

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>iris.plot &mdash; Iris 3.0.0rc0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/theme_override.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/iris-logo-title.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installing.html">Installing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/gallery/index.html">Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/iris_cubes.html">Iris data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/loading_iris_cubes.html">Loading Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/saving_iris_cubes.html">Saving Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/navigating_a_cube.html">Navigating a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/subsetting_a_cube.html">Subsetting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/real_and_lazy_data.html">Real and lazy data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/plotting_a_cube.html">Plotting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/interpolation_and_regridding.html">Cube interpolation and regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/merge_and_concat.html">Merge and concatenate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_statistics.html">Cube statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_maths.html">Cube maths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/citation.html">Citing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/code_maintenance.html">Code maintenance</a></li>
</ul>
<p class="caption"><span class="caption-text">Further Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/lenient_metadata.html">Lenient metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/lenient_maths.html">Lenient cube maths</a></li>
</ul>
<p class="caption"><span class="caption-text">Developers Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_getting_involved.html">Getting involved</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/gitwash/index.html">Working with Iris source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_documentation.html">Contributing to the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_codebase_index.html">Contributing to the code base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_changes.html">Contributing your changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/release.html">Releases</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/iris.html">Iris API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../whatsnew/index.html">Whatâ€™s new in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../techpapers/index.html">Iris technical papers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Iris copyright, licensing and contributors</a></li>
</ul>

            
          

    
    
    
        <p class="caption">
            <span class="caption-text">
            
                Support
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SciTools/iris"><i class="fa fa-github fa-fw"></i> Source code</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris"><i class="fa fa-comments fa-fw"></i> Users Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris-dev"><i class="fa fa-comments fa-fw"></i> Developers Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://stackoverflow.com/questions/tagged/python-iris"><i class="fa fa-question fa-fw"></i> StackOverflow for "How do I?"</a></li>
            
                <li class="toctree-l1"><a href="https://scitools.org.uk/iris/docs/v2.4.0/index.html"><i class="fa fa-book fa-fw"></i> Legacy documentation</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Iris</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../iris.html">iris</a> &raquo;</li>
        
      <li>iris.plot</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for iris.plot</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Iris contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Iris and is released under the LGPL license.</span>
<span class="c1"># See COPYING and COPYING.LESSER in the root of the repository for full</span>
<span class="c1"># licensing details.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Iris-specific extensions to matplotlib, mimicking the :mod:`matplotlib.pyplot`</span>
<span class="sd">interface.</span>

<span class="sd">See also: :ref:`matplotlib &lt;matplotlib:users-guide-index&gt;`.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">import</span> <span class="nn">cartopy.crs</span> <span class="k">as</span> <span class="nn">ccrs</span>
<span class="kn">import</span> <span class="nn">cartopy.mpl.geoaxes</span>
<span class="kn">from</span> <span class="nn">cartopy.geodesic</span> <span class="kn">import</span> <span class="n">Geodesic</span>
<span class="kn">import</span> <span class="nn">cftime</span>
<span class="kn">import</span> <span class="nn">matplotlib.axes</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="k">as</span> <span class="nn">mpl_collections</span>
<span class="kn">import</span> <span class="nn">matplotlib.dates</span> <span class="k">as</span> <span class="nn">mpl_dates</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.offsetbox</span> <span class="kn">import</span> <span class="n">AnchoredText</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">mpl_ticker</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">mpl_transforms</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="kn">import</span> <span class="nn">iris.cube</span>
<span class="kn">import</span> <span class="nn">iris.analysis.cartography</span> <span class="k">as</span> <span class="nn">cartography</span>
<span class="kn">import</span> <span class="nn">iris.coords</span>
<span class="kn">import</span> <span class="nn">iris.coord_systems</span>
<span class="kn">from</span> <span class="nn">iris.exceptions</span> <span class="kn">import</span> <span class="n">IrisError</span>

<span class="c1"># Importing iris.palette to register the brewer palettes.</span>
<span class="kn">import</span> <span class="nn">iris.palette</span>
<span class="kn">from</span> <span class="nn">iris.util</span> <span class="kn">import</span> <span class="n">_meshgrid</span>

<span class="c1"># Cynthia Brewer citation text.</span>
<span class="n">BREWER_CITE</span> <span class="o">=</span> <span class="s2">&quot;Colours based on ColorBrewer.org&quot;</span>

<span class="n">PlotDefn</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;PlotDefn&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="s2">&quot;transpose&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_get_plot_defn_custom_coords_picked</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dim=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># Pass through valid dimension indexes.</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="o">&gt;=</span> <span class="n">ndims</span><span class="p">:</span>
                <span class="n">emsg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;The data dimension (</span><span class="si">{}</span><span class="s2">) is out of range for &quot;</span>
                    <span class="s2">&quot;the dimensionality of the required plot (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">ndims</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coord</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">as_coord</span><span class="p">,</span> <span class="n">coords</span><span class="p">))</span>

    <span class="c1"># Check that we were given the right number of coordinates/dimensions.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The list of coordinates given (</span><span class="si">%s</span><span class="s2">) should have the&quot;</span>
            <span class="s2">&quot; same length (</span><span class="si">%s</span><span class="s2">) as the dimensionality of the&quot;</span>
            <span class="s2">&quot; required plot (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">names</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">ndims</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Check which dimensions are spanned by each coordinate.</span>
    <span class="k">def</span> <span class="nf">get_span</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">span</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">coord</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">span</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">span</span>

    <span class="n">spans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_span</span><span class="p">,</span> <span class="n">coords</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">span</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spans</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">span</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The coordinate </span><span class="si">{!r}</span><span class="s2"> doesn&#39;t span a data dimension.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">BOUND_MODE</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">span</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The coordinate </span><span class="si">{!r}</span><span class="s2"> has </span><span class="si">{}</span><span class="s2"> dimensions.&quot;</span>
                <span class="s2">&quot;Cell-based plotting is only supported for&quot;</span>
                <span class="s2">&quot;coordinates with one or two dimensions.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># Check the combination of coordinates spans enough (ndims) data</span>
    <span class="c1"># dimensions.</span>
    <span class="n">total_span</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">spans</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_span</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The given coordinates (</span><span class="si">{}</span><span class="s2">) don&#39;t span the </span><span class="si">{}</span><span class="s2"> data&quot;</span>
            <span class="s2">&quot; dimensions.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">names</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">ndims</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># If we have 2-dimensional data, and one or more 1-dimensional</span>
    <span class="c1"># coordinates, check if we need to transpose.</span>
    <span class="n">transpose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">spans</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">span</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spans</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">span</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">span</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">transpose</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

    <span class="c1"># Note the use of `reversed` to convert from the X-then-Y</span>
    <span class="c1"># convention of the end-user API to the V-then-U convention used by</span>
    <span class="c1"># the plotting routines.</span>
    <span class="n">plot_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">PlotDefn</span><span class="p">(</span><span class="n">plot_coords</span><span class="p">,</span> <span class="n">transpose</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_valid_bound_dim_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">coord</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">nbounds</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">coord</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_get_plot_defn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return data and plot-axis coords given a cube &amp; a mode of either</span>
<span class="sd">    POINT_MODE or BOUND_MODE.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cube</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">ndims</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cube must be </span><span class="si">%s</span><span class="s2">-dimensional. Got </span><span class="si">%s</span><span class="s2"> dimensions.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">ndims</span><span class="p">,</span> <span class="n">cube</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

    <span class="c1"># Start by taking the DimCoords from each dimension.</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndims</span>
    <span class="k">for</span> <span class="n">dim_coord</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">:</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim_coord</span>

    <span class="c1"># When appropriate, restrict to 1D with bounds.</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">BOUND_MODE</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_valid_bound_dim_coord</span><span class="p">,</span> <span class="n">coords</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">guess_axis</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">guess_coord_axis</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axis</span>

    <span class="c1"># Allow DimCoords in aux_coords to fill in for missing dim_coords.</span>
    <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aux_coords</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">aux_coords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">aux_coords</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">aux_coords</span><span class="p">:</span>
                <span class="n">aux_coords</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If plotting a 2 dimensional plot, check for 2d coordinates</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">missing_dims</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_dims</span><span class="p">:</span>
            <span class="c1"># Note that this only picks up coordinates that span the dims</span>
            <span class="n">two_dim_coords</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="n">missing_dims</span><span class="p">)</span>
            <span class="n">two_dim_coords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">two_dim_coords</span> <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_dim_coords</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">two_dim_coords</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">two_dim_coords</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">POINT_MODE</span><span class="p">:</span>
        <span class="c1"># Allow multi-dimensional aux_coords to override the dim_coords</span>
        <span class="c1"># along the Z axis. This results in a preference for using the</span>
        <span class="c1"># derived altitude over model_level_number or level_height.</span>
        <span class="c1"># Limit to Z axis to avoid preferring latitude over grid_latitude etc.</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">guess_axis</span><span class="p">,</span> <span class="n">coords</span><span class="p">))</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dim_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">guess_coord_axis</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="n">axis</span>
                <span class="p">):</span>
                    <span class="n">coords</span><span class="p">[</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)]</span> <span class="o">=</span> <span class="n">coord</span>

    <span class="c1"># Re-order the coordinates to achieve the preferred</span>
    <span class="c1"># horizontal/vertical associations. If we can&#39;t associate</span>
    <span class="c1"># an axis to order the coordinates, fall back to using the cube dimension</span>
    <span class="c1"># followed by the name of the coordinate.</span>
    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">guess_axis</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">order</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord</span><span class="p">),</span>
            <span class="n">coord</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="n">sorted_coords</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">)</span>

    <span class="n">transpose</span> <span class="o">=</span> <span class="n">sorted_coords</span> <span class="o">!=</span> <span class="n">coords</span>
    <span class="k">return</span> <span class="n">PlotDefn</span><span class="p">(</span><span class="n">sorted_coords</span><span class="p">,</span> <span class="n">transpose</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_can_draw_map</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
    <span class="n">std_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">c</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">standard_name</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">valid_std_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;longitude&quot;</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;grid_latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;grid_longitude&quot;</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;projection_y_coordinate&quot;</span><span class="p">,</span> <span class="s2">&quot;projection_x_coordinate&quot;</span><span class="p">],</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">std_names</span> <span class="ow">in</span> <span class="n">valid_std_names</span>


<span class="k">def</span> <span class="nf">_broadcast_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="c1"># Matplotlib needs the U and V coordinates to have the same</span>
    <span class="c1"># dimensionality (either both 1D, or both 2D). So we simply</span>
    <span class="c1"># broadcast both to 2D to be on the safe side.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">_string_coord_axis_tick_labels</span><span class="p">(</span><span class="n">string_axes</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply tick labels for string coordinates.&quot;&quot;&quot;</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ticks</span> <span class="ow">in</span> <span class="n">string_axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Define a tick formatter. This will assign a label to all ticks</span>
        <span class="c1"># located precisely on  an integer in range(len(ticks)) and assign</span>
        <span class="c1"># an empty string to any other ticks.</span>
        <span class="k">def</span> <span class="nf">ticker_func</span><span class="p">(</span><span class="n">tick_location</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
            <span class="n">tick_locations</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ticks</span><span class="p">))</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">ticks</span>
            <span class="n">label_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tick_locations</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">label_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tick_location</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">label</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">mpl_ticker</span><span class="o">.</span><span class="n">FuncFormatter</span><span class="p">(</span><span class="n">ticker_func</span><span class="p">)</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">mpl_ticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">this_axis</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">this_axis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
        <span class="n">this_axis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_invert_yaxis</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts the y-axis of the current plot based on conditions:</span>

<span class="sd">        * If the y-axis is already inverted we don&#39;t want to re-invert it.</span>
<span class="sd">        * If v_coord is None then it will not have any attributes.</span>
<span class="sd">        * If neither of the above are true then invert y if v_coord has</span>
<span class="sd">          attribute &#39;positive&#39; set to &#39;down&#39;.</span>

<span class="sd">    Args:</span>

<span class="sd">        * v_coord - the coord to be plotted on the y-axis</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">yaxis_is_inverted</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">yaxis_inverted</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">yaxis_is_inverted</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">):</span>
        <span class="n">attr_pve</span> <span class="o">=</span> <span class="n">v_coord</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;positive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr_pve</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">attr_pve</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_check_bounds_contiguity_and_mask</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks that any discontiguities in the bounds of the given coordinate only</span>
<span class="sd">    occur where the data is masked.</span>

<span class="sd">    Where a discontinuity occurs the grid created for plotting will not be</span>
<span class="sd">    correct. This does not matter if the data is masked in that location as</span>
<span class="sd">    this is not plotted.</span>

<span class="sd">    If a discontiguity occurs where the data is *not* masked, an error is</span>
<span class="sd">    raised.</span>

<span class="sd">    Args:</span>
<span class="sd">        coord: (iris.coord.Coord)</span>
<span class="sd">            Coordinate the bounds of which will be checked for contiguity</span>
<span class="sd">        data: (array)</span>
<span class="sd">            Data of the the cube we are plotting</span>
<span class="sd">        atol:</span>
<span class="sd">            Absolute tolerance when checking the contiguity. Defaults to None.</span>
<span class="sd">            If an absolute tolerance is not set, 1D coords are not checked (so</span>
<span class="sd">            as to not introduce a breaking change without a major release) but</span>
<span class="sd">            2D coords are always checked, by calling</span>
<span class="sd">            :meth:`iris.coords.Coord._discontiguity_in_bounds` with its default</span>
<span class="sd">            tolerance.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">data_is_masked</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;mask&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data_is_masked</span><span class="p">:</span>
        <span class="c1"># When checking the location of the discontiguities, we check against</span>
        <span class="c1"># the opposite of the mask, which is True where data exists.</span>
        <span class="n">mask_invert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># 1D coords are only checked if an absolute tolerance is set, to avoid</span>
        <span class="c1"># introducing a breaking change.</span>
        <span class="k">if</span> <span class="n">atol</span><span class="p">:</span>
            <span class="n">contiguous</span><span class="p">,</span> <span class="n">diffs</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">_discontiguity_in_bounds</span><span class="p">(</span><span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">contiguous</span> <span class="ow">and</span> <span class="n">data_is_masked</span><span class="p">:</span>
                <span class="n">not_masked_at_discontiguity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask_invert</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">diffs</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>

    <span class="k">elif</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atol</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;atol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atol</span>
        <span class="k">if</span> <span class="n">rtol</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;rtol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rtol</span>
        <span class="n">contiguous</span><span class="p">,</span> <span class="n">diffs</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">_discontiguity_in_bounds</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">contiguous</span> <span class="ow">and</span> <span class="n">data_is_masked</span><span class="p">:</span>
            <span class="n">diffs_along_x</span><span class="p">,</span> <span class="n">diffs_along_y</span> <span class="o">=</span> <span class="n">diffs</span>

            <span class="c1"># Check along both dimensions that any discontiguous</span>
            <span class="c1"># points are correctly masked.</span>
            <span class="n">not_masked_at_discontiguity_along_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask_invert</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">diffs_along_x</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">not_masked_at_discontiguity_along_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask_invert</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">diffs_along_y</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">not_masked_at_discontiguity</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">not_masked_at_discontiguity_along_x</span>
                <span class="ow">or</span> <span class="n">not_masked_at_discontiguity_along_y</span>
            <span class="p">)</span>

    <span class="c1"># If any discontiguity occurs where the data is not masked the grid will be</span>
    <span class="c1"># created incorrectly, so raise an error.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">contiguous</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_is_masked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The bounds of the </span><span class="si">{}</span><span class="s2"> coordinate are not &quot;</span>
                <span class="s2">&quot;contiguous. Not able to create a suitable grid&quot;</span>
                <span class="s2">&quot;to plot. You can use &quot;</span>
                <span class="s2">&quot;iris.util.find_discontiguities() to identify &quot;</span>
                <span class="s2">&quot;discontiguities in your x and y coordinate &quot;</span>
                <span class="s2">&quot;bounds arrays.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">not_masked_at_discontiguity</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The bounds of the </span><span class="si">{}</span><span class="s2"> coordinate are not &quot;</span>
                <span class="s2">&quot;contiguous and data is not masked where the &quot;</span>
                <span class="s2">&quot;discontiguity occurs. Not able to create a &quot;</span>
                <span class="s2">&quot;suitable grid to plot. You can use &quot;</span>
                <span class="s2">&quot;iris.util.find_discontiguities() to identify &quot;</span>
                <span class="s2">&quot;discontiguities in your x and y coordinate &quot;</span>
                <span class="s2">&quot;bounds arrays, and then mask them with &quot;</span>
                <span class="s2">&quot;iris.util.mask_cube()&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="p">)</span>


<span class="k">def</span> <span class="nf">_draw_2d_from_bounds</span><span class="p">(</span><span class="n">draw_method_name</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># NB. In the interests of clarity we use &quot;u&quot; and &quot;v&quot; to refer to the</span>
    <span class="c1"># horizontal and vertical axes on the matplotlib plot.</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">BOUND_MODE</span>
    <span class="c1"># Get &amp; remove the coords entry from kwargs.</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plot_defn</span> <span class="o">=</span> <span class="n">_get_plot_defn_custom_coords_picked</span><span class="p">(</span>
            <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plot_defn</span> <span class="o">=</span> <span class="n">_get_plot_defn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">contig_tol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;contiguity_tolerance&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="s2">&quot;has_bounds&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">_check_bounds_contiguity_and_mask</span><span class="p">(</span>
                <span class="n">coord</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">contig_tol</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">_can_draw_map</span><span class="p">(</span><span class="n">plot_defn</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_map_common</span><span class="p">(</span>
            <span class="n">draw_method_name</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">BOUND_MODE</span><span class="p">,</span>
            <span class="n">cube</span><span class="p">,</span>
            <span class="n">plot_defn</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Obtain data array.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">transpose</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Obtain U and V coordinates</span>
        <span class="n">v_coord</span><span class="p">,</span> <span class="n">u_coord</span> <span class="o">=</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">coords</span>

        <span class="c1"># Track numpy arrays to use for the actual plotting.</span>
        <span class="n">plot_arrays</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Map axis name to associated values.</span>
        <span class="n">string_axes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">data_dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="p">[</span><span class="n">u_coord</span><span class="p">,</span> <span class="n">v_coord</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;xaxis&quot;</span><span class="p">,</span> <span class="s2">&quot;yaxis&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">data_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">coord</span> <span class="k">if</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">transpose</span> <span class="k">else</span> <span class="n">coord</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;SU&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Coord </span><span class="si">{!r}</span><span class="s2"> must be one-dimensional.&quot;</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot plot bounded string coordinate.&quot;</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">string_axes</span><span class="p">[</span><span class="n">axis_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">data_dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">()</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">_fixup_dates</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span>
                    <span class="p">):</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="n">mpl_dates</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

            <span class="n">plot_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">plot_arrays</span>

        <span class="c1"># If the data is transposed, 2D coordinates will also need to be</span>
        <span class="c1"># transposed.</span>
        <span class="k">if</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">transpose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">coord</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_broadcast_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axes&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">draw_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="p">,</span> <span class="n">draw_method_name</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">draw_method</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Apply tick labels for string coordinates.</span>
        <span class="n">_string_coord_axis_tick_labels</span><span class="p">(</span><span class="n">string_axes</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Invert y-axis if necessary.</span>
        <span class="n">_invert_yaxis</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_draw_2d_from_points</span><span class="p">(</span><span class="n">draw_method_name</span><span class="p">,</span> <span class="n">arg_func</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># NB. In the interests of clarity we use &quot;u&quot; and &quot;v&quot; to refer to the</span>
    <span class="c1"># horizontal and vertical axes on the matplotlib plot.</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">POINT_MODE</span>
    <span class="c1"># Get &amp; remove the coords entry from kwargs.</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plot_defn</span> <span class="o">=</span> <span class="n">_get_plot_defn_custom_coords_picked</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plot_defn</span> <span class="o">=</span> <span class="n">_get_plot_defn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_can_draw_map</span><span class="p">(</span><span class="n">plot_defn</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_map_common</span><span class="p">(</span>
            <span class="n">draw_method_name</span><span class="p">,</span>
            <span class="n">arg_func</span><span class="p">,</span>
            <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">POINT_MODE</span><span class="p">,</span>
            <span class="n">cube</span><span class="p">,</span>
            <span class="n">plot_defn</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Obtain data array.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">transpose</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># Also transpose the scatter marker color array,</span>
            <span class="c1"># as now mpl 2.x does not do this for free.</span>
            <span class="k">if</span> <span class="n">draw_method_name</span> <span class="o">==</span> <span class="s2">&quot;scatter&quot;</span> <span class="ow">and</span> <span class="s2">&quot;c&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Obtain U and V coordinates</span>
        <span class="n">v_coord</span><span class="p">,</span> <span class="n">u_coord</span> <span class="o">=</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">coords</span>
        <span class="k">if</span> <span class="n">u_coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u_coord</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">u_coord</span> <span class="k">if</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">transpose</span> <span class="k">else</span> <span class="n">u_coord</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u_coord</span><span class="o">.</span><span class="n">points</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">_fixup_dates</span><span class="p">(</span><span class="n">u_coord</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v_coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">v_coord</span> <span class="k">if</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">transpose</span> <span class="k">else</span> <span class="n">v_coord</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v_coord</span><span class="o">.</span><span class="n">points</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">_fixup_dates</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">transpose</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Track numpy arrays to use for the actual plotting.</span>
        <span class="n">plot_arrays</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Map axis name to associated values.</span>
        <span class="n">string_axes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;xaxis&quot;</span><span class="p">,</span> <span class="s2">&quot;yaxis&quot;</span><span class="p">]):</span>
            <span class="c1"># Replace any string coordinates with &quot;index&quot; coordinates.</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;SU&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Multi-dimensional string coordinates &quot;</span>
                        <span class="s2">&quot;not supported.&quot;</span>
                    <span class="p">)</span>
                <span class="n">plot_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
                <span class="n">string_axes</span><span class="p">[</span><span class="n">axis_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">elif</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span>
            <span class="p">):</span>
                <span class="n">plot_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpl_dates</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">plot_arrays</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_broadcast_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axes&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">draw_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="p">,</span> <span class="n">draw_method_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arg_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">arg_func</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">draw_method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">draw_method</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Apply tick labels for string coordinates.</span>
        <span class="n">_string_coord_axis_tick_labels</span><span class="p">(</span><span class="n">string_axes</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Invert y-axis if necessary.</span>
        <span class="n">_invert_yaxis</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_fixup_dates</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">calendar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Convert coordinate values into tuples of</span>
        <span class="c1"># (year, month, day, hour, min, sec)</span>
        <span class="n">dates</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">calendar</span> <span class="o">==</span> <span class="s2">&quot;gregorian&quot;</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">date</span><span class="p">)</span> <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">dates</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">nc_time_axis</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Cannot plot against time in a non-gregorian &quot;</span>
                    <span class="s1">&#39;calendar, because &quot;nc_time_axis&quot; is not available :  &#39;</span>
                    <span class="s2">&quot;Install the package from &quot;</span>
                    <span class="s2">&quot;https://github.com/SciTools/nc-time-axis to enable &quot;</span>
                    <span class="s2">&quot;this usage.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">IrisError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">r</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">nc_time_axis</span><span class="o">.</span><span class="n">CalendarDateTime</span><span class="p">(</span>
                    <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">date</span><span class="p">),</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">calendar</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">dates</span>
            <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">values</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">_data_from_coord_or_cube</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_fixup_dates</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Plot arguments must be cubes or coordinates.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_uv_from_u_object_v_object</span><span class="p">(</span><span class="n">u_object</span><span class="p">,</span> <span class="n">v_object</span><span class="p">):</span>
    <span class="n">ndim_msg</span> <span class="o">=</span> <span class="s2">&quot;Cube or coordinate must be 1-dimensional. Got </span><span class="si">{}</span><span class="s2"> dimensions.&quot;</span>
    <span class="k">if</span> <span class="n">u_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">u_object</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">ndim_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u_object</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">v_object</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">ndim_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v_object</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_data_from_coord_or_cube</span><span class="p">(</span><span class="n">v_object</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">_data_from_coord_or_cube</span><span class="p">(</span><span class="n">u_object</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">_u_object_from_v_object</span><span class="p">(</span><span class="n">v_object</span><span class="p">):</span>
    <span class="n">u_object</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v_object</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
        <span class="n">plot_defn</span> <span class="o">=</span> <span class="n">_get_plot_defn</span><span class="p">(</span><span class="n">v_object</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">POINT_MODE</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">u_object</span><span class="p">,)</span> <span class="o">=</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">coords</span>
    <span class="k">return</span> <span class="n">u_object</span>


<span class="k">def</span> <span class="nf">_get_plot_objects</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="c1"># two arguments</span>
        <span class="n">u_object</span><span class="p">,</span> <span class="n">v_object</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_uv_from_u_object_v_object</span><span class="p">(</span><span class="n">u_object</span><span class="p">,</span> <span class="n">v_object</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;The x and y-axis objects are not compatible. They should &quot;</span>
                <span class="s2">&quot;have equal sizes but got (</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">) and (</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u_object</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v_object</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># single argument</span>
        <span class="n">v_object</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">u_object</span> <span class="o">=</span> <span class="n">_u_object_from_v_object</span><span class="p">(</span><span class="n">v_object</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_uv_from_u_object_v_object</span><span class="p">(</span><span class="n">u_object</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">u_object</span><span class="p">,</span> <span class="n">v_object</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">args</span>


<span class="k">def</span> <span class="nf">_get_geodesic_params</span><span class="p">(</span><span class="n">globe</span><span class="p">):</span>
    <span class="c1"># Derive the semimajor axis and flattening values for a given globe from</span>
    <span class="c1"># its attributes. If the values are under specified, raise a ValueError</span>
    <span class="n">flattening</span> <span class="o">=</span> <span class="n">globe</span><span class="o">.</span><span class="n">flattening</span>
    <span class="n">semimajor</span> <span class="o">=</span> <span class="n">globe</span><span class="o">.</span><span class="n">semimajor_axis</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">semimajor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Has semiminor or raises error</span>
            <span class="k">if</span> <span class="n">flattening</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Has inverse flattening or raises error</span>
                <span class="n">flattening</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">globe</span><span class="o">.</span><span class="n">inverse_flattening</span>
            <span class="n">semimajor</span> <span class="o">=</span> <span class="n">globe</span><span class="o">.</span><span class="n">semiminor_axis</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">flattening</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">flattening</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">globe</span><span class="o">.</span><span class="n">semiminor_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flattening</span> <span class="o">=</span> <span class="p">(</span><span class="n">semimajor</span> <span class="o">-</span> <span class="n">globe</span><span class="o">.</span><span class="n">semiminor_axis</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span>
                    <span class="n">semimajor</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Has inverse flattening or raises error</span>
                <span class="n">flattening</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">globe</span><span class="o">.</span><span class="n">inverse_flattening</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># One of the required attributes was None</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The globe was underspecified.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">semimajor</span><span class="p">,</span> <span class="n">flattening</span>


<span class="k">def</span> <span class="nf">_shift_plot_sections</span><span class="p">(</span><span class="n">u_object</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shifts subsections of u by multiples of 360 degrees within ranges</span>
<span class="sd">    defined by the points where the line should cross over the 0/360 degree</span>
<span class="sd">    longitude boundary.</span>

<span class="sd">    e.g. [ 300, 100, 200, 300, 100, 300 ] =&gt; [ 300, 460, 560, 660, 820, 660 ]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert coordinates to true lat-lon</span>
    <span class="n">src_crs</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">u_object</span><span class="o">.</span><span class="n">coord_system</span><span class="o">.</span><span class="n">as_cartopy_crs</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">u_object</span><span class="o">.</span><span class="n">coord_system</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Geodetic</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">tgt_crs</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Geodetic</span><span class="p">(</span><span class="n">globe</span><span class="o">=</span><span class="n">src_crs</span><span class="o">.</span><span class="n">globe</span><span class="p">)</span>
    <span class="n">tgt_proj</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(</span><span class="n">globe</span><span class="o">=</span><span class="n">src_crs</span><span class="o">.</span><span class="n">globe</span><span class="p">)</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">tgt_crs</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">src_crs</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">startpoints</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">endpoints</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">proj_x</span><span class="p">,</span> <span class="n">proj_y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tgt_proj</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">src_crs</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Calculate the inverse geodesic for each pair of points in turn, and</span>
    <span class="c1"># convert the start point&#39;s azimuth into a vector in the source coordinate</span>
    <span class="c1"># system.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">radius</span><span class="p">,</span> <span class="n">flattening</span> <span class="o">=</span> <span class="n">_get_geodesic_params</span><span class="p">(</span><span class="n">src_crs</span><span class="o">.</span><span class="n">globe</span><span class="p">)</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="n">Geodesic</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">flattening</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">geodesic</span> <span class="o">=</span> <span class="n">Geodesic</span><span class="p">()</span>
    <span class="n">dists</span><span class="p">,</span> <span class="n">azms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">startpoints</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">azms_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">azms</span><span class="p">))</span>
    <span class="n">azms_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">azms</span><span class="p">))</span>
    <span class="n">azms_u</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">src_crs</span><span class="o">.</span><span class="n">transform_vectors</span><span class="p">(</span>
        <span class="n">tgt_proj</span><span class="p">,</span> <span class="n">proj_x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">proj_y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">azms_lon</span><span class="p">,</span> <span class="n">azms_lat</span>
    <span class="p">)</span>

    <span class="c1"># Use the grid longitude values and the geodesic azimuth to determine</span>
    <span class="c1"># the points where the line should cross the 0/360 degree boundary, and</span>
    <span class="c1"># in which direction</span>
    <span class="n">lwraps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">azms_u</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rwraps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">azms_u</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rwraps</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lwraps</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">shift_vals</span> <span class="o">=</span> <span class="n">shifts</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">*</span> <span class="n">u_object</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span>
    <span class="n">new_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">new_u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">new_u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">shift_vals</span>
    <span class="k">return</span> <span class="n">new_u</span>


<span class="k">def</span> <span class="nf">_draw_1d_from_points</span><span class="p">(</span><span class="n">draw_method_name</span><span class="p">,</span> <span class="n">arg_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># NB. In the interests of clarity we use &quot;u&quot; to refer to the horizontal</span>
    <span class="c1"># axes on the matplotlib plot and &quot;v&quot; for the vertical axes.</span>

    <span class="c1"># retrieve the objects that are plotted on the horizontal and vertical</span>
    <span class="c1"># axes (cubes or coordinates) and their respective values, along with the</span>
    <span class="c1"># argument tuple with these objects removed</span>
    <span class="n">u_object</span><span class="p">,</span> <span class="n">v_object</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">_get_plot_objects</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># Track numpy arrays to use for the actual plotting.</span>
    <span class="n">plot_arrays</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Map axis name to associated values.</span>
    <span class="n">string_axes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;xaxis&quot;</span><span class="p">,</span> <span class="s2">&quot;yaxis&quot;</span><span class="p">]):</span>
        <span class="c1"># Replace any string coordinates with &quot;index&quot; coordinates.</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;SU&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Multi-dimensional string coordinates are not supported.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">plot_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
            <span class="n">string_axes</span><span class="p">[</span><span class="n">axis_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plot_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">plot_arrays</span>

    <span class="c1"># if both u_object and v_object are coordinates then check if a map</span>
    <span class="c1"># should be drawn</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">u_object</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v_object</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">_can_draw_map</span><span class="p">([</span><span class="n">v_object</span><span class="p">,</span> <span class="n">u_object</span><span class="p">])</span>
    <span class="p">):</span>
        <span class="c1"># Replace non-cartopy subplot/axes with a cartopy alternative and set</span>
        <span class="c1"># the transform keyword.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_ensure_cartopy_axes_and_determine_kwargs</span><span class="p">(</span>
            <span class="n">u_object</span><span class="p">,</span> <span class="n">v_object</span><span class="p">,</span> <span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">draw_method_name</span> <span class="o">==</span> <span class="s2">&quot;plot&quot;</span> <span class="ow">and</span> <span class="n">u_object</span><span class="o">.</span><span class="n">standard_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;projection_x_coordinate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;projection_y_coordinate&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">_shift_plot_sections</span><span class="p">(</span><span class="n">u_object</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="n">axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axes&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">draw_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="p">,</span> <span class="n">draw_method_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arg_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">arg_func</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">draw_method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">draw_method</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Apply tick labels for string coordinates.</span>
    <span class="n">_string_coord_axis_tick_labels</span><span class="p">(</span><span class="n">string_axes</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="c1"># Invert y-axis if necessary.</span>
    <span class="n">_invert_yaxis</span><span class="p">(</span><span class="n">v_object</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_replace_axes_with_cartopy_axes</span><span class="p">(</span><span class="n">cartopy_proj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace non-cartopy subplot/axes with a cartopy alternative</span>
<span class="sd">    based on the provided projection. If the current axes are already an</span>
<span class="sd">    instance of :class:`cartopy.mpl.geoaxes.GeoAxes` then no action is taken.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">cartopy</span><span class="o">.</span><span class="n">mpl</span><span class="o">.</span><span class="n">geoaxes</span><span class="o">.</span><span class="n">GeoAxes</span><span class="p">):</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">SubplotBase</span><span class="p">):</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">get_subplotspec</span><span class="p">(),</span>
                <span class="n">projection</span><span class="o">=</span><span class="n">cartopy_proj</span><span class="p">,</span>
                <span class="n">title</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">get_title</span><span class="p">(),</span>
                <span class="n">xlabel</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xlabel</span><span class="p">(),</span>
                <span class="n">ylabel</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylabel</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span>
                <span class="n">projection</span><span class="o">=</span><span class="n">cartopy_proj</span><span class="p">,</span>
                <span class="n">title</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">get_title</span><span class="p">(),</span>
                <span class="n">xlabel</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xlabel</span><span class="p">(),</span>
                <span class="n">ylabel</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylabel</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="c1"># delete the axes which didn&#39;t have a cartopy projection</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">delaxes</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ensure_cartopy_axes_and_determine_kwargs</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace the current non-cartopy axes with :class:`cartopy.mpl.GeoAxes`</span>
<span class="sd">    and return the appropriate kwargs dict based on the provided coordinates</span>
<span class="sd">    and kwargs.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine projection.</span>
    <span class="k">if</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">coord_system</span> <span class="o">!=</span> <span class="n">y_coord</span><span class="o">.</span><span class="n">coord_system</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The X and Y coordinates must have equal coordinate&quot;</span> <span class="s2">&quot; systems.&quot;</span>
        <span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">coord_system</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cartopy_proj</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">as_cartopy_projection</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cartopy_proj</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">()</span>

    <span class="c1"># Ensure the current axes are a cartopy.mpl.GeoAxes instance.</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;axes&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coord_systems</span><span class="o">.</span><span class="n">RotatedGeogCS</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">180</span>
            <span class="ow">and</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">360</span>
            <span class="ow">and</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="c1"># The RotatedGeogCS has 0 - 360 extent, different from the</span>
            <span class="c1"># assumptions made by Cartopy: rebase longitudes for the map axes</span>
            <span class="c1"># to set the datum longitude to the International Date Line.</span>
            <span class="n">cs_kwargs</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">_ccrs_kwargs</span><span class="p">()</span>
            <span class="n">cs_kwargs</span><span class="p">[</span><span class="s2">&quot;central_rotated_longitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">180.0</span>
            <span class="n">adapted_cartopy_proj</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">RotatedPole</span><span class="p">(</span><span class="o">**</span><span class="n">cs_kwargs</span><span class="p">)</span>
            <span class="n">_replace_axes_with_cartopy_axes</span><span class="p">(</span><span class="n">adapted_cartopy_proj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_replace_axes_with_cartopy_axes</span><span class="p">(</span><span class="n">cartopy_proj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">axes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">cartopy</span><span class="o">.</span><span class="n">mpl</span><span class="o">.</span><span class="n">geoaxes</span><span class="o">.</span><span class="n">GeoAxes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The supplied axes instance must be a cartopy &quot;</span> <span class="s2">&quot;GeoAxes instance.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Set the &quot;from transform&quot; keyword.</span>
    <span class="k">if</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;transform&#39; keyword is not allowed as it &quot;</span>
            <span class="s2">&quot;automatically determined from the coordinate &quot;</span>
            <span class="s2">&quot;metadata.&quot;</span>
        <span class="p">)</span>
    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cartopy_proj</span>

    <span class="k">return</span> <span class="n">new_kwargs</span>


<span class="k">def</span> <span class="nf">_check_geostationary_coords_and_convert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Geostationary stores projected coordinates as scanning angles (</span>
    <span class="c1"># radians), in line with CF definition (this behaviour is unique to</span>
    <span class="c1"># Geostationary). Before plotting, must be converted by multiplying by</span>
    <span class="c1"># satellite height.</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;transform&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">cartopy</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">Geostationary</span><span class="p">):</span>
        <span class="n">satellite_height</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">proj4_params</span><span class="p">[</span><span class="s2">&quot;h&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">*=</span> <span class="n">satellite_height</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">_map_common</span><span class="p">(</span>
    <span class="n">draw_method_name</span><span class="p">,</span> <span class="n">arg_func</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">plot_defn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draw the given cube on a map using its points or bounds.</span>

<span class="sd">    &quot;Mode&quot; parameter will switch functionality between POINT or BOUND plotting.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate 2d x and 2d y grids.</span>
    <span class="n">y_coord</span><span class="p">,</span> <span class="n">x_coord</span> <span class="o">=</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">coords</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">POINT_MODE</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">y_coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_meshgrid</span><span class="p">(</span><span class="n">x_coord</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">y_coord</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">y_coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">points</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y_coord</span><span class="o">.</span><span class="n">points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected 1D or 2D XY coords&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">y_coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_meshgrid</span><span class="p">(</span>
                    <span class="n">x_coord</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">(),</span> <span class="n">y_coord</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="c1"># Exception translation.</span>
            <span class="k">except</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Expected two 1D coords. Could not get XY&quot;</span>
                    <span class="s2">&quot; grid from bounds. X or Y coordinate not&quot;</span>
                    <span class="s2">&quot; 1D.&quot;</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not get XY grid from bounds. &quot;</span>
                    <span class="s2">&quot;X or Y coordinate doesn&#39;t have 2 bounds &quot;</span>
                    <span class="s2">&quot;per point.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x_coord</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">()</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y_coord</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">()</span>

    <span class="c1"># Obtain the data array.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">transpose</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># If we are global, then append the first column of data the array to the</span>
    <span class="c1"># last (and add 360 degrees) NOTE: if it is found that this block of code</span>
    <span class="c1"># is useful in anywhere other than this plotting routine, it may be better</span>
    <span class="c1"># placed in the CS.</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">monotonic</span><span class="p">(</span>
            <span class="n">x_coord</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">return_direction</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">360</span> <span class="o">*</span> <span class="n">direction</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_v_data&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">v_data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;_v_data&quot;</span><span class="p">]</span>
            <span class="n">v_data</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">v_data</span><span class="p">,</span> <span class="n">v_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;_v_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_data</span>

    <span class="c1"># Replace non-cartopy subplot/axes with a cartopy alternative and set the</span>
    <span class="c1"># transform keyword.</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_ensure_cartopy_axes_and_determine_kwargs</span><span class="p">(</span>
        <span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="c1"># Make Geostationary coordinates plot-able.</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_check_geostationary_coords_and_convert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">arg_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">arg_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>

    <span class="c1"># Draw the contour lines/filled contours.</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axes&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">plotfn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="p">,</span> <span class="n">draw_method_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">plotfn</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="contour"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.contour">[docs]</a><span class="k">def</span> <span class="nf">contour</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws contour lines based on the given Cube.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * coords: list of :class:`~iris.coords.Coord` objects or</span>
<span class="sd">        coordinate names. Use the given coordinates as the axes for the</span>
<span class="sd">        plot. The order of the given coordinates indicates which axis</span>
<span class="sd">        to use for each, where the first element is the horizontal</span>
<span class="sd">        axis of the plot and the second element is the vertical axis</span>
<span class="sd">        of the plot.</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    See :func:`matplotlib.pyplot.contour` for details of other valid</span>
<span class="sd">    keyword arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_draw_2d_from_points</span><span class="p">(</span><span class="s2">&quot;contour&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="contourf"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.contourf">[docs]</a><span class="k">def</span> <span class="nf">contourf</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws filled contours based on the given Cube.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * coords: list of :class:`~iris.coords.Coord` objects or</span>
<span class="sd">        coordinate names. Use the given coordinates as the axes for the</span>
<span class="sd">        plot. The order of the given coordinates indicates which axis</span>
<span class="sd">        to use for each, where the first element is the horizontal</span>
<span class="sd">        axis of the plot and the second element is the vertical axis</span>
<span class="sd">        of the plot.</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    See :func:`matplotlib.pyplot.contourf` for details of other valid</span>
<span class="sd">    keyword arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;antialiased&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_draw_2d_from_points</span><span class="p">(</span><span class="s2">&quot;contourf&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Matplotlib produces visible seams between anti-aliased polygons.</span>
    <span class="c1"># But if the polygons are virtually opaque then we can cover the seams</span>
    <span class="c1"># by drawing anti-aliased lines *underneath* the polygon joins.</span>

    <span class="c1"># Figure out the alpha level for the contour plot</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">alpha</span>
    <span class="c1"># If the contours are anti-aliased and mostly opaque then draw lines under</span>
    <span class="c1"># the seams.</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">antialiased</span> <span class="ow">and</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mf">0.95</span><span class="p">:</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">levels</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">tcolors</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">extend</span> <span class="o">==</span> <span class="s2">&quot;neither&quot;</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">result</span><span class="o">.</span><span class="n">extend</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">result</span><span class="o">.</span><span class="n">extend</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Draw the lines just *below* the polygons to ensure we minimise</span>
            <span class="c1"># any boundary shift.</span>
            <span class="n">zorder</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zorder</span> <span class="o">-</span> <span class="mf">0.1</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;axes&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">contour</span><span class="p">(</span>
                <span class="n">cube</span><span class="p">,</span>
                <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span>
                <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                <span class="n">antialiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>
                <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Restore the current &quot;image&quot; to &#39;result&#39; rather than the mappable</span>
            <span class="c1"># resulting from the additional call to contour().</span>
            <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">_sci</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">sci</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="default_projection"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.default_projection">[docs]</a><span class="k">def</span> <span class="nf">default_projection</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the primary map projection for the given cube.</span>

<span class="sd">    Using the returned projection, one can create a cartopy map with::</span>

<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        ax = plt.ax(projection=default_projection(cube))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># XXX logic seems flawed, but it is what map_setup did...</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_system</span><span class="p">(</span><span class="s2">&quot;CoordSystem&quot;</span><span class="p">)</span>
    <span class="n">projection</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">as_cartopy_projection</span><span class="p">()</span> <span class="k">if</span> <span class="n">cs</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">projection</span></div>


<div class="viewcode-block" id="default_projection_extent"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.default_projection_extent">[docs]</a><span class="k">def</span> <span class="nf">default_projection_extent</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">POINT_MODE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cube&#39;s extents ``(x0, x1, y0, y1)`` in its default projection.</span>

<span class="sd">    Keyword arguments:</span>

<span class="sd">     * mode - Either ``iris.coords.POINT_MODE`` or ``iris.coords.BOUND_MODE``.</span>
<span class="sd">              Triggers whether the extent should be representative of the cell</span>
<span class="sd">              points, or the limits of the cell&#39;s bounds.</span>
<span class="sd">              The default is iris.coords.POINT_MODE.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">extents</span> <span class="o">=</span> <span class="n">cartography</span><span class="o">.</span><span class="n">_xy_range</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="n">xlim</span> <span class="o">=</span> <span class="n">extents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ylim</span> <span class="o">=</span> <span class="n">extents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_fill_orography</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">vert_plot</span><span class="p">,</span> <span class="n">horiz_plot</span><span class="p">,</span> <span class="n">style_args</span><span class="p">):</span>
    <span class="c1"># Find the orography coordinate.</span>
    <span class="n">orography</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;surface_altitude&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plot_defn</span> <span class="o">=</span> <span class="n">_get_plot_defn_custom_coords_picked</span><span class="p">(</span>
            <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plot_defn</span> <span class="o">=</span> <span class="n">_get_plot_defn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">v_coord</span><span class="p">,</span> <span class="n">u_coord</span> <span class="o">=</span> <span class="n">plot_defn</span><span class="o">.</span><span class="n">coords</span>

    <span class="c1"># Find which plot coordinate corresponds to the derived altitude, so that</span>
    <span class="c1"># we can replace altitude with the surface altitude.</span>
    <span class="k">if</span> <span class="n">v_coord</span> <span class="ow">and</span> <span class="n">v_coord</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">==</span> <span class="s2">&quot;altitude&quot;</span><span class="p">:</span>
        <span class="c1"># v is altitude, so plot u and orography with orog in the y direction.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">vert_plot</span><span class="p">(</span><span class="n">u_coord</span><span class="p">,</span> <span class="n">orography</span><span class="p">,</span> <span class="n">style_args</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">u_coord</span> <span class="ow">and</span> <span class="n">u_coord</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">==</span> <span class="s2">&quot;altitude&quot;</span><span class="p">:</span>
        <span class="c1"># u is altitude, so plot v and orography with orog in the x direction.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">horiz_plot</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="n">orography</span><span class="p">,</span> <span class="n">style_args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Plot does not use hybrid height. One of the &quot;</span>
            <span class="s2">&quot;coordinates to plot must be altitude, but </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;were given.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u_coord</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">v_coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="orography_at_bounds"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.orography_at_bounds">[docs]</a><span class="k">def</span> <span class="nf">orography_at_bounds</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;#888888&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plots orography defined at cell boundaries from the given Cube.&quot;&quot;&quot;</span>

    <span class="c1"># XXX Needs contiguous orography corners to work.</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;This operation is temporarily not provided &quot;</span>
        <span class="s2">&quot;until coordinates can expose 2d contiguous &quot;</span>
        <span class="s2">&quot;bounds (corners).&quot;</span>
    <span class="p">)</span>

    <span class="n">style_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;edgecolor&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;facecolor&quot;</span><span class="p">:</span> <span class="n">facecolor</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">vert_plot</span><span class="p">(</span><span class="n">u_coord</span><span class="p">,</span> <span class="n">orography</span><span class="p">,</span> <span class="n">style_args</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u_coord</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">()</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">orography</span><span class="o">.</span><span class="n">points</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">left</span>
        <span class="n">plotfn</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">bar</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">bar</span>
        <span class="k">return</span> <span class="n">plotfn</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="o">**</span><span class="n">style_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">horiz_plot</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="n">orography</span><span class="p">,</span> <span class="n">style_args</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v_coord</span><span class="o">.</span><span class="n">contiguous_bounds</span><span class="p">()</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">orography</span><span class="o">.</span><span class="n">points</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bottom</span>
        <span class="n">plotfn</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">barh</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">barh</span>
        <span class="k">return</span> <span class="n">plotfn</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="o">**</span><span class="n">style_args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_fill_orography</span><span class="p">(</span>
        <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">BOUND_MODE</span><span class="p">,</span> <span class="n">vert_plot</span><span class="p">,</span> <span class="n">horiz_plot</span><span class="p">,</span> <span class="n">style_args</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="orography_at_points"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.orography_at_points">[docs]</a><span class="k">def</span> <span class="nf">orography_at_points</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;#888888&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plots orography defined at sample points from the given Cube.&quot;&quot;&quot;</span>

    <span class="n">style_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;facecolor&quot;</span><span class="p">:</span> <span class="n">facecolor</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">vert_plot</span><span class="p">(</span><span class="n">u_coord</span><span class="p">,</span> <span class="n">orography</span><span class="p">,</span> <span class="n">style_args</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">u_coord</span><span class="o">.</span><span class="n">points</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">orography</span><span class="o">.</span><span class="n">points</span>
        <span class="n">plotfn</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">fill_between</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span>
        <span class="k">return</span> <span class="n">plotfn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">style_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">horiz_plot</span><span class="p">(</span><span class="n">v_coord</span><span class="p">,</span> <span class="n">orography</span><span class="p">,</span> <span class="n">style_args</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">v_coord</span><span class="o">.</span><span class="n">points</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">orography</span><span class="o">.</span><span class="n">points</span>
        <span class="n">plotfn</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">fill_betweenx</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">fill_betweenx</span>
        <span class="k">return</span> <span class="n">plotfn</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">style_args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_fill_orography</span><span class="p">(</span>
        <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">POINT_MODE</span><span class="p">,</span> <span class="n">vert_plot</span><span class="p">,</span> <span class="n">horiz_plot</span><span class="p">,</span> <span class="n">style_args</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="outline"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.outline">[docs]</a><span class="k">def</span> <span class="nf">outline</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws cell outlines based on the given Cube.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * coords: list of :class:`~iris.coords.Coord` objects or</span>
<span class="sd">        coordinate names. Use the given coordinates as the axes for the</span>
<span class="sd">        plot. The order of the given coordinates indicates which axis</span>
<span class="sd">        to use for each, where the first element is the horizontal</span>
<span class="sd">        axis of the plot and the second element is the vertical axis</span>
<span class="sd">        of the plot.</span>

<span class="sd">    * color: None or mpl color The color of the cell outlines. If</span>
<span class="sd">        None, the matplotlibrc setting patch.edgecolor is used by</span>
<span class="sd">        default.</span>

<span class="sd">    * linewidth: None or number The width of the lines showing the</span>
<span class="sd">        cell outlines. If None, the default width in patch.linewidth</span>
<span class="sd">        in matplotlibrc is used.</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_draw_2d_from_bounds</span><span class="p">(</span>
        <span class="s2">&quot;pcolormesh&quot;</span><span class="p">,</span>
        <span class="n">cube</span><span class="p">,</span>
        <span class="n">facecolors</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="n">edgecolors</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
        <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
        <span class="n">antialiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
        <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># set the _is_stroked property to get a single color grid.</span>
    <span class="c1"># See https://github.com/matplotlib/matplotlib/issues/1302</span>
    <span class="n">result</span><span class="o">.</span><span class="n">_is_stroked</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;_wrapped_collection_fix&quot;</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_wrapped_collection_fix</span><span class="o">.</span><span class="n">_is_stroked</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="pcolor"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.pcolor">[docs]</a><span class="k">def</span> <span class="nf">pcolor</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws a pseudocolor plot based on the given 2-dimensional Cube.</span>

<span class="sd">    The cube must have either two 1-dimensional coordinates or two</span>
<span class="sd">    2-dimensional coordinates with contiguous bounds to plot the cube against.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * coords: list of :class:`~iris.coords.Coord` objects or</span>
<span class="sd">        coordinate names. Use the given coordinates as the axes for the</span>
<span class="sd">        plot. The order of the given coordinates indicates which axis</span>
<span class="sd">        to use for each, where the first element is the horizontal</span>
<span class="sd">        axis of the plot and the second element is the vertical axis</span>
<span class="sd">        of the plot.</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    * contiguity_tolerance: The absolute tolerance used when checking for</span>
<span class="sd">        contiguity between the bounds of the cells. Defaults to None.</span>

<span class="sd">    See :func:`matplotlib.pyplot.pcolor` for details of other valid</span>
<span class="sd">    keyword arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;antialiased&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;snap&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_draw_2d_from_bounds</span><span class="p">(</span><span class="s2">&quot;pcolor&quot;</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="pcolormesh"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.pcolormesh">[docs]</a><span class="k">def</span> <span class="nf">pcolormesh</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws a pseudocolor plot based on the given 2-dimensional Cube.</span>

<span class="sd">    The cube must have either two 1-dimensional coordinates or two</span>
<span class="sd">    2-dimensional coordinates with contiguous bounds to plot against each</span>
<span class="sd">    other.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * coords: list of :class:`~iris.coords.Coord` objects or</span>
<span class="sd">        coordinate names. Use the given coordinates as the axes for the</span>
<span class="sd">        plot. The order of the given coordinates indicates which axis</span>
<span class="sd">        to use for each, where the first element is the horizontal</span>
<span class="sd">        axis of the plot and the second element is the vertical axis</span>
<span class="sd">        of the plot.</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    * contiguity_tolerance: The absolute tolerance used when checking for</span>
<span class="sd">        contiguity between the bounds of the cells. Defaults to None.</span>

<span class="sd">    See :func:`matplotlib.pyplot.pcolormesh` for details of other</span>
<span class="sd">    valid keyword arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_draw_2d_from_bounds</span><span class="p">(</span><span class="s2">&quot;pcolormesh&quot;</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="points"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.points">[docs]</a><span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws sample point positions based on the given Cube.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * coords: list of :class:`~iris.coords.Coord` objects or</span>
<span class="sd">        coordinate names. Use the given coordinates as the axes for the</span>
<span class="sd">        plot. The order of the given coordinates indicates which axis</span>
<span class="sd">        to use for each, where the first element is the horizontal</span>
<span class="sd">        axis of the plot and the second element is the vertical axis</span>
<span class="sd">        of the plot.</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    See :func:`matplotlib.pyplot.scatter` for details of other valid</span>
<span class="sd">    keyword arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_scatter_args</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_draw_2d_from_points</span><span class="p">(</span>
        <span class="s2">&quot;scatter&quot;</span><span class="p">,</span> <span class="n">_scatter_args</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_vector_component_args</span><span class="p">(</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">,</span> <span class="n">u_data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Callback from _draw_2d_from_points for &#39;quiver&#39; and &#39;streamlines&#39;.</span>

<span class="sd">    Returns arguments (x, y, u, v), to be passed to the underlying matplotlib</span>
<span class="sd">    call.</span>

<span class="sd">    &quot;u_data&quot; will always be &quot;u_cube.data&quot;.</span>
<span class="sd">    The matching &quot;v_cube.data&quot; component is stored in kwargs[&#39;_v_data&#39;].</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_v_data&quot;</span><span class="p">)</span>

    <span class="c1"># Rescale u+v values for plot distortion.</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">crs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="p">(</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">,</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">RotatedPole</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Can only plot vectors provided in a lat-lon &quot;</span>
                <span class="s1">&#39;projection, i.e. equivalent to &quot;cartopy.crs.PlateCarree&quot; &#39;</span>
                <span class="s1">&#39;or &quot;cartopy.crs.RotatedPole&quot;. This &#39;</span>
                <span class="s2">&quot;cube coordinate system translates as Cartopy </span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crs</span><span class="p">))</span>
        <span class="c1"># Given the above check, the Y points must be latitudes.</span>
        <span class="c1"># We therefore **assume** they are in degrees : I&#39;m not sure this</span>
        <span class="c1"># is wise, but all the rest of this plot code does that, e.g. in</span>
        <span class="c1"># _map_common.</span>
        <span class="c1"># TODO: investigate degree units assumptions, here + elsewhere.</span>

        <span class="c1"># Implement a latitude scaling, but preserve the given magnitudes.</span>
        <span class="n">u_data</span><span class="p">,</span> <span class="n">v_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">u_data</span><span class="p">,</span> <span class="n">v_data</span><span class="p">)]</span>
        <span class="n">mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">u_data</span> <span class="o">*</span> <span class="n">u_data</span> <span class="o">+</span> <span class="n">v_data</span> <span class="o">*</span> <span class="n">v_data</span><span class="p">)</span>
        <span class="n">v_data</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">y_points</span><span class="p">))</span>
        <span class="n">scales</span> <span class="o">=</span> <span class="n">mags</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">u_data</span> <span class="o">*</span> <span class="n">u_data</span> <span class="o">+</span> <span class="n">v_data</span> <span class="o">*</span> <span class="n">v_data</span><span class="p">)</span>
        <span class="n">u_data</span> <span class="o">*=</span> <span class="n">scales</span>
        <span class="n">v_data</span> <span class="o">*=</span> <span class="n">scales</span>

    <span class="k">return</span> <span class="p">((</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">,</span> <span class="n">u_data</span><span class="p">,</span> <span class="n">v_data</span><span class="p">),</span> <span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="quiver"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.quiver">[docs]</a><span class="k">def</span> <span class="nf">quiver</span><span class="p">(</span><span class="n">u_cube</span><span class="p">,</span> <span class="n">v_cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws an arrow plot from two vector component cubes.</span>

<span class="sd">    Args:</span>

<span class="sd">    * u_cube, v_cube : (:class:`~iris.cube.Cube`)</span>
<span class="sd">        u and v vector components.  Must have same shape and units.</span>
<span class="sd">        If the cubes have geographic coordinates, the values are treated as</span>
<span class="sd">        true distance differentials, e.g. windspeeds, and *not* map coordinate</span>
<span class="sd">        vectors.  The components are aligned with the North and East of the</span>
<span class="sd">        cube coordinate system.</span>

<span class="sd">    .. Note:</span>

<span class="sd">        At present, if u_cube and v_cube have geographic coordinates, then they</span>
<span class="sd">        must be in a lat-lon coordinate system, though it may be a rotated one.</span>
<span class="sd">        To transform wind values between coordinate systems, use</span>
<span class="sd">        :func:`iris.analysis.cartography.rotate_vectors`.</span>
<span class="sd">        To transform coordinate grid points, you will need to create</span>
<span class="sd">        2-dimensional arrays of x and y values.  These can be transformed with</span>
<span class="sd">        :meth:`cartopy.crs.CRS.transform_points`.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * coords: (list of :class:`~iris.coords.Coord` or string)</span>
<span class="sd">        Coordinates or coordinate names. Use the given coordinates as the axes</span>
<span class="sd">        for the plot. The order of the given coordinates indicates which axis</span>
<span class="sd">        to use for each, where the first element is the horizontal</span>
<span class="sd">        axis of the plot and the second element is the vertical axis</span>
<span class="sd">        of the plot.</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    See :func:`matplotlib.pyplot.quiver` for details of other valid</span>
<span class="sd">    keyword arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># TODO: check u + v cubes for compatibility.</span>
    <span class="c1">#</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;_v_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_cube</span><span class="o">.</span><span class="n">data</span>
    <span class="k">return</span> <span class="n">_draw_2d_from_points</span><span class="p">(</span>
        <span class="s2">&quot;quiver&quot;</span><span class="p">,</span> <span class="n">_vector_component_args</span><span class="p">,</span> <span class="n">u_cube</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="plot"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.plot">[docs]</a><span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws a line plot based on the given cube(s) or coordinate(s).</span>

<span class="sd">    The first one or two arguments may be cubes or coordinates to plot.</span>
<span class="sd">    Each of the following is valid::</span>

<span class="sd">        # plot a 1d cube against its dimension coordinate</span>
<span class="sd">        plot(cube)</span>

<span class="sd">        # plot a 1d coordinate</span>
<span class="sd">        plot(coord)</span>

<span class="sd">        # plot a 1d cube against a given 1d coordinate, with the cube</span>
<span class="sd">        # values on the y-axis and the coordinate on the x-axis</span>
<span class="sd">        plot(coord, cube)</span>

<span class="sd">        # plot a 1d cube against a given 1d coordinate, with the cube</span>
<span class="sd">        # values on the x-axis and the coordinate on the y-axis</span>
<span class="sd">        plot(cube, coord)</span>

<span class="sd">        # plot two 1d coordinates against one-another</span>
<span class="sd">        plot(coord1, coord2)</span>

<span class="sd">        # plot two 1d cubes against one-another</span>
<span class="sd">        plot(cube1, cube2)</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    See :func:`matplotlib.pyplot.plot` for details of additional valid</span>
<span class="sd">    keyword arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;coords&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;&quot;coords&quot; is not a valid plot keyword. Coordinates &#39;</span>
            <span class="s2">&quot;and cubes may be passed as arguments for &quot;</span>
            <span class="s2">&quot;full control of the plot axes.&quot;</span>
        <span class="p">)</span>
    <span class="n">_plot_args</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">_draw_1d_from_points</span><span class="p">(</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="n">_plot_args</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="scatter"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.scatter">[docs]</a><span class="k">def</span> <span class="nf">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws a scatter plot based on the given cube(s) or coordinate(s).</span>

<span class="sd">    Args:</span>

<span class="sd">    * x: :class:`~iris.cube.Cube` or :class:`~iris.coords.Coord`</span>
<span class="sd">        A cube or a coordinate to plot on the x-axis.</span>

<span class="sd">    * y: :class:`~iris.cube.Cube` or :class:`~iris.coords.Coord`</span>
<span class="sd">        A cube or a coordinate to plot on the y-axis.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    See :func:`matplotlib.pyplot.scatter` for details of additional</span>
<span class="sd">    valid keyword arguments.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># here we are more specific about argument types than generic 1d plotting</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;x must be a cube or a coordinate.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;y must be a cube or a coordinate.&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="n">_plot_args</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">_draw_1d_from_points</span><span class="p">(</span><span class="s2">&quot;scatter&quot;</span><span class="p">,</span> <span class="n">_plot_args</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># Provide convenience show method from pyplot</span>
<span class="n">show</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span>


<div class="viewcode-block" id="symbols"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.symbols">[docs]</a><span class="k">def</span> <span class="nf">symbols</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;inches&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws fixed-size symbols.</span>

<span class="sd">    See :mod:`iris.symbols` for available symbols.</span>

<span class="sd">    Args:</span>

<span class="sd">    * x: iterable</span>
<span class="sd">        The x coordinates where the symbols will be plotted.</span>

<span class="sd">    * y: iterable</span>
<span class="sd">        The y coordinates where the symbols will be plotted.</span>

<span class="sd">    * symbols: iterable</span>
<span class="sd">        The symbols (from :mod:`iris.symbols`) to plot.</span>

<span class="sd">    * size: float</span>
<span class="sd">        The symbol size in `units`.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    * units: [&#39;inches&#39;, &#39;points&#39;]</span>
<span class="sd">        The unit for the symbol size.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

    <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>

    <span class="c1"># XXX &quot;match_original&quot; doesn&#39;t work ... so brute-force it instead.</span>
    <span class="c1">#   PatchCollection constructor ignores all non-style keywords when using</span>
    <span class="c1">#   match_original</span>
    <span class="c1">#   See matplotlib.collections.PatchCollection.__init__</span>
    <span class="c1">#   Specifically matplotlib/collections line 1053</span>
    <span class="c1"># pc = PatchCollection(symbols, offsets=offsets, transOffset=ax.transData,</span>
    <span class="c1">#                      match_original=True)</span>
    <span class="n">facecolors</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>
    <span class="n">edgecolors</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_edgecolor</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>
    <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>

    <span class="n">pc</span> <span class="o">=</span> <span class="n">mpl_collections</span><span class="o">.</span><span class="n">PatchCollection</span><span class="p">(</span>
        <span class="n">symbols</span><span class="p">,</span>
        <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
        <span class="n">transOffset</span><span class="o">=</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
        <span class="n">facecolors</span><span class="o">=</span><span class="n">facecolors</span><span class="p">,</span>
        <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
        <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;inches&quot;</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span>
    <span class="k">elif</span> <span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;points&quot;</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span> <span class="o">/</span> <span class="mf">72.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognised units: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">units</span><span class="p">)</span>
    <span class="n">pc</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mpl_transforms</span><span class="o">.</span><span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">size</span> <span class="o">*</span> <span class="n">scale</span><span class="p">))</span>

    <span class="n">axes</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span>
    <span class="n">axes</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span></div>


<div class="viewcode-block" id="citation"><a class="viewcode-back" href="../../generated/api/iris/plot.html#iris.plot.citation">[docs]</a><span class="k">def</span> <span class="nf">citation</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">figure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a text citation to a plot.</span>

<span class="sd">    Places an anchored text citation in the bottom right</span>
<span class="sd">    hand corner of the plot.</span>

<span class="sd">    Args:</span>

<span class="sd">    * text:</span>
<span class="sd">        Citation text to be plotted.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * figure:</span>
<span class="sd">        Target :class:`matplotlib.figure.Figure` instance. Defaults</span>
<span class="sd">        to the current figure if none provided.</span>

<span class="sd">    * axes: the :class:`matplotlib.axes.Axes` to use for drawing.</span>
<span class="sd">        Defaults to the current axes if none provided.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">figure</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">figure</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">anchor</span> <span class="o">=</span> <span class="n">AnchoredText</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">prop</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">anchor</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_boxstyle</span><span class="p">(</span><span class="s2">&quot;round, pad=0, rounding_size=0.2&quot;</span><span class="p">)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">figure</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">anchor</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        
        &copy; <a href="../../copyright.html">Copyright</a> Iris Contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>