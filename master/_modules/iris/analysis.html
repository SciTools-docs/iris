

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>iris.analysis &mdash; Iris 3.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/theme_override.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/iris-logo-title.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installing.html">Installing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/gallery/index.html">Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/iris_cubes.html">Iris data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/loading_iris_cubes.html">Loading Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/saving_iris_cubes.html">Saving Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/navigating_a_cube.html">Navigating a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/subsetting_a_cube.html">Subsetting a Cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/real_and_lazy_data.html">Real and Lazy Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/plotting_a_cube.html">Plotting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/interpolation_and_regridding.html">Cube interpolation and regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/merge_and_concat.html">Merge and concatenate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_statistics.html">Cube statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_maths.html">Basic cube mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/citation.html">Citing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/code_maintenance.html">Code maintenance</a></li>
</ul>
<p class="caption"><span class="caption-text">Developers Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_getting_involved.html">Getting Involved</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/gitwash/index.html">Working with <em>iris</em> source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_documentation.html">Contributing to the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_codebase_index.html">Contributing to the code base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_changes.html">Contributing your changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/release.html">Releases</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/iris.html">Iris API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../whatsnew/index.html">Whatâ€™s new in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../techpapers/index.html">Iris Technical Papers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Iris copyright, licensing and contributors</a></li>
</ul>

            
          

    
    
    
        <p class="caption">
            <span class="caption-text">
            
                Support
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SciTools/iris"><i class="fa fa-github fa-fw"></i> Source Code</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris"><i class="fa fa-comments fa-fw"></i> Users Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris-dev"><i class="fa fa-comments fa-fw"></i> Developers Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://stackoverflow.com/questions/tagged/python-iris"><i class="fa fa-question fa-fw"></i> StackOverflow For "How do I?"</a></li>
            
                <li class="toctree-l1"><a href="https://scitools.org.uk/iris/docs/v2.4.0/index.html"><i class="fa fa-book fa-fw"></i> Legacy documentation</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Iris</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../iris.html">iris</a> &raquo;</li>
        
      <li>iris.analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for iris.analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Iris contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Iris and is released under the LGPL license.</span>
<span class="c1"># See COPYING and COPYING.LESSER in the root of the repository for full</span>
<span class="c1"># licensing details.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A package providing :class:`iris.cube.Cube` analysis support.</span>

<span class="sd">This module defines a suite of :class:`~iris.analysis.Aggregator` instances,</span>
<span class="sd">which are used to specify the statistical measure to calculate over a</span>
<span class="sd">:class:`~iris.cube.Cube`, using methods such as</span>
<span class="sd">:meth:`~iris.cube.Cube.aggregated_by` and :meth:`~iris.cube.Cube.collapsed`.</span>

<span class="sd">The :class:`~iris.analysis.Aggregator` is a convenience class that allows</span>
<span class="sd">specific statistical aggregation operators to be defined and instantiated.</span>
<span class="sd">These operators can then be used to collapse, or partially collapse, one or</span>
<span class="sd">more dimensions of a :class:`~iris.cube.Cube`, as discussed in</span>
<span class="sd">:ref:`cube-statistics`.</span>

<span class="sd">In particular, :ref:`cube-statistics-collapsing` discusses how to use</span>
<span class="sd">:const:`MEAN` to average over one dimension of a :class:`~iris.cube.Cube`,</span>
<span class="sd">and also how to perform weighted :ref:`cube-statistics-collapsing-average`.</span>
<span class="sd">While :ref:`cube-statistics-aggregated-by` shows how to aggregate similar</span>
<span class="sd">groups of data points along a single dimension, to result in fewer points</span>
<span class="sd">in that dimension.</span>

<span class="sd">The gallery contains several interesting worked examples of how an</span>
<span class="sd">:class:`~iris.analysis.Aggregator` may be used, including:</span>

<span class="sd"> * :ref:`sphx_glr_generated_gallery_meteorology_plot_COP_1d.py`</span>
<span class="sd"> * :ref:`sphx_glr_generated_gallery_general_plot_SOI_filtering.py`</span>
<span class="sd"> * :ref:`sphx_glr_generated_gallery_meteorology_plot_hovmoller.py`</span>
<span class="sd"> * :ref:`sphx_glr_generated_gallery_meteorology_plot_lagged_ensemble.py`</span>
<span class="sd"> * :ref:`sphx_glr_generated_gallery_general_plot_custom_aggregation.py`</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.stats.mstats</span>

<span class="kn">from</span> <span class="nn">iris.analysis._area_weighted</span> <span class="kn">import</span> <span class="n">AreaWeightedRegridder</span>
<span class="kn">from</span> <span class="nn">iris.analysis._interpolation</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">EXTRAPOLATION_MODES</span><span class="p">,</span>
    <span class="n">RectilinearInterpolator</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">iris.analysis._regrid</span> <span class="kn">import</span> <span class="n">RectilinearRegridder</span><span class="p">,</span> <span class="n">CurvilinearRegridder</span>
<span class="kn">import</span> <span class="nn">iris.coords</span>
<span class="kn">from</span> <span class="nn">iris.exceptions</span> <span class="kn">import</span> <span class="n">LazyAggregatorError</span>
<span class="kn">import</span> <span class="nn">iris._lazy_data</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;COUNT&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GMEAN&quot;</span><span class="p">,</span>
    <span class="s2">&quot;HMEAN&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MAX&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MEAN&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MEDIAN&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MIN&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PEAK&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PERCENTILE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PROPORTION&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RMS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;STD_DEV&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SUM&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VARIANCE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;WPERCENTILE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Aggregator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;WeightedAggregator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;clear_phenomenon_identity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Linear&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AreaWeighted&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Nearest&quot;</span><span class="p">,</span>
    <span class="s2">&quot;UnstructuredNearest&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PointInCell&quot;</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">_CoordGroup</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a list of coordinates, one for each given cube. Which can be</span>
<span class="sd">    operated on conveniently.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">cubes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cubes</span> <span class="o">=</span> <span class="n">cubes</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_first_coord_w_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first none None coordinate, and its associated cube</span>
<span class="sd">        as (cube, coord).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">cube_coord</span><span class="p">:</span> <span class="n">cube_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cubes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># No exact repr, so a helpful string is given instead</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;[&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;None&quot;</span>
                    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">first_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_coord_w_cube</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">first_coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_oid_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of object ids for this _CoordGroup&#39;s coordinates&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="nb">id</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_oid_tuple</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># equals is overridden to guarantee that two _CoordGroups are only</span>
        <span class="c1"># equal if their coordinates are the same objects (by object id)</span>
        <span class="c1"># this is useful in the context of comparing _CoordGroups if they are</span>
        <span class="c1"># part of a set operation such as that in coord_compare, but</span>
        <span class="c1"># not useful in many other circumstances (i.e. deepcopying a</span>
        <span class="c1"># _CoordGroups instance would mean that copy != original)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_CoordGroup</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_oid_tuple</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_oid_tuple</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">default_val</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function to a coord group returning a list of bools</span>
<span class="sd">        for each coordinate.</span>

<span class="sd">        The predicate function should take exactly 2 arguments (cube, coord)</span>
<span class="sd">        and return a boolean.</span>

<span class="sd">        If None is in the coord group then return True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cube</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cubes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">default_val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">predicate</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">matches_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether all coordinates match the given function after running</span>
<span class="sd">        it through :meth:`matches`.</span>

<span class="sd">        If None is in the coord group then return True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">predicate</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">matches_any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether any coordinates match the given function after running</span>
<span class="sd">        it through :meth:`matches`.</span>

<span class="sd">        If None is in the coord group then return True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">predicate</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_dimensional_metadata_comparison</span><span class="p">(</span><span class="o">*</span><span class="n">cubes</span><span class="p">,</span> <span class="n">object_get</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience function to help compare coordinates, cell-measures or</span>
<span class="sd">    ancillary-variables, on one or more cubes, by their metadata.</span>

<span class="sd">    .. Note::</span>

<span class="sd">        Up to Iris 2.x, this _used_ to be the public API method</span>
<span class="sd">        &quot;iris.analysis.coord_comparison&quot;.</span>
<span class="sd">        It has since been generalised, and made private.</span>
<span class="sd">        However, the cube elements handled are still mostly referred to as &#39;coords&#39; /</span>
<span class="sd">        &#39;coordinates&#39; throughout, for simplicity :  In fact, they will all be either</span>
<span class="sd">        `iris.coords.Coord`, `iris.coords.CellMeasure` or</span>
<span class="sd">        `iris.coords.AncillaryVariable`, the cube element type being controlled by the</span>
<span class="sd">        &#39;object_get&#39; keyword.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cubes (iterable of `iris.cube.Cube`):</span>
<span class="sd">        a set of cubes whose coordinates, cell-measures or ancillary-variables are to</span>
<span class="sd">        be compared.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * object_get (callable(cube) or None):</span>
<span class="sd">        If not None, this must be a cube method returning a list of all cube elements</span>
<span class="sd">        of the required type, i.e. one of `iris.cube.Cube.coords`,</span>
<span class="sd">        `iris.cube.Cube.cell_measures`, or `iris.cube.Cube.ancillary_variables`.</span>
<span class="sd">        If not specified, defaults to `iris.cube.Cube.coords`</span>

<span class="sd">    Returns:</span>

<span class="sd">        result (dict mapping string: list of _CoordGroup):</span>
<span class="sd">            A dictionary whose keys are match categories and values are groups of</span>
<span class="sd">            coordinates, cell-measures or ancillary-variables.</span>

<span class="sd">    The values of the returned dictionary are lists of _CoordGroup representing</span>
<span class="sd">    grouped coordinates.  Each _CoordGroup contains all the input &#39;cubes&#39;, and a</span>
<span class="sd">    matching list of the coord within each cube that matches some specific CoordDefn</span>
<span class="sd">    (or maybe None).</span>

<span class="sd">    The keys of the returned dictionary are strings naming &#39;categories&#39; :  Each</span>
<span class="sd">    represents a statement,</span>
<span class="sd">    &quot;Given these cubes list the coordinates which,</span>
<span class="sd">    when grouped by metadata, are/have...&quot;</span>

<span class="sd">    Returned Keys:</span>

<span class="sd">    * grouped_coords</span>
<span class="sd">       A list of coordinate groups of all the coordinates grouped together</span>
<span class="sd">       by their coordinate definition</span>
<span class="sd">    * ungroupable</span>
<span class="sd">       A list of coordinate groups which contain at least one None,</span>
<span class="sd">       meaning not all Cubes provide an equivalent coordinate</span>
<span class="sd">    * not_equal</span>
<span class="sd">       A list of coordinate groups of which not all are equal</span>
<span class="sd">       (superset of ungroupable)</span>
<span class="sd">    * no_data_dimension</span>
<span class="sd">       A list of coordinate groups of which all have no data dimensions on</span>
<span class="sd">       their respective cubes</span>
<span class="sd">    * scalar</span>
<span class="sd">       A list of coordinate groups of which all have shape (1, )</span>
<span class="sd">    * non_equal_data_dimension</span>
<span class="sd">       A list of coordinate groups of which not all have the same</span>
<span class="sd">       data dimension on their respective cubes</span>
<span class="sd">    * non_equal_shape</span>
<span class="sd">       A list of coordinate groups of which not all have the same shape</span>
<span class="sd">    * equal_data_dimension</span>
<span class="sd">       A list of coordinate groups of which all have the same data dimension</span>
<span class="sd">       on their respective cubes</span>
<span class="sd">    * equal</span>
<span class="sd">       A list of coordinate groups of which all are equal</span>
<span class="sd">    * ungroupable_and_dimensioned</span>
<span class="sd">       A list of coordinate groups of which not all cubes had an equivalent</span>
<span class="sd">       (in metadata) coordinate which also describe a data dimension</span>
<span class="sd">    * dimensioned</span>
<span class="sd">       A list of coordinate groups of which all describe a data dimension on</span>
<span class="sd">       their respective cubes</span>
<span class="sd">    * ignorable</span>
<span class="sd">       A list of scalar, ungroupable non_equal coordinate groups</span>
<span class="sd">    * resamplable</span>
<span class="sd">        A list of equal, different data dimensioned coordinate groups</span>
<span class="sd">    * transposable</span>
<span class="sd">       A list of non equal, same data dimensioned, non scalar coordinate groups</span>

<span class="sd">    Example usage::</span>

<span class="sd">        result = _dimensional_metadata_comparison(cube1, cube2)</span>
<span class="sd">        print(&#39;All equal coordinates: &#39;, result[&#39;equal&#39;])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">object_get</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">iris.cube</span> <span class="kn">import</span> <span class="n">Cube</span>

        <span class="n">object_get</span> <span class="o">=</span> <span class="n">Cube</span><span class="o">.</span><span class="n">coords</span>

    <span class="n">all_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">object_get</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span> <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">]</span>
    <span class="n">grouped_coords</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># set of coordinates id()s of coordinates which have been processed</span>
    <span class="n">processed_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># iterate through all cubes, then by each coordinate in the cube looking</span>
    <span class="c1"># for coordinate groups</span>
    <span class="k">for</span> <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cubes</span><span class="p">,</span> <span class="n">all_coords</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>

            <span class="c1"># if this coordinate has already been processed, then continue on</span>
            <span class="c1"># to the next one</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="ow">in</span> <span class="n">processed_coords</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># setup a list to hold the coordinates which will be turned into a</span>
            <span class="c1"># coordinate group and added to the grouped_coords list</span>
            <span class="n">this_coords_coord_group</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">other_cube_i</span><span class="p">,</span> <span class="n">other_cube</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cubes</span><span class="p">):</span>
                <span class="c1"># setup a variable to hold the coordinate which will be added</span>
                <span class="c1"># to the coordinate group for this cube</span>
                <span class="n">coord_to_add_to_group</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># don&#39;t bother checking if the current cube is the one we are</span>
                <span class="c1"># trying to match coordinates too</span>
                <span class="k">if</span> <span class="n">other_cube</span> <span class="ow">is</span> <span class="n">cube</span><span class="p">:</span>
                    <span class="n">coord_to_add_to_group</span> <span class="o">=</span> <span class="n">coord</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># iterate through all coordinates in this cube</span>
                    <span class="k">for</span> <span class="n">other_coord</span> <span class="ow">in</span> <span class="n">all_coords</span><span class="p">[</span><span class="n">other_cube_i</span><span class="p">]:</span>
                        <span class="c1"># for optimisation, check that the name is equivalent</span>
                        <span class="c1"># *before* checking all of the metadata is equivalent</span>
                        <span class="n">eq</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">other_coord</span> <span class="ow">is</span> <span class="n">coord</span>
                            <span class="ow">or</span> <span class="n">other_coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                            <span class="ow">and</span> <span class="n">other_coord</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">coord</span><span class="o">.</span><span class="n">metadata</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">eq</span><span class="p">:</span>
                            <span class="n">coord_to_add_to_group</span> <span class="o">=</span> <span class="n">other_coord</span>
                            <span class="k">break</span>

                <span class="c1"># add the coordinate to the group</span>
                <span class="k">if</span> <span class="n">coord_to_add_to_group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">this_coords_coord_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">this_coords_coord_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_to_add_to_group</span><span class="p">)</span>
                    <span class="c1"># add the object id of the coordinate which is being added</span>
                    <span class="c1"># to the group to the processed coordinate list</span>
                    <span class="n">processed_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">coord_to_add_to_group</span><span class="p">))</span>

            <span class="c1"># add the group to the list of groups</span>
            <span class="n">grouped_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_CoordGroup</span><span class="p">(</span><span class="n">this_coords_coord_group</span><span class="p">,</span> <span class="n">cubes</span><span class="p">))</span>

    <span class="c1"># define some sets which will be populated in the subsequent loop</span>
    <span class="n">ungroupable</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">different_shaped_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">different_data_dimension</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">no_data_dimension</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">scalar_coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">not_equal</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">coord_group</span> <span class="ow">in</span> <span class="n">grouped_coords</span><span class="p">:</span>
        <span class="n">first_cube</span><span class="p">,</span> <span class="n">first_coord</span> <span class="o">=</span> <span class="n">coord_group</span><span class="o">.</span><span class="n">_first_coord_w_cube</span><span class="p">()</span>

        <span class="c1"># Get all coordinate groups which aren&#39;t complete (i.e. there is a</span>
        <span class="c1"># None in the group)</span>
        <span class="k">def</span> <span class="nf">coord_is_None_fn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">coord_group</span><span class="o">.</span><span class="n">matches_any</span><span class="p">(</span><span class="n">coord_is_None_fn</span><span class="p">):</span>
            <span class="n">ungroupable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord_group</span><span class="p">)</span>

        <span class="c1"># Get all coordinate groups which don&#39;t all equal one another</span>
        <span class="c1"># (None -&gt; group not all equal)</span>
        <span class="k">def</span> <span class="nf">not_equal_fn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coord</span> <span class="o">!=</span> <span class="n">first_coord</span>

        <span class="k">if</span> <span class="n">coord_group</span><span class="o">.</span><span class="n">matches_any</span><span class="p">(</span><span class="n">not_equal_fn</span><span class="p">):</span>
            <span class="n">not_equal</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord_group</span><span class="p">)</span>

        <span class="c1"># Get all coordinate groups which don&#39;t all share the same shape</span>
        <span class="c1"># (None -&gt; group has different shapes)</span>
        <span class="k">def</span> <span class="nf">diff_shape_fn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">first_coord</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">coord_group</span><span class="o">.</span><span class="n">matches_any</span><span class="p">(</span><span class="n">diff_shape_fn</span><span class="p">):</span>
            <span class="n">different_shaped_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord_group</span><span class="p">)</span>

        <span class="c1"># Get all coordinate groups which don&#39;t all share the same data</span>
        <span class="c1"># dimension on their respective cubes</span>
        <span class="c1"># (None -&gt; group describes a different dimension)</span>
        <span class="k">def</span> <span class="nf">diff_data_dim_fn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">cube_dims</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span> <span class="o">!=</span> <span class="n">first_coord</span><span class="o">.</span><span class="n">cube_dims</span><span class="p">(</span><span class="n">first_cube</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">coord_group</span><span class="o">.</span><span class="n">matches_any</span><span class="p">(</span><span class="n">diff_data_dim_fn</span><span class="p">):</span>
            <span class="n">different_data_dimension</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord_group</span><span class="p">)</span>

        <span class="c1"># get all coordinate groups which don&#39;t describe a dimension</span>
        <span class="c1"># (None -&gt; doesn&#39;t describe a dimension)</span>
        <span class="k">def</span> <span class="nf">no_data_dim_fn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">cube_dims</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span> <span class="o">==</span> <span class="p">()</span>

        <span class="k">if</span> <span class="n">coord_group</span><span class="o">.</span><span class="n">matches_all</span><span class="p">(</span><span class="n">no_data_dim_fn</span><span class="p">):</span>
            <span class="n">no_data_dimension</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord_group</span><span class="p">)</span>

        <span class="c1"># get all coordinate groups which don&#39;t describe a dimension</span>
        <span class="c1"># (None -&gt; not a scalar coordinate)</span>
        <span class="k">def</span> <span class="nf">no_data_dim_fn</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">coord_group</span><span class="o">.</span><span class="n">matches_all</span><span class="p">(</span><span class="n">no_data_dim_fn</span><span class="p">):</span>
            <span class="n">scalar_coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord_group</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;grouped_coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grouped_coords</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;not_equal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">not_equal</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ungroupable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ungroupable</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;no_data_dimension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">no_data_dimension</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;scalar&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scalar_coords</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;non_equal_data_dimension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">different_data_dimension</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;non_equal_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">different_shaped_coords</span>

    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;equal_data_dimension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;grouped_coords&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;non_equal_data_dimension&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;equal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;grouped_coords&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;not_equal&quot;</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;dimensioned&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;grouped_coords&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;no_data_dimension&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ungroupable_and_dimensioned&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ungroupable&quot;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;dimensioned&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ignorable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;not_equal&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ungroupable&quot;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">&amp;</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;no_data_dimension&quot;</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;resamplable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;not_equal&quot;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;equal_data_dimension&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;scalar&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;transposable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;equal&quot;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;non_equal_data_dimension&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># for convenience, turn all of the sets in the dictionary into lists,</span>
    <span class="c1"># sorted by the name of the group</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">groups</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">_Aggregator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`_Aggregator` base class provides common aggregation</span>
<span class="sd">    functionality.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cell_method</span><span class="p">,</span> <span class="n">call_func</span><span class="p">,</span> <span class="n">units_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lazy_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an aggregator for the given :data:`call_func`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * cell_method (string):</span>
<span class="sd">            Cell method definition formatter.  Used in the fashion</span>
<span class="sd">            &quot;cell_method.format(\**kwargs)&quot;, to produce a cell-method string</span>
<span class="sd">            which can include keyword values.</span>

<span class="sd">        * call_func (callable):</span>
<span class="sd">            | *Call signature*: (data, axis=None, \**kwargs)</span>

<span class="sd">            Data aggregation function.</span>
<span class="sd">            Returns an aggregation result, collapsing the &#39;axis&#39; dimension of</span>
<span class="sd">            the &#39;data&#39; argument.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * units_func (callable):</span>
<span class="sd">            | *Call signature*: (units)</span>

<span class="sd">            If provided, called to convert a cube&#39;s units.</span>
<span class="sd">            Returns an :class:`cf_units.Unit`, or a</span>
<span class="sd">            value that can be made into one.</span>

<span class="sd">        * lazy_func (callable or None):</span>
<span class="sd">            An alternative to :data:`call_func` implementing a lazy</span>
<span class="sd">            aggregation. Note that, it need not support all features of the</span>
<span class="sd">            main operation, but should raise an error in unhandled cases.</span>

<span class="sd">        Additional kwargs::</span>
<span class="sd">            Passed through to :data:`call_func` and :data:`lazy_func`.</span>

<span class="sd">        Aggregators are used by cube aggregation methods such as</span>
<span class="sd">        :meth:`~iris.cube.Cube.collapsed` and</span>
<span class="sd">        :meth:`~iris.cube.Cube.aggregated_by`.  For example::</span>

<span class="sd">            result = cube.collapsed(&#39;longitude&#39;, iris.analysis.MEAN)</span>

<span class="sd">        A variety of ready-made aggregators are provided in this module, such</span>
<span class="sd">        as :data:`~iris.analysis.MEAN` and :data:`~iris.analysis.MAX`.  Custom</span>
<span class="sd">        aggregators can also be created for special purposes, see</span>
<span class="sd">        :ref:`sphx_glr_generated_gallery_general_plot_custom_aggregation.py`</span>
<span class="sd">        for a worked example.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#: Cube cell method string.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_method</span> <span class="o">=</span> <span class="n">cell_method</span>
        <span class="c1">#: Data aggregation function.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_func</span> <span class="o">=</span> <span class="n">call_func</span>
        <span class="c1">#: Unit conversion function.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units_func</span> <span class="o">=</span> <span class="n">units_func</span>
        <span class="c1">#: Lazy aggregation function, may be None to indicate that a lazy</span>
        <span class="c1">#: operation is not available.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lazy_func</span> <span class="o">=</span> <span class="n">lazy_func</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">lazy_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform aggregation over the data with a lazy operation, analogous to</span>
<span class="sd">        the &#39;aggregate&#39; result.</span>

<span class="sd">        Keyword arguments are passed through to the data aggregation function</span>
<span class="sd">        (for example, the &quot;percent&quot; keyword for a percentile aggregator).</span>
<span class="sd">        This function is usually used in conjunction with update_metadata(),</span>
<span class="sd">        which should be passed the same keyword arguments.</span>

<span class="sd">        Args:</span>

<span class="sd">        * data (array):</span>
<span class="sd">            A lazy array (:class:`dask.array.Array`).</span>

<span class="sd">        * axis (int or list of int):</span>
<span class="sd">            The dimensions to aggregate over -- note that this is defined</span>
<span class="sd">            differently to the &#39;aggregate&#39; method &#39;axis&#39; argument, which only</span>
<span class="sd">            accepts a single dimension index.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * kwargs:</span>
<span class="sd">            All keyword arguments are passed through to the data aggregation</span>
<span class="sd">            function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A lazy array representing the aggregation operation</span>
<span class="sd">            (:class:`dask.array.Array`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> aggregator does not support lazy operation.&quot;</span>
            <span class="k">raise</span> <span class="n">LazyAggregatorError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()))</span>

        <span class="c1"># Combine keyword args with `kwargs` taking priority over those</span>
        <span class="c1"># provided to __init__.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy_func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the aggregation function given the data.</span>

<span class="sd">        Keyword arguments are passed through to the data aggregation function</span>
<span class="sd">        (for example, the &quot;percent&quot; keyword for a percentile aggregator).</span>
<span class="sd">        This function is usually used in conjunction with update_metadata(),</span>
<span class="sd">        which should be passed the same keyword arguments.</span>

<span class="sd">        Args:</span>

<span class="sd">        * data (array):</span>
<span class="sd">            Data array.</span>

<span class="sd">        * axis (int):</span>
<span class="sd">            Axis to aggregate over.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * mdtol (float):</span>
<span class="sd">            Tolerance of missing data. The value returned will be masked if</span>
<span class="sd">            the fraction of data to missing data is less than or equal to</span>
<span class="sd">            mdtol.  mdtol=0 means no missing data is tolerated while mdtol=1</span>
<span class="sd">            will return the resulting value from the aggregation function.</span>
<span class="sd">            Defaults to 1.</span>

<span class="sd">        * kwargs:</span>
<span class="sd">            All keyword arguments apart from those specified above, are</span>
<span class="sd">            passed through to the data aggregation function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The aggregated data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="n">mdtol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;mdtol&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mdtol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">fraction_not_missing</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">mask_update</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mdtol</span> <span class="o">&gt;</span> <span class="n">fraction_not_missing</span>
            <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">mask</span> <span class="o">|</span> <span class="n">mask_update</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_update</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">update_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update common cube metadata w.r.t the aggregation function.</span>

<span class="sd">        Args:</span>

<span class="sd">        * cube (:class:`iris.cube.Cube`):</span>
<span class="sd">            Source cube that requires metadata update.</span>
<span class="sd">        * coords (:class:`iris.coords.Coord`):</span>
<span class="sd">            The one or more coordinates that were aggregated.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * This function is intended to be used in conjunction with aggregate()</span>
<span class="sd">          and should be passed the same keywords (for example, the &quot;ddof&quot;</span>
<span class="sd">          keyword for a standard deviation aggregator).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update the units if required.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units_func</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the result from :func:`iris.analysis.Aggregator.aggregate`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * collapsed_cube:</span>
<span class="sd">            A :class:`iris.cube.Cube`.</span>
<span class="sd">        * data_result:</span>
<span class="sd">            Result from :func:`iris.analysis.Aggregator.aggregate`</span>
<span class="sd">        * coords:</span>
<span class="sd">            The one or more coordinates that were aggregated over.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * This function is intended to be used in conjunction with aggregate()</span>
<span class="sd">          and should be passed the same keywords (for example, the &quot;ddof&quot;</span>
<span class="sd">          keyword from a standard deviation aggregator).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The collapsed cube with its aggregated data payload.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">collapsed_cube</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data_result</span>
        <span class="k">return</span> <span class="n">collapsed_cube</span>

    <span class="k">def</span> <span class="nf">aggregate_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shape of the new dimension/s created by the aggregator.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * This function is intended to be used in conjunction with aggregate()</span>
<span class="sd">          and should be passed the same keywords.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of the aggregate shape.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the aggregator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_method</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
        <span class="k">return</span> <span class="n">name</span>


<span class="k">class</span> <span class="nc">PercentileAggregator</span><span class="p">(</span><span class="n">_Aggregator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`PercentileAggregator` class provides percentile aggregation</span>
<span class="sd">    functionality.</span>

<span class="sd">    This aggregator *may* introduce a new dimension to the data for the</span>
<span class="sd">    statistic being calculated, but only if more than one quantile is required.</span>
<span class="sd">    For example, calculating the 50th and 90th percentile will result in a new</span>
<span class="sd">    data dimension with an extent of 2, for each of the quantiles calculated.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lazy_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a percentile aggregator.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * units_func (callable):</span>
<span class="sd">            | *Call signature*: (units)</span>

<span class="sd">            If provided, called to convert a cube&#39;s units.</span>
<span class="sd">            Returns an :class:`cf_units.Unit`, or a</span>
<span class="sd">            value that can be made into one.</span>

<span class="sd">        * lazy_func (callable or None):</span>
<span class="sd">            An alternative to :data:`call_func` implementing a lazy</span>
<span class="sd">            aggregation. Note that, it need not support all features of the</span>
<span class="sd">            main operation, but should raise an error in unhandled cases.</span>

<span class="sd">        Additional kwargs::</span>
<span class="sd">            Passed through to :data:`call_func` and :data:`lazy_func`.</span>

<span class="sd">        This aggregator can used by cube aggregation methods such as</span>
<span class="sd">        :meth:`~iris.cube.Cube.collapsed` and</span>
<span class="sd">        :meth:`~iris.cube.Cube.aggregated_by`.  For example::</span>

<span class="sd">            cube.collapsed(&#39;longitude&#39;, iris.analysis.PERCENTILE, percent=50)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;percentile&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;percent&quot;</span><span class="p">]</span>
        <span class="n">_Aggregator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">_percentile</span><span class="p">,</span>
            <span class="n">units_func</span><span class="o">=</span><span class="n">units_func</span><span class="p">,</span>
            <span class="n">lazy_func</span><span class="o">=</span><span class="n">lazy_func</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the percentile aggregation over the given data.</span>

<span class="sd">        Keyword arguments are passed through to the data aggregation function</span>
<span class="sd">        (for example, the &quot;percent&quot; keyword for a percentile aggregator).</span>
<span class="sd">        This function is usually used in conjunction with update_metadata(),</span>
<span class="sd">        which should be passed the same keyword arguments.</span>

<span class="sd">        Args:</span>

<span class="sd">        * data (array):</span>
<span class="sd">            Data array.</span>

<span class="sd">        * axis (int):</span>
<span class="sd">            Axis to aggregate over.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * mdtol (float):</span>
<span class="sd">            Tolerance of missing data. The value returned will be masked if</span>
<span class="sd">            the fraction of data to missing data is less than or equal to</span>
<span class="sd">            mdtol.  mdtol=0 means no missing data is tolerated while mdtol=1</span>
<span class="sd">            will return the resulting value from the aggregation function.</span>
<span class="sd">            Defaults to 1.</span>

<span class="sd">        * kwargs:</span>
<span class="sd">            All keyword arguments apart from those specified above, are</span>
<span class="sd">            passed through to the data aggregation function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The aggregated data.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> aggregator requires the mandatory keyword argument </span><span class="si">{!r}</span><span class="s2">.&quot;</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">arg</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_Aggregator</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the result from :func:`iris.analysis.Aggregator.aggregate`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * collapsed_cube:</span>
<span class="sd">            A :class:`iris.cube.Cube`.</span>
<span class="sd">        * data_result:</span>
<span class="sd">            Result from :func:`iris.analysis.Aggregator.aggregate`</span>
<span class="sd">        * coords:</span>
<span class="sd">            The one or more coordinates that were aggregated over.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * This function is intended to be used in conjunction with aggregate()</span>
<span class="sd">          and should be passed the same keywords (for example, the &quot;percent&quot;</span>
<span class="sd">          keywords from a percentile aggregator).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The collapsed cube with it&#39;s aggregated data payload.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cubes</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">()</span>
        <span class="c1"># The additive aggregator requires a mandatory keyword.</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> aggregator requires the mandatory keyword argument </span><span class="si">{!r}</span><span class="s2">.&quot;</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">arg</span><span class="p">))</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># Derive the name of the additive coordinate.</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
        <span class="n">coord_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_over_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">points</span><span class="p">]</span>

        <span class="c1"># Decorate a collapsed cube with a scalar additive coordinate</span>
        <span class="c1"># for each of the additive points, to result in a possibly higher</span>
        <span class="c1"># order cube.</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="n">cube</span> <span class="o">=</span> <span class="n">collapsed_cube</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">AuxCoord</span><span class="p">(</span>
                <span class="n">point</span><span class="p">,</span> <span class="n">long_name</span><span class="o">=</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;percent&quot;</span>
            <span class="p">)</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="n">cubes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>

        <span class="n">collapsed_cube</span> <span class="o">=</span> <span class="n">cubes</span><span class="o">.</span><span class="n">merge_cube</span><span class="p">()</span>

        <span class="c1"># Ensure to roll the data payload additive dimension, which should</span>
        <span class="c1"># be the last dimension for an additive operation with more than</span>
        <span class="c1"># one point, to be the first dimension, thus matching the collapsed</span>
        <span class="c1"># cube.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_shape</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Roll the last additive dimension to be the first.</span>
            <span class="n">data_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">data_result</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Marry the collapsed cube and the data payload together.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_Aggregator</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">aggregate_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The shape of the additive dimension created by the aggregator.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * This function is intended to be used in conjunction with aggregate()</span>
<span class="sd">          and should be passed the same keywords.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of the additive dimension shape.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> aggregator requires the mandatory keyword argument </span><span class="si">{!r}</span><span class="s2">.&quot;</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">arg</span><span class="p">))</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">points</span><span class="p">]</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">return</span> <span class="n">shape</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the aggregator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>


<span class="k">class</span> <span class="nc">WeightedPercentileAggregator</span><span class="p">(</span><span class="n">PercentileAggregator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`WeightedPercentileAggregator` class provides percentile</span>
<span class="sd">    aggregation functionality.</span>

<span class="sd">    This aggregator *may* introduce a new dimension to the data for the</span>
<span class="sd">    statistic being calculated, but only if more than one quantile is required.</span>
<span class="sd">    For example, calculating the 50th and 90th percentile will result in a new</span>
<span class="sd">    data dimension with an extent of 2, for each of the quantiles calculated.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lazy_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a weighted percentile aggregator.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * units_func (callable):</span>
<span class="sd">            | *Call signature*: (units)</span>

<span class="sd">            If provided, called to convert a cube&#39;s units.</span>
<span class="sd">            Returns an :class:`cf_units.Unit`, or a</span>
<span class="sd">            value that can be made into one.</span>

<span class="sd">        * lazy_func (callable or None):</span>
<span class="sd">            An alternative to :data:`call_func` implementing a lazy</span>
<span class="sd">            aggregation. Note that, it need not support all features of the</span>
<span class="sd">            main operation, but should raise an error in unhandled cases.</span>

<span class="sd">        Additional kwargs::</span>
<span class="sd">            Passed through to :data:`call_func` and :data:`lazy_func`.</span>

<span class="sd">        This aggregator can used by cube aggregation methods such as</span>
<span class="sd">        :meth:`~iris.cube.Cube.collapsed` and</span>
<span class="sd">        :meth:`~iris.cube.Cube.aggregated_by`.  For example::</span>

<span class="sd">            cube.collapsed(&#39;longitude&#39;, iris.analysis.WPERCENTILE, percent=50,</span>
<span class="sd">                             weights=iris.analysis.cartography.area_weights(cube))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_Aggregator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">_weighted_percentile</span><span class="p">,</span>
            <span class="n">units_func</span><span class="o">=</span><span class="n">units_func</span><span class="p">,</span>
            <span class="n">lazy_func</span><span class="o">=</span><span class="n">lazy_func</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;weighted_percentile&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;percent&quot;</span><span class="p">,</span> <span class="s2">&quot;weights&quot;</span><span class="p">]</span>

        <span class="c1">#: A list of keywords associated with weighted behaviour.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weighting_keywords</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;returned&quot;</span><span class="p">,</span> <span class="s2">&quot;weights&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the result from :func:`iris.analysis.Aggregator.aggregate`.</span>

<span class="sd">        Returns a tuple(cube, weights) if a tuple(data, weights) was returned</span>
<span class="sd">        from :func:`iris.analysis.Aggregator.aggregate`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * collapsed_cube:</span>
<span class="sd">            A :class:`iris.cube.Cube`.</span>
<span class="sd">        * data_result:</span>
<span class="sd">            Result from :func:`iris.analysis.Aggregator.aggregate`</span>
<span class="sd">        * coords:</span>
<span class="sd">            The one or more coordinates that were aggregated over.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * This function is intended to be used in conjunction with aggregate()</span>
<span class="sd">          and should be passed the same keywords (for example, the &quot;weights&quot;</span>
<span class="sd">          keyword).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The collapsed cube with it&#39;s aggregated data payload. Or a tuple</span>
<span class="sd">            pair of (cube, weights) if the keyword &quot;returned&quot; is specified</span>
<span class="sd">            and True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;returned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Package the data into the cube and return a tuple</span>
            <span class="n">collapsed_cube</span> <span class="o">=</span> <span class="n">PercentileAggregator</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">PercentileAggregator</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="Aggregator"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.Aggregator">[docs]</a><span class="k">class</span> <span class="nc">Aggregator</span><span class="p">(</span><span class="n">_Aggregator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`Aggregator` class provides common aggregation functionality.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Aggregator.update_metadata"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.Aggregator.update_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">update_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update cube cell method metadata w.r.t the aggregation function.</span>

<span class="sd">        Args:</span>

<span class="sd">        * cube (:class:`iris.cube.Cube`):</span>
<span class="sd">            Source cube that requires metadata update.</span>
<span class="sd">        * coords (:class:`iris.coords.Coord`):</span>
<span class="sd">            The one or more coordinates that were aggregated.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * This function is intended to be used in conjunction with aggregate()</span>
<span class="sd">          and should be passed the same keywords (for example, the &quot;ddof&quot;</span>
<span class="sd">          keyword for a standard deviation aggregator).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_Aggregator</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">]</span>

        <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Coordinate instance expected to the &quot;</span> <span class="s2">&quot;Aggregator object.&quot;</span>
                <span class="p">)</span>
            <span class="n">coord_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

        <span class="c1"># Add a cell method.</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_method</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">cell_method</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">CellMethod</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">)</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">add_cell_method</span><span class="p">(</span><span class="n">cell_method</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="WeightedAggregator"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.WeightedAggregator">[docs]</a><span class="k">class</span> <span class="nc">WeightedAggregator</span><span class="p">(</span><span class="n">Aggregator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience class that supports common weighted aggregation functionality.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cell_method</span><span class="p">,</span> <span class="n">call_func</span><span class="p">,</span> <span class="n">units_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lazy_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a weighted aggregator for the given :data:`call_func`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * cell_method (string):</span>
<span class="sd">            Cell method string that supports string format substitution.</span>

<span class="sd">        * call_func (callable):</span>
<span class="sd">            Data aggregation function. Call signature `(data, axis, **kwargs)`.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * units_func (callable):</span>
<span class="sd">            Units conversion function.</span>

<span class="sd">        * lazy_func (callable or None):</span>
<span class="sd">            An alternative to :data:`call_func` implementing a lazy</span>
<span class="sd">            aggregation. Note that, it need not support all features of the</span>
<span class="sd">            main operation, but should raise an error in unhandled cases.</span>

<span class="sd">        Additional kwargs:</span>
<span class="sd">            Passed through to :data:`call_func` and :data:`lazy_func`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Aggregator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cell_method</span><span class="p">,</span>
            <span class="n">call_func</span><span class="p">,</span>
            <span class="n">units_func</span><span class="o">=</span><span class="n">units_func</span><span class="p">,</span>
            <span class="n">lazy_func</span><span class="o">=</span><span class="n">lazy_func</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1">#: A list of keywords that trigger weighted behaviour.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weighting_keywords</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;returned&quot;</span><span class="p">,</span> <span class="s2">&quot;weights&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="WeightedAggregator.uses_weighting"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.WeightedAggregator.uses_weighting">[docs]</a>    <span class="k">def</span> <span class="nf">uses_weighting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether this aggregator uses weighting.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * kwargs:</span>
<span class="sd">            Arguments to filter of weighted keywords.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighting_keywords</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="WeightedAggregator.post_process"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.WeightedAggregator.post_process">[docs]</a>    <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the result from :func:`iris.analysis.Aggregator.aggregate`.</span>

<span class="sd">        Returns a tuple(cube, weights) if a tuple(data, weights) was returned</span>
<span class="sd">        from :func:`iris.analysis.Aggregator.aggregate`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * collapsed_cube:</span>
<span class="sd">            A :class:`iris.cube.Cube`.</span>
<span class="sd">        * data_result:</span>
<span class="sd">            Result from :func:`iris.analysis.Aggregator.aggregate`</span>
<span class="sd">        * coords:</span>
<span class="sd">            The one or more coordinates that were aggregated over.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * This function is intended to be used in conjunction with aggregate()</span>
<span class="sd">          and should be passed the same keywords (for example, the &quot;weights&quot;</span>
<span class="sd">          keywords from a mean aggregator).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The collapsed cube with it&#39;s aggregated data payload. Or a tuple</span>
<span class="sd">            pair of (cube, weights) if the keyword &quot;returned&quot; is specified</span>
<span class="sd">            and True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;returned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Package the data into the cube and return a tuple</span>
            <span class="n">collapsed_cube</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">collapsed_weights</span> <span class="o">=</span> <span class="n">data_result</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">collapsed_weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div></div>


<span class="k">def</span> <span class="nf">_build_dask_mdtol_function</span><span class="p">(</span><span class="n">dask_stats_function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a wrapped dask statistic function that supports the &#39;mdtol&#39; keyword.</span>

<span class="sd">    &#39;dask_function&#39; must be a dask statistical function, compatible with the</span>
<span class="sd">    call signature : &quot;dask_stats_function(data, axis=axis, **kwargs)&quot;.</span>
<span class="sd">    It must be masked-data tolerant, i.e. it ignores masked input points and</span>
<span class="sd">    performs a calculation on only the unmasked points.</span>
<span class="sd">    For example, mean([1, --, 2]) = (1 + 2) / 2 = 1.5.</span>

<span class="sd">    The returned value is a new function operating on dask arrays.</span>
<span class="sd">    It has the call signature `stat(data, axis=-1, mdtol=None, **kwargs)`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dask_stats_function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inner_stat</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mdtol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Call the statistic to get the basic result (missing-data tolerant).</span>
        <span class="n">dask_result</span> <span class="o">=</span> <span class="n">dask_stats_function</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mdtol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mdtol</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dask_result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Build a lazy computation to compare the fraction of missing</span>
            <span class="c1"># input points at each output point to the &#39;mdtol&#39; threshold.</span>
            <span class="n">point_mask_counts</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">points_per_calc</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">dask_result</span><span class="o">.</span><span class="n">size</span>
            <span class="n">masked_point_fractions</span> <span class="o">=</span> <span class="n">point_mask_counts</span> <span class="o">/</span> <span class="n">points_per_calc</span>
            <span class="n">boolean_mask</span> <span class="o">=</span> <span class="n">masked_point_fractions</span> <span class="o">&gt;</span> <span class="n">mdtol</span>
            <span class="c1"># Return an mdtol-masked version of the basic result.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span>
                <span class="n">da</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">dask_result</span><span class="p">),</span> <span class="n">boolean_mask</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">inner_stat</span>


<span class="k">def</span> <span class="nf">_percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">percent</span><span class="p">,</span> <span class="n">fast_percentile_method</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The percentile aggregator is an additive operation. This means that</span>
<span class="sd">    it *may* introduce a new dimension to the data for the statistic being</span>
<span class="sd">    calculated, but only if more than one percentile point is requested.</span>

<span class="sd">    If a new additive dimension is formed, then it will always be the last</span>
<span class="sd">    dimension of the resulting percentile data payload.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * fast_percentile_method (boolean) :</span>
<span class="sd">        When set to True, uses the numpy.percentiles method as a faster</span>
<span class="sd">        alternative to the scipy.mstats.mquantiles method. Does not handle</span>
<span class="sd">        masked arrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure that the target axis is the last dimension.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Flatten any leading dimensions.</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="c1"># Perform the percentile calculation.</span>
    <span class="k">if</span> <span class="n">fast_percentile_method</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot use fast np.percentile method with masked array.&quot;</span>
        <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">percent</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">mquantiles</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="c1"># Ensure to unflatten any leading dimensions.</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">percent</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">percent</span> <span class="o">=</span> <span class="p">[</span><span class="n">percent</span><span class="p">]</span>
        <span class="n">percent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span>
        <span class="c1"># Account for the additive dimension.</span>
        <span class="k">if</span> <span class="n">percent</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="n">shape</span> <span class="o">+=</span> <span class="n">percent</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Check whether to reduce to a scalar result, as per the behaviour</span>
    <span class="c1"># of other aggregators.</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="ow">and</span> <span class="n">quantiles</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_weighted_quantile_1D</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the weighted quantile of a 1D numpy array.</span>

<span class="sd">    Adapted from `wquantiles &lt;https://github.com/nudomarinero/wquantiles/&gt;`_</span>

<span class="sd">    Args:</span>

<span class="sd">    * data (array)</span>
<span class="sd">        One dimensional data array</span>
<span class="sd">    * weights (array)</span>
<span class="sd">        Array of the same size of `data`.  If data is masked, weights must have</span>
<span class="sd">        matching mask.</span>
<span class="sd">    * quantiles : (float or sequence of floats)</span>
<span class="sd">        Quantile(s) to compute. Must have a value between 0 and 1.</span>

<span class="sd">    **kwargs</span>
<span class="sd">        passed to `scipy.interpolate.interp1d`</span>

<span class="sd">    Returns:</span>
<span class="sd">        array or float.  Calculated quantile values (set to np.nan wherever sum</span>
<span class="sd">        of weights is zero or masked)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Return np.nan if no useable points found</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">quantiles</span><span class="p">))</span>
    <span class="c1"># Sort the data</span>
    <span class="n">ind_sorted</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">sorted_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ind_sorted</span><span class="p">]</span>
    <span class="n">sorted_weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">ind_sorted</span><span class="p">]</span>
    <span class="c1"># Compute the auxiliary arrays</span>
    <span class="n">Sn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">sorted_weights</span><span class="p">)</span>
    <span class="n">Pn</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sn</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sorted_weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sorted_weights</span><span class="p">)</span>
    <span class="c1"># Get the value of the weighted quantiles</span>
    <span class="n">interpolator</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
        <span class="n">Pn</span><span class="p">,</span> <span class="n">sorted_data</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>
    <span class="c1"># Set cases where quantile falls outside data range to min or max</span>
    <span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Pn</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">quantiles</span><span class="p">,</span> <span class="n">sorted_data</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Pn</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">quantiles</span><span class="p">,</span> <span class="n">sorted_data</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_weighted_percentile</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">percent</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The weighted_percentile aggregator is an additive operation. This means</span>
<span class="sd">    that it *may* introduce a new dimension to the data for the statistic being</span>
<span class="sd">    calculated, but only if more than one percentile point is requested.</span>

<span class="sd">    If a new additive dimension is formed, then it will always be the last</span>
<span class="sd">    dimension of the resulting percentile data payload.</span>

<span class="sd">    Args:</span>

<span class="sd">    * data: ndarray or masked array</span>

<span class="sd">    * axis: int</span>
<span class="sd">         axis to calculate percentiles over</span>

<span class="sd">    * weights: ndarray</span>
<span class="sd">         array with the weights.  Must have same shape as data</span>

<span class="sd">    * percent: float or sequence of floats</span>
<span class="sd">         Percentile rank/s at which to extract value/s.</span>

<span class="sd">    * returned: bool, optional</span>
<span class="sd">         Default False.  If True, returns a tuple with the percentiles as the</span>
<span class="sd">         first element and the sum of the weights as the second element.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure that data and weights arrays are same shape.</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_weighted_percentile: weights wrong shape.&quot;</span><span class="p">)</span>
    <span class="c1"># Ensure that the target axis is the last dimension.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span>
    <span class="c1"># Add data mask to weights if necessary.</span>
    <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Flatten any leading dimensions and loop over them</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">quantiles</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="c1"># Perform the percentile calculation.</span>
        <span class="k">for</span> <span class="n">res</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span> <span class="n">wt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">_weighted_quantile_1D</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">wt</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Data is 1D</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_weighted_quantile_1D</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="c1"># Ensure to unflatten any leading dimensions.</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">percent</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">percent</span> <span class="o">=</span> <span class="p">[</span><span class="n">percent</span><span class="p">]</span>
        <span class="n">percent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span>
        <span class="c1"># Account for the additive dimension.</span>
        <span class="k">if</span> <span class="n">percent</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="n">shape</span> <span class="o">+=</span> <span class="n">percent</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Check whether to reduce to a scalar result, as per the behaviour</span>
    <span class="c1"># of other aggregators.</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="ow">and</span> <span class="n">quantiles</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">returned</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="nd">@_build_dask_mdtol_function</span>
<span class="k">def</span> <span class="nf">_lazy_count</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_lazy_data</span><span class="o">.</span><span class="n">as_lazy_data</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;function must be a callable. Got </span><span class="si">{}</span><span class="s2">.&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">func</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_proportion</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_lazy_data</span><span class="o">.</span><span class="n">non_lazy</span><span class="p">(</span><span class="n">_lazy_count</span><span class="p">)</span>
    <span class="c1"># if the incoming array is masked use that to count the total number of</span>
    <span class="c1"># values</span>
    <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="c1"># calculate the total number of non-masked values across the given axis</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># numpy will return a single boolean as a mask if the mask</span>
            <span class="c1"># was not explicitly specified on array construction, so in this</span>
            <span class="c1"># case pass the array shape instead of the mask:</span>
            <span class="n">total_non_masked</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_non_masked</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span>
                <span class="n">array</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="n">total_non_masked</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_equal</span><span class="p">(</span><span class="n">total_non_masked</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">total_non_masked</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="c1"># Sanitise the result of this operation thru ma.asarray to ensure that</span>
    <span class="c1"># the dtype of the fill-value and the dtype of the array are aligned.</span>
    <span class="c1"># Otherwise, it is possible for numpy to return a masked array that has</span>
    <span class="c1"># a dtype for its data that is different to the dtype of the fill-value,</span>
    <span class="c1"># which can cause issues outside this function.</span>
    <span class="c1"># Reference - tests/unit/analyis/test_PROPORTION.py Test_masked.test_ma</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">total_non_masked</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_rms</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># XXX due to the current limitations in `da.average` (see below), maintain</span>
    <span class="c1"># an explicit non-lazy aggregation function for now.</span>
    <span class="c1"># Note: retaining this function also means that if weights are passed to</span>
    <span class="c1"># the lazy aggregator, the aggregation will fall back to using this</span>
    <span class="c1"># non-lazy aggregator.</span>
    <span class="n">rval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="n">rval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rval</span>


<span class="nd">@_build_dask_mdtol_function</span>
<span class="k">def</span> <span class="nf">_lazy_rms</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># XXX This should use `da.average` and not `da.mean`, as does the above.</span>
    <span class="c1"># However `da.average` current doesn&#39;t handle masked weights correctly</span>
    <span class="c1"># (see https://github.com/dask/dask/issues/3846).</span>
    <span class="c1"># To work around this we use da.mean, which doesn&#39;t support weights at</span>
    <span class="c1"># all. Thus trying to use this aggregator with weights will currently</span>
    <span class="c1"># raise an error in dask due to the unexpected keyword `weights`,</span>
    <span class="c1"># rather than silently returning the wrong answer.</span>
    <span class="k">return</span> <span class="n">da</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">array</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>


<span class="nd">@_build_dask_mdtol_function</span>
<span class="k">def</span> <span class="nf">_lazy_sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_lazy_data</span><span class="o">.</span><span class="n">as_lazy_data</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="c1"># weighted or scaled sum</span>
    <span class="n">axis_in</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">weights_in</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">returned_in</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;returned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weights_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wsum</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_in</span> <span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wsum</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">returned_in</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weights_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_lazy_data</span><span class="o">.</span><span class="n">as_lazy_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights_in</span>
        <span class="n">rvalue</span> <span class="o">=</span> <span class="p">(</span><span class="n">wsum</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_in</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rvalue</span> <span class="o">=</span> <span class="n">wsum</span>
    <span class="k">return</span> <span class="n">rvalue</span>


<span class="k">def</span> <span class="nf">_peak</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">column_segments</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
        <span class="n">nan_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">column</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nan_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">nan_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nan_indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">nan_index</span><span class="p">:</span>
                        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">[:</span><span class="n">nan_index</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">nan_indices</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nan_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">column</span><span class="p">[</span><span class="n">nan_indices</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">nan_index</span><span class="p">]</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">nan_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="n">nan_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="n">columns</span>

    <span class="k">def</span> <span class="nf">interp_order</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">k</span>

    <span class="c1"># Collapse array to its final data shape.</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">endslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">slices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">endslice</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>  <span class="c1"># Numpy&gt;=1.16 : index with tuple, *not* list.</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Cast non-float data type.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)[</span><span class="n">slices</span><span class="p">]</span>

    <span class="c1"># Generate nd-index iterator over array.</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ndindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ndindex</span> <span class="ow">in</span> <span class="n">ndindices</span><span class="p">:</span>
        <span class="n">ndindex_slice</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ndindex</span><span class="p">)</span>
        <span class="n">ndindex_slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">column_slice</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ndindex_slice</span><span class="p">)]</span>

        <span class="c1"># Check if the column slice contains a single value, nans only,</span>
        <span class="c1"># masked values only or if the values are all equal.</span>
        <span class="n">equal_slice</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">column_slice</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">column_slice</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">column_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">column_slice</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">column_slice</span><span class="p">))</span>
            <span class="ow">or</span> <span class="n">ma</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">column_slice</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">equal_slice</span><span class="p">,</span> <span class="n">column_slice</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># Check if the column slice is masked.</span>
        <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">column_slice</span><span class="p">):</span>
            <span class="c1"># Check if the column slice contains only nans, without inf</span>
            <span class="c1"># or -inf values, regardless of the mask.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">column_slice</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">column_slice</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">ndindex</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">continue</span>

            <span class="c1"># Replace masked values with nans.</span>
            <span class="n">column_slice</span> <span class="o">=</span> <span class="n">column_slice</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Determine the column segments that require a fitted spline.</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">column_segments</span><span class="p">(</span><span class="n">column_slice</span><span class="p">)</span>
        <span class="n">column_peaks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Determine the interpolation order for the spline fit.</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">interp_order</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">column_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">continue</span>

            <span class="n">tck</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">column</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">column</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
            <span class="n">spline</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">tck</span><span class="p">)</span>

            <span class="n">column_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="n">spline_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spline</span><span class="p">)</span>
            <span class="c1"># Check if the max value of the spline is greater than the</span>
            <span class="c1"># max value of the column.</span>
            <span class="k">if</span> <span class="n">spline_max</span> <span class="o">&gt;</span> <span class="n">column_max</span><span class="p">:</span>
                <span class="n">column_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spline_max</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">column_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column_max</span><span class="p">)</span>

        <span class="n">data</span><span class="p">[</span><span class="n">ndindex</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">column_peaks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="c1">#</span>
<span class="c1"># Common partial Aggregation class constructors.</span>
<span class="c1">#</span>
<span class="n">COUNT</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span>
    <span class="s2">&quot;count&quot;</span><span class="p">,</span>
    <span class="n">iris</span><span class="o">.</span><span class="n">_lazy_data</span><span class="o">.</span><span class="n">non_lazy</span><span class="p">(</span><span class="n">_lazy_count</span><span class="p">),</span>
    <span class="n">units_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">units</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">lazy_func</span><span class="o">=</span><span class="n">_lazy_count</span><span class="p">,</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that counts the number</span>
<span class="sd">of :class:`~iris.cube.Cube` data occurrences that satisfy a particular</span>
<span class="sd">criterion, as defined by a user supplied *function*.</span>

<span class="sd">**Required** kwargs associated with the use of this aggregator:</span>

<span class="sd">* function (callable):</span>
<span class="sd">    A function which converts an array of data values into a corresponding</span>
<span class="sd">    array of True/False values.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute the number of *ensemble members* with precipitation exceeding 10</span>
<span class="sd">(in cube data units) could be calculated with::</span>

<span class="sd">    result = precip_cube.collapsed(&#39;ensemble_member&#39;, iris.analysis.COUNT,</span>
<span class="sd">                                   function=lambda values: values &gt; 10)</span>

<span class="sd">.. seealso:: The :func:`~iris.analysis.PROPORTION` aggregator.</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">GMEAN</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span><span class="s2">&quot;geometric_mean&quot;</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">gmean</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates the</span>
<span class="sd">geometric mean over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">:func:`scipy.stats.mstats.gmean`.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute zonal geometric means over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.GMEAN)</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">HMEAN</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span><span class="s2">&quot;harmonic_mean&quot;</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">hmean</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates the</span>
<span class="sd">harmonic mean over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">:func:`scipy.stats.mstats.hmean`.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute zonal harmonic mean over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.HMEAN)</span>

<span class="sd">.. note::</span>

<span class="sd">    The harmonic mean is only valid if all data values are greater</span>
<span class="sd">    than zero.</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">MEAN</span> <span class="o">=</span> <span class="n">WeightedAggregator</span><span class="p">(</span>
    <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">average</span><span class="p">,</span> <span class="n">lazy_func</span><span class="o">=</span><span class="n">_build_dask_mdtol_function</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">average</span><span class="p">)</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the mean over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">:func:`numpy.ma.average`.</span>

<span class="sd">Additional kwargs associated with the use of this aggregator:</span>

<span class="sd">* mdtol (float):</span>
<span class="sd">    Tolerance of missing data. The value returned in each element of the</span>
<span class="sd">    returned array will be masked if the fraction of masked data contributing</span>
<span class="sd">    to that element exceeds mdtol. This fraction is calculated based on the</span>
<span class="sd">    number of masked elements. mdtol=0 means no missing data is tolerated</span>
<span class="sd">    while mdtol=1 means the resulting element will be masked if and only if</span>
<span class="sd">    all the contributing elements are masked. Defaults to 1.</span>
<span class="sd">* weights (float ndarray):</span>
<span class="sd">    Weights matching the shape of the cube or the length of the window</span>
<span class="sd">    for rolling window operations. Note that, latitude/longitude area</span>
<span class="sd">    weights can be calculated using</span>
<span class="sd">    :func:`iris.analysis.cartography.area_weights`.</span>
<span class="sd">* returned (boolean):</span>
<span class="sd">    Set this to True to indicate that the collapsed weights are to be</span>
<span class="sd">    returned along with the collapsed data. Defaults to False.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute zonal means over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.MEAN)</span>

<span class="sd">To compute a weighted area average::</span>

<span class="sd">    coords = (&#39;longitude&#39;, &#39;latitude&#39;)</span>
<span class="sd">    collapsed_cube, collapsed_weights = cube.collapsed(coords,</span>
<span class="sd">                                                       iris.analysis.MEAN,</span>
<span class="sd">                                                       weights=weights,</span>
<span class="sd">                                                       returned=True)</span>

<span class="sd">.. note::</span>

<span class="sd">    Lazy operation is supported, via :func:`dask.array.ma.average`.</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">MEDIAN</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the median over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">:func:`numpy.ma.median`.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute zonal medians over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.MEDIAN)</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">MIN</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span>
    <span class="s2">&quot;minimum&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">lazy_func</span><span class="o">=</span><span class="n">_build_dask_mdtol_function</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the minimum over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">:func:`numpy.ma.min`.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute zonal minimums over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.MIN)</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">MAX</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span>
    <span class="s2">&quot;maximum&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">lazy_func</span><span class="o">=</span><span class="n">_build_dask_mdtol_function</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the maximum over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">:func:`numpy.ma.max`.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute zonal maximums over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.MAX)</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">PEAK</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span><span class="s2">&quot;peak&quot;</span><span class="p">,</span> <span class="n">_peak</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the peak value derived from a spline interpolation over a</span>
<span class="sd">:class:`~iris.cube.Cube`.</span>

<span class="sd">The peak calculation takes into account nan values. Therefore, if the number</span>
<span class="sd">of non-nan values is zero the result itself will be an array of nan values.</span>

<span class="sd">The peak calculation also takes into account masked values. Therefore, if the</span>
<span class="sd">number of non-masked values is zero the result itself will be a masked array.</span>

<span class="sd">If multiple coordinates are specified, then the peak calculations are</span>
<span class="sd">performed individually, in sequence, for each coordinate specified.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute the peak over the *time* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;time&#39;, iris.analysis.PEAK)</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">PERCENTILE</span> <span class="o">=</span> <span class="n">PercentileAggregator</span><span class="p">(</span><span class="n">alphap</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">betap</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.PercentileAggregator` instance that calculates the</span>
<span class="sd">percentile over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">:func:`scipy.stats.mstats.mquantiles`.</span>

<span class="sd">**Required** kwargs associated with the use of this aggregator:</span>

<span class="sd">* percent (float or sequence of floats):</span>
<span class="sd">    Percentile rank/s at which to extract value/s.</span>

<span class="sd">Additional kwargs associated with the use of this aggregator:</span>

<span class="sd">* alphap (float):</span>
<span class="sd">    Plotting positions parameter, see :func:`scipy.stats.mstats.mquantiles`.</span>
<span class="sd">    Defaults to 1.</span>
<span class="sd">* betap (float):</span>
<span class="sd">    Plotting positions parameter, see :func:`scipy.stats.mstats.mquantiles`.</span>
<span class="sd">    Defaults to 1.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute the 10th and 90th percentile over *time*::</span>

<span class="sd">    result = cube.collapsed(&#39;time&#39;, iris.analysis.PERCENTILE, percent=[10, 90])</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">PROPORTION</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span><span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="n">_proportion</span><span class="p">,</span> <span class="n">units_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">units</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates the</span>
<span class="sd">proportion, as a fraction, of :class:`~iris.cube.Cube` data occurrences</span>
<span class="sd">that satisfy a particular criterion, as defined by a user supplied</span>
<span class="sd">*function*.</span>

<span class="sd">**Required** kwargs associated with the use of this aggregator:</span>

<span class="sd">* function (callable):</span>
<span class="sd">    A function which converts an array of data values into a corresponding</span>
<span class="sd">    array of True/False values.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute the probability of precipitation exceeding 10</span>
<span class="sd">(in cube data units) across *ensemble members* could be calculated with::</span>

<span class="sd">    result = precip_cube.collapsed(&#39;ensemble_member&#39;, iris.analysis.PROPORTION,</span>
<span class="sd">                                   function=lambda values: values &gt; 10)</span>

<span class="sd">Similarly, the proportion of *time* precipitation exceeded 10</span>
<span class="sd">(in cube data units) could be calculated with::</span>

<span class="sd">    result = precip_cube.collapsed(&#39;time&#39;, iris.analysis.PROPORTION,</span>
<span class="sd">                                   function=lambda values: values &gt; 10)</span>

<span class="sd">.. seealso:: The :func:`~iris.analysis.COUNT` aggregator.</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">RMS</span> <span class="o">=</span> <span class="n">WeightedAggregator</span><span class="p">(</span>
    <span class="s2">&quot;root mean square&quot;</span><span class="p">,</span> <span class="n">_rms</span><span class="p">,</span> <span class="n">lazy_func</span><span class="o">=</span><span class="n">_build_dask_mdtol_function</span><span class="p">(</span><span class="n">_lazy_rms</span><span class="p">)</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the root mean square over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">((x0**2 + x1**2 + ... + xN-1**2) / N) ** 0.5.</span>

<span class="sd">Additional kwargs associated with the use of this aggregator:</span>

<span class="sd">* weights (float ndarray):</span>
<span class="sd">    Weights matching the shape of the cube or the length of the window for</span>
<span class="sd">    rolling window operations. The weights are applied to the squares when</span>
<span class="sd">    taking the mean.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute the zonal root mean square over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.RMS)</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">STD_DEV</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span>
    <span class="s2">&quot;standard_deviation&quot;</span><span class="p">,</span>
    <span class="n">ma</span><span class="o">.</span><span class="n">std</span><span class="p">,</span>
    <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">lazy_func</span><span class="o">=</span><span class="n">_build_dask_mdtol_function</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">std</span><span class="p">),</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the standard deviation over a :class:`~iris.cube.Cube`, as</span>
<span class="sd">computed by :func:`numpy.ma.std`.</span>

<span class="sd">Additional kwargs associated with the use of this aggregator:</span>

<span class="sd">* ddof (integer):</span>
<span class="sd">    Delta degrees of freedom. The divisor used in calculations is N - ddof,</span>
<span class="sd">    where N represents the number of elements. Defaults to 1.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute zonal standard deviations over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.STD_DEV)</span>

<span class="sd">To obtain the biased standard deviation::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.STD_DEV, ddof=0)</span>

<span class="sd">.. note::</span>

<span class="sd">    Lazy operation is supported, via :func:`dask.array.nanstd`.</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">SUM</span> <span class="o">=</span> <span class="n">WeightedAggregator</span><span class="p">(</span>
    <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">iris</span><span class="o">.</span><span class="n">_lazy_data</span><span class="o">.</span><span class="n">non_lazy</span><span class="p">(</span><span class="n">_lazy_sum</span><span class="p">),</span>
    <span class="n">lazy_func</span><span class="o">=</span><span class="n">_build_dask_mdtol_function</span><span class="p">(</span><span class="n">_lazy_sum</span><span class="p">),</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the sum over a :class:`~iris.cube.Cube`, as computed by :func:`numpy.ma.sum`.</span>

<span class="sd">Additional kwargs associated with the use of this aggregator:</span>

<span class="sd">* weights (float ndarray):</span>
<span class="sd">    Weights matching the shape of the cube, or the length of</span>
<span class="sd">    the window for rolling window operations. Weights should be</span>
<span class="sd">    normalized before using them with this aggregator if scaling</span>
<span class="sd">    is not intended.</span>
<span class="sd">* returned (boolean):</span>
<span class="sd">    Set this to True to indicate the collapsed weights are to be returned</span>
<span class="sd">    along with the collapsed data. Defaults to False.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute an accumulation over the *time* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;time&#39;, iris.analysis.SUM)</span>

<span class="sd">To compute a weighted rolling sum e.g. to apply a digital filter::</span>

<span class="sd">    weights = np.array([.1, .2, .4, .2, .1])</span>
<span class="sd">    result = cube.rolling_window(&#39;time&#39;, iris.analysis.SUM,</span>
<span class="sd">                                 len(weights), weights=weights)</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">VARIANCE</span> <span class="o">=</span> <span class="n">Aggregator</span><span class="p">(</span>
    <span class="s2">&quot;variance&quot;</span><span class="p">,</span>
    <span class="n">ma</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
    <span class="n">units_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">units</span><span class="p">:</span> <span class="n">units</span> <span class="o">*</span> <span class="n">units</span><span class="p">,</span>
    <span class="n">lazy_func</span><span class="o">=</span><span class="n">_build_dask_mdtol_function</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">var</span><span class="p">),</span>
    <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.Aggregator` instance that calculates</span>
<span class="sd">the variance over a :class:`~iris.cube.Cube`, as computed by</span>
<span class="sd">:func:`numpy.ma.var`.</span>

<span class="sd">Additional kwargs associated with the use of this aggregator:</span>

<span class="sd">* ddof (integer):</span>
<span class="sd">    Delta degrees of freedom. The divisor used in calculations is N - ddof,</span>
<span class="sd">    where N represents the number of elements. Defaults to 1.</span>

<span class="sd">**For example**:</span>

<span class="sd">To compute zonal variance over the *longitude* axis of a cube::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.VARIANCE)</span>

<span class="sd">To obtain the biased variance::</span>

<span class="sd">    result = cube.collapsed(&#39;longitude&#39;, iris.analysis.VARIANCE, ddof=0)</span>

<span class="sd">.. note::</span>

<span class="sd">    Lazy operation is supported, via :func:`dask.array.nanvar`.</span>

<span class="sd">This aggregator handles masked data.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="n">WPERCENTILE</span> <span class="o">=</span> <span class="n">WeightedPercentileAggregator</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An :class:`~iris.analysis.WeightedPercentileAggregator` instance that</span>
<span class="sd">calculates the weighted percentile over a :class:`~iris.cube.Cube`.</span>

<span class="sd">**Required** kwargs associated with the use of this aggregator:</span>

<span class="sd">* percent (float or sequence of floats):</span>
<span class="sd">    Percentile rank/s at which to extract value/s.</span>

<span class="sd">* weights (float ndarray):</span>
<span class="sd">    Weights matching the shape of the cube or the length of the window</span>
<span class="sd">    for rolling window operations. Note that, latitude/longitude area</span>
<span class="sd">    weights can be calculated using</span>
<span class="sd">    :func:`iris.analysis.cartography.area_weights`.</span>

<span class="sd">Additional kwargs associated with the use of this aggregator:</span>

<span class="sd">* returned (boolean):</span>
<span class="sd">    Set this to True to indicate that the collapsed weights are to be</span>
<span class="sd">    returned along with the collapsed data. Defaults to False.</span>

<span class="sd">* kind (string or int):</span>
<span class="sd">    Specifies the kind of interpolation used, see</span>
<span class="sd">    :func:`scipy.interpolate.interp1d` Defaults to &quot;linear&quot;, which is</span>
<span class="sd">    equivalent to alphap=0.5, betap=0.5 in `iris.analysis.PERCENTILE`</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_Groupby</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience class to determine group slices over one or more group-by</span>
<span class="sd">    coordinates.</span>

<span class="sd">    Generate the coordinate slices for the groups and calculate the</span>
<span class="sd">    new group-by coordinates and the new shared coordinates given the</span>
<span class="sd">    group slices. Note that, new shared coordinates will be bounded</span>
<span class="sd">    coordinates.</span>

<span class="sd">    Assumes that all the coordinates share the same axis, therefore all</span>
<span class="sd">    of the coordinates must be of the same length.</span>

<span class="sd">    Group-by coordinates are those coordinates over which value groups</span>
<span class="sd">    are to be determined.</span>

<span class="sd">    Shared coordinates are those coordinates which share the same axis</span>
<span class="sd">    as group-by coordinates, but which are not to be included in the</span>
<span class="sd">    group-by analysis.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupby_coords</span><span class="p">,</span> <span class="n">shared_coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the group slices over the group-by coordinates.</span>

<span class="sd">        Args:</span>

<span class="sd">        * groupby_coords (list :class:`iris.coords.Coord` instances):</span>
<span class="sd">            One or more coordinates from the same axis over which to group-by.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * shared_coords (list of (:class:`iris.coords.Coord`, `int`) pairs):</span>
<span class="sd">            One or more coordinates (including multidimensional coordinates)</span>
<span class="sd">            that share the same group-by coordinate axis.  The `int` identifies</span>
<span class="sd">            which dimension of the coord is on the group-by coordinate axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#: Group-by and shared coordinates that have been grouped.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groupby_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shared_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Ensure group-by coordinates are iterable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupby_coords</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;groupby_coords must be a &quot;</span> <span class="s2">&quot;`collections.Iterable` type.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Add valid group-by coordinates.</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">groupby_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_groupby_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="c1"># Add the coordinates sharing the same axis as the group-by</span>
        <span class="c1"># coordinates.</span>
        <span class="k">if</span> <span class="n">shared_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Ensure shared coordinates are iterable.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shared_coords</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;shared_coords must be a &quot;</span> <span class="s2">&quot;`collections.Iterable` type.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Add valid shared coordinates.</span>
            <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shared_coords</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_shared_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_groupby_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Group-by coordinates have different lengths.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groupby_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_shared_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shared coordinates have different lengths.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shared_coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coord</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the groups and associated slices over one or more group-by</span>
<span class="sd">        coordinates.</span>

<span class="sd">        Also creates new group-by and shared coordinates given the calculated</span>
<span class="sd">        group slices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A generator of the coordinate group slices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupby_coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="p">:</span>
                <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupby_coords</span><span class="p">:</span>
                    <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">_GroupIterator</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
                    <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

                <span class="c1"># Construct the group slice for each group over the group-by</span>
                <span class="c1"># coordinates. Keep constructing until all group-by coordinate</span>
                <span class="c1"># groups are exhausted.</span>
                <span class="k">while</span> <span class="nb">any</span><span class="p">([</span><span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]):</span>
                    <span class="c1"># Determine the extent (start, stop) of the group given</span>
                    <span class="c1"># each current group-by coordinate group.</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">item</span><span class="o">.</span><span class="n">groupby_slice</span><span class="o">.</span><span class="n">start</span>
                            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span>
                            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">item</span><span class="o">.</span><span class="n">groupby_slice</span><span class="o">.</span><span class="n">stop</span>
                            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span>
                            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="c1"># Construct composite group key for the group using the</span>
                    <span class="c1"># start value from each group-by coordinate.</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupby_coords</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="c1"># Associate group slice with group key within the ordered</span>
                    <span class="c1"># dictionary.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="c1"># Prepare for the next group slice construction over the</span>
                    <span class="c1"># group-by coordinates.</span>
                    <span class="k">for</span> <span class="n">item_index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="c1"># Get coordinate current group slice.</span>
                        <span class="n">groupby_slice</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">groupby_slice</span>
                        <span class="c1"># Determine whether coordinate has spanned all its</span>
                        <span class="c1"># groups i.e. its full length</span>
                        <span class="c1"># or whether we need to get the coordinates next group.</span>
                        <span class="k">if</span> <span class="n">groupby_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">:</span>
                            <span class="c1"># This coordinate has exhausted all its groups,</span>
                            <span class="c1"># so remove it.</span>
                            <span class="n">items</span><span class="p">[</span><span class="n">item_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">elif</span> <span class="n">groupby_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                            <span class="c1"># The current group of this coordinate is</span>
                            <span class="c1"># exhausted, so get the next one.</span>
                            <span class="n">items</span><span class="p">[</span><span class="n">item_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="n">item_index</span><span class="p">])</span>

                <span class="c1"># Merge multiple slices together into one tuple.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_slice_merge</span><span class="p">()</span>
                <span class="c1"># Calculate the new group-by coordinates.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_groupby_coords</span><span class="p">()</span>
                <span class="c1"># Calculate the new shared coordinates.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_shared_coords</span><span class="p">()</span>
            <span class="c1"># Generate the group-by slices/groups.</span>
            <span class="k">for</span> <span class="n">groupby_slice</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">groupby_slice</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_slice_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge multiple slices into one tuple and collapse items from</span>
<span class="sd">        containing list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Iterate over the ordered dictionary in order to reduce</span>
        <span class="c1"># multiple slices into a single tuple and collapse</span>
        <span class="c1"># all items from containing list.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">groupby_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groupby_slices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Compress multiple slices into tuple representation.</span>
                <span class="n">groupby_indicies</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">groupby_slice</span> <span class="ow">in</span> <span class="n">groupby_slices</span><span class="p">:</span>
                    <span class="n">groupby_indicies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="nb">range</span><span class="p">(</span><span class="n">groupby_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">groupby_slice</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">groupby_indicies</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Remove single inner slice from list.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">groupby_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_groupby_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new group-by coordinates given the group slices.&quot;&quot;&quot;</span>

        <span class="n">groupby_slice</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate over the ordered dictionary in order to construct</span>
        <span class="c1"># a group-by slice that samples the first element from each group.</span>
        <span class="k">for</span> <span class="n">key_slice</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_slice</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">groupby_slice</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">groupby_slice</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_slice</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

        <span class="n">groupby_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groupby_slice</span><span class="p">)</span>

        <span class="c1"># Create new group-by coordinates from the group-by slice.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="n">groupby_slice</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupby_coords</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_shared_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the new shared coordinates given the group slices.&quot;&quot;&quot;</span>

        <span class="n">groupby_bounds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate over the ordered dictionary in order to construct</span>
        <span class="c1"># a list of tuple group boundary indexes.</span>
        <span class="k">for</span> <span class="n">key_slice</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_slice</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">groupby_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key_slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">groupby_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Create new shared bounded coordinates.</span>
        <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shared_coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;SU&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">new_points</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">new_bounds</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># np.apply_along_axis does not work with str.join, so we</span>
                    <span class="c1"># need to loop through the array directly. First move axis</span>
                    <span class="c1"># of interest to trailing dim and flatten the others.</span>
                    <span class="n">work_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="n">work_arr</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">work_shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>
                    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">new_shape</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">work_arr</span> <span class="o">=</span> <span class="n">work_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">work_shape</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">key_slice</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                            <span class="n">indices</span> <span class="o">=</span> <span class="n">key_slice</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span>
                                <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">key_slice</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">work_arr</span><span class="p">:</span>
                            <span class="n">new_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">key_slice</span><span class="p">)))</span>

                    <span class="c1"># Reinstate flattened dimensions. Aggregated dim now leads.</span>
                    <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>

                    <span class="c1"># Move aggregated dimension back to position it started in.</span>
                    <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">new_points</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;collapsing the bounded string coordinate </span><span class="si">{0!r}</span><span class="s2">&quot;</span>
                        <span class="s2">&quot; is not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_bounds</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Construct list of coordinate group boundary pairs.</span>
                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">groupby_bounds</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                        <span class="c1"># Collapse group bounds into bounds.</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="p">(</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="n">new_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                    <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="o">+</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span><span class="p">,</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                    <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Collapse group points into bounds.</span>
                        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                            <span class="n">new_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span>
                                    <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
                                    <span class="o">+</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span><span class="p">,</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span>
                                    <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span>
                                <span class="p">]</span>
                            <span class="p">)</span>

                <span class="c1"># Bounds needs to be an array with the length 2 start-stop</span>
                <span class="c1"># dimension last, and the aggregated dimension back in its</span>
                <span class="c1"># original position.</span>
                <span class="n">new_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_bounds</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Now create the new bounded group shared coordinate.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">new_points</span> <span class="o">=</span> <span class="n">new_bounds</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;The </span><span class="si">{0!r}</span><span class="s2"> coordinate on the collapsing dimension&quot;</span>
                        <span class="s2">&quot; cannot be collapsed.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">coord</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">new_points</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">new_bounds</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># non monotonic points/bounds</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">AuxCoord</span><span class="o">.</span><span class="n">from_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                        <span class="n">points</span><span class="o">=</span><span class="n">new_points</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">new_bounds</span>
                    <span class="p">)</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the number of groups given the group-by coordinates.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slices_by_key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">()])</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">groupby_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupby_coords</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shared_coords_by_name</span><span class="p">:</span>
            <span class="n">shared_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shared_coords</span><span class="p">]</span>
            <span class="n">shared_string</span> <span class="o">=</span> <span class="s2">&quot;, shared_coords=</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">shared_coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shared_string</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%r%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">groupby_coords</span><span class="p">,</span>
            <span class="n">shared_string</span><span class="p">,</span>
        <span class="p">)</span>


<div class="viewcode-block" id="clear_phenomenon_identity"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.clear_phenomenon_identity">[docs]</a><span class="k">def</span> <span class="nf">clear_phenomenon_identity</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to clear the standard_name, attributes, and</span>
<span class="sd">    cell_methods of a cube.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">cell_methods</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#</span>
<span class="c1"># Interpolation API</span>
<span class="c1">#</span>
<span class="c1">###############################################################################</span>


<div class="viewcode-block" id="Linear"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.Linear">[docs]</a><span class="k">class</span> <span class="nc">Linear</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class describes the linear interpolation and regridding scheme for</span>
<span class="sd">    interpolating or regridding over one or more orthogonal coordinates,</span>
<span class="sd">    typically for use with :meth:`iris.cube.Cube.interpolate()` or</span>
<span class="sd">    :meth:`iris.cube.Cube.regrid()`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LINEAR_EXTRAPOLATION_MODES</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">EXTRAPOLATION_MODES</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extrapolation_mode</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Linear interpolation and regridding scheme suitable for interpolating</span>
<span class="sd">        or regridding over one or more orthogonal coordinates.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * extrapolation_mode:</span>
<span class="sd">            Must be one of the following strings:</span>

<span class="sd">              * &#39;extrapolate&#39; or &#39;linear&#39; - The extrapolation points</span>
<span class="sd">                will be calculated by extending the gradient of the</span>
<span class="sd">                closest two points.</span>
<span class="sd">              * &#39;nan&#39; - The extrapolation points will be be set to NaN.</span>
<span class="sd">              * &#39;error&#39; - A ValueError exception will be raised, notifying an</span>
<span class="sd">                attempt to extrapolate.</span>
<span class="sd">              * &#39;mask&#39; - The extrapolation points will always be masked, even</span>
<span class="sd">                if the source data is not a MaskedArray.</span>
<span class="sd">              * &#39;nanmask&#39; - If the source data is a MaskedArray the</span>
<span class="sd">                extrapolation points will be masked. Otherwise they will be</span>
<span class="sd">                set to NaN.</span>

<span class="sd">            The default mode of extrapolation is &#39;linear&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolation_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">LINEAR_EXTRAPOLATION_MODES</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Extrapolation mode </span><span class="si">{!r}</span><span class="s2"> not supported.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extrapolation_mode</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolation_mode</span> <span class="o">=</span> <span class="n">extrapolation_mode</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Linear(</span><span class="si">{!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extrapolation_mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_normalised_extrapolation_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolation_mode</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;extrapolate&quot;</span>
        <span class="k">return</span> <span class="n">mode</span>

<div class="viewcode-block" id="Linear.interpolator"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.Linear.interpolator">[docs]</a>    <span class="k">def</span> <span class="nf">interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a linear interpolator to perform interpolation over the</span>
<span class="sd">        given :class:`~iris.cube.Cube` specified by the dimensions of</span>
<span class="sd">        the given coordinates.</span>

<span class="sd">        Typically you should use :meth:`iris.cube.Cube.interpolate` for</span>
<span class="sd">        interpolating a cube. There are, however, some situations when</span>
<span class="sd">        constructing your own interpolator is preferable. These are detailed</span>
<span class="sd">        in the :ref:`user guide &lt;caching_an_interpolator&gt;`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * cube:</span>
<span class="sd">            The source :class:`iris.cube.Cube` to be interpolated.</span>
<span class="sd">        * coords:</span>
<span class="sd">            The names or coordinate instances that are to be</span>
<span class="sd">            interpolated over.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A callable with the interface:</span>

<span class="sd">                `callable(sample_points, collapse_scalar=True)`</span>

<span class="sd">            where `sample_points` is a sequence containing an array of values</span>
<span class="sd">            for each of the coordinates passed to this method, and</span>
<span class="sd">            `collapse_scalar` determines whether to remove length one</span>
<span class="sd">            dimensions in the result cube caused by scalar values in</span>
<span class="sd">            `sample_points`.</span>

<span class="sd">            The values for coordinates that correspond to date/times</span>
<span class="sd">            may optionally be supplied as datetime.datetime or</span>
<span class="sd">            cftime.datetime instances.</span>

<span class="sd">            For example, for the callable returned by:</span>
<span class="sd">            `Linear().interpolator(cube, [&#39;latitude&#39;, &#39;longitude&#39;])`,</span>
<span class="sd">            sample_points must have the form</span>
<span class="sd">            `[new_lat_values, new_lon_values]`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RectilinearInterpolator</span><span class="p">(</span>
            <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalised_extrapolation_mode</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Linear.regridder"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.Linear.regridder">[docs]</a>    <span class="k">def</span> <span class="nf">regridder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_grid</span><span class="p">,</span> <span class="n">target_grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a linear regridder to perform regridding from the source</span>
<span class="sd">        grid to the target grid.</span>

<span class="sd">        Typically you should use :meth:`iris.cube.Cube.regrid` for</span>
<span class="sd">        regridding a cube. There are, however, some situations when</span>
<span class="sd">        constructing your own regridder is preferable. These are detailed in</span>
<span class="sd">        the :ref:`user guide &lt;caching_a_regridder&gt;`.</span>

<span class="sd">        Supports lazy regridding. Any</span>
<span class="sd">        `chunks &lt;https://docs.dask.org/en/latest/array-chunks.html&gt;`__</span>
<span class="sd">        in horizontal dimensions will be combined before regridding.</span>

<span class="sd">        Args:</span>

<span class="sd">        * src_grid:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the source grid.</span>
<span class="sd">        * target_grid:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the target grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A callable with the interface:</span>

<span class="sd">                `callable(cube)`</span>

<span class="sd">            where `cube` is a cube with the same grid as `src_grid`</span>
<span class="sd">            that is to be regridded to the `target_grid`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RectilinearRegridder</span><span class="p">(</span>
            <span class="n">src_grid</span><span class="p">,</span>
            <span class="n">target_grid</span><span class="p">,</span>
            <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalised_extrapolation_mode</span><span class="p">(),</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="AreaWeighted"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.AreaWeighted">[docs]</a><span class="k">class</span> <span class="nc">AreaWeighted</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class describes an area-weighted regridding scheme for regridding</span>
<span class="sd">    between &#39;ordinary&#39; horizontal grids with separated X and Y coordinates in a</span>
<span class="sd">    common coordinate system.</span>
<span class="sd">    Typically for use with :meth:`iris.cube.Cube.regrid()`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mdtol</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Area-weighted regridding scheme suitable for regridding between</span>
<span class="sd">        different orthogonal XY grids in the same coordinate system.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * mdtol (float):</span>
<span class="sd">            Tolerance of missing data. The value returned in each element of</span>
<span class="sd">            the returned array will be masked if the fraction of missing data</span>
<span class="sd">            exceeds mdtol. This fraction is calculated based on the area of</span>
<span class="sd">            masked cells within each target cell. mdtol=0 means no masked</span>
<span class="sd">            data is tolerated while mdtol=1 will mean the resulting element</span>
<span class="sd">            will be masked if and only if all the overlapping elements of the</span>
<span class="sd">            source grid are masked. Defaults to 1.</span>

<span class="sd">        .. Note:</span>
<span class="sd">            Both sourge and target cubes must have an XY grid defined by</span>
<span class="sd">            separate X and Y dimensions with dimension coordinates.</span>
<span class="sd">            All of the XY dimension coordinates must also be bounded, and have</span>
<span class="sd">            the same cooordinate system.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">mdtol</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Value for mdtol must be in range 0 - 1, got </span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mdtol</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdtol</span> <span class="o">=</span> <span class="n">mdtol</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;AreaWeighted(mdtol=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdtol</span><span class="p">)</span>

<div class="viewcode-block" id="AreaWeighted.regridder"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.AreaWeighted.regridder">[docs]</a>    <span class="k">def</span> <span class="nf">regridder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_grid_cube</span><span class="p">,</span> <span class="n">target_grid_cube</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an area-weighted regridder to perform regridding from the</span>
<span class="sd">        source grid to the target grid.</span>

<span class="sd">        Typically you should use :meth:`iris.cube.Cube.regrid` for</span>
<span class="sd">        regridding a cube. There are, however, some situations when</span>
<span class="sd">        constructing your own regridder is preferable. These are detailed in</span>
<span class="sd">        the :ref:`user guide &lt;caching_a_regridder&gt;`.</span>

<span class="sd">        Supports lazy regridding. Any</span>
<span class="sd">        `chunks &lt;https://docs.dask.org/en/latest/array-chunks.html&gt;`__</span>
<span class="sd">        in horizontal dimensions will be combined before regridding.</span>

<span class="sd">        Args:</span>

<span class="sd">        * src_grid_cube:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the source grid.</span>
<span class="sd">        * target_grid_cube:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the target grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A callable with the interface:</span>

<span class="sd">                `callable(cube)`</span>

<span class="sd">            where `cube` is a cube with the same grid as `src_grid_cube`</span>
<span class="sd">            that is to be regridded to the grid of `target_grid_cube`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AreaWeightedRegridder</span><span class="p">(</span>
            <span class="n">src_grid_cube</span><span class="p">,</span> <span class="n">target_grid_cube</span><span class="p">,</span> <span class="n">mdtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mdtol</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="Nearest"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.Nearest">[docs]</a><span class="k">class</span> <span class="nc">Nearest</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class describes the nearest-neighbour interpolation and regridding</span>
<span class="sd">    scheme for interpolating or regridding over one or more orthogonal</span>
<span class="sd">    coordinates, typically for use with :meth:`iris.cube.Cube.interpolate()`</span>
<span class="sd">    or :meth:`iris.cube.Cube.regrid()`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extrapolation_mode</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nearest-neighbour interpolation and regridding scheme suitable for</span>
<span class="sd">        interpolating or regridding over one or more orthogonal coordinates.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * extrapolation_mode:</span>
<span class="sd">            Must be one of the following strings:</span>

<span class="sd">              * &#39;extrapolate&#39; - The extrapolation points will take their</span>
<span class="sd">                value from the nearest source point.</span>
<span class="sd">              * &#39;nan&#39; - The extrapolation points will be be set to NaN.</span>
<span class="sd">              * &#39;error&#39; - A ValueError exception will be raised, notifying an</span>
<span class="sd">                attempt to extrapolate.</span>
<span class="sd">              * &#39;mask&#39; - The extrapolation points will always be masked, even</span>
<span class="sd">                if the source data is not a MaskedArray.</span>
<span class="sd">              * &#39;nanmask&#39; - If the source data is a MaskedArray the</span>
<span class="sd">                extrapolation points will be masked. Otherwise they will be</span>
<span class="sd">                set to NaN.</span>

<span class="sd">            The default mode of extrapolation is &#39;extrapolate&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolation_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">EXTRAPOLATION_MODES</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Extrapolation mode </span><span class="si">{!r}</span><span class="s2"> not supported.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extrapolation_mode</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolation_mode</span> <span class="o">=</span> <span class="n">extrapolation_mode</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Nearest(</span><span class="si">{!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extrapolation_mode</span><span class="p">)</span>

<div class="viewcode-block" id="Nearest.interpolator"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.Nearest.interpolator">[docs]</a>    <span class="k">def</span> <span class="nf">interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a nearest-neighbour interpolator to perform</span>
<span class="sd">        interpolation over the given :class:`~iris.cube.Cube` specified</span>
<span class="sd">        by the dimensions of the specified coordinates.</span>

<span class="sd">        Typically you should use :meth:`iris.cube.Cube.interpolate` for</span>
<span class="sd">        interpolating a cube. There are, however, some situations when</span>
<span class="sd">        constructing your own interpolator is preferable. These are detailed</span>
<span class="sd">        in the :ref:`user guide &lt;caching_an_interpolator&gt;`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * cube:</span>
<span class="sd">            The source :class:`iris.cube.Cube` to be interpolated.</span>
<span class="sd">        * coords:</span>
<span class="sd">            The names or coordinate instances that are to be</span>
<span class="sd">            interpolated over.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A callable with the interface:</span>

<span class="sd">                `callable(sample_points, collapse_scalar=True)`</span>

<span class="sd">            where `sample_points` is a sequence containing an array of values</span>
<span class="sd">            for each of the coordinates passed to this method, and</span>
<span class="sd">            `collapse_scalar` determines whether to remove length one</span>
<span class="sd">            dimensions in the result cube caused by scalar values in</span>
<span class="sd">            `sample_points`.</span>

<span class="sd">            The values for coordinates that correspond to date/times</span>
<span class="sd">            may optionally be supplied as datetime.datetime or</span>
<span class="sd">            cftime.datetime instances.</span>

<span class="sd">            For example, for the callable returned by:</span>
<span class="sd">            `Nearest().interpolator(cube, [&#39;latitude&#39;, &#39;longitude&#39;])`,</span>
<span class="sd">            sample_points must have the form</span>
<span class="sd">            `[new_lat_values, new_lon_values]`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RectilinearInterpolator</span><span class="p">(</span>
            <span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolation_mode</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Nearest.regridder"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.Nearest.regridder">[docs]</a>    <span class="k">def</span> <span class="nf">regridder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_grid</span><span class="p">,</span> <span class="n">target_grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a nearest-neighbour regridder to perform regridding from the</span>
<span class="sd">        source grid to the target grid.</span>

<span class="sd">        Typically you should use :meth:`iris.cube.Cube.regrid` for</span>
<span class="sd">        regridding a cube. There are, however, some situations when</span>
<span class="sd">        constructing your own regridder is preferable. These are detailed in</span>
<span class="sd">        the :ref:`user guide &lt;caching_a_regridder&gt;`.</span>

<span class="sd">        Supports lazy regridding. Any</span>
<span class="sd">        `chunks &lt;https://docs.dask.org/en/latest/array-chunks.html&gt;`__</span>
<span class="sd">        in horizontal dimensions will be combined before regridding.</span>

<span class="sd">        Args:</span>

<span class="sd">        * src_grid:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the source grid.</span>
<span class="sd">        * target_grid:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the target grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A callable with the interface:</span>

<span class="sd">                `callable(cube)`</span>

<span class="sd">            where `cube` is a cube with the same grid as `src_grid`</span>
<span class="sd">            that is to be regridded to the `target_grid`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RectilinearRegridder</span><span class="p">(</span>
            <span class="n">src_grid</span><span class="p">,</span> <span class="n">target_grid</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolation_mode</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="UnstructuredNearest"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.UnstructuredNearest">[docs]</a><span class="k">class</span> <span class="nc">UnstructuredNearest</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a nearest-neighbour regridding scheme for regridding data whose</span>
<span class="sd">    horizontal (X- and Y-axis) coordinates are mapped to the *same* dimensions,</span>
<span class="sd">    rather than being orthogonal on independent dimensions.</span>

<span class="sd">    For latitude-longitude coordinates, the nearest-neighbour distances are</span>
<span class="sd">    computed on the sphere, otherwise flat Euclidean distances are used.</span>

<span class="sd">    The source X and Y coordinates can have any shape.</span>

<span class="sd">    The target grid must be of the &quot;normal&quot; kind, i.e. it has separate,</span>
<span class="sd">    1-dimensional X and Y coordinates.</span>

<span class="sd">    Source and target XY coordinates must have the same coordinate system,</span>
<span class="sd">    which may also be None.</span>
<span class="sd">    If any of the XY coordinates are latitudes or longitudes, then they *all*</span>
<span class="sd">    must be.  Otherwise, the corresponding X and Y coordinates must have the</span>
<span class="sd">    same units in the source and grid cubes.</span>

<span class="sd">    .. Note::</span>
<span class="sd">        Currently only supports regridding, not interpolation.</span>

<span class="sd">    .. Note::</span>
<span class="sd">          This scheme performs essentially the same job as</span>
<span class="sd">          :class:`iris.experimental.regrid.ProjectedUnstructuredNearest`.</span>
<span class="sd">          That scheme is faster, but only works well on data in a limited</span>
<span class="sd">          region of the globe, covered by a specified projection.</span>
<span class="sd">          This approach is more rigorously correct and can be applied to global</span>
<span class="sd">          datasets.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Note: the argument requirements are simply those of the underlying</span>
    <span class="c1"># regridder class,</span>
    <span class="c1"># :class:`iris.analysis.trajectory.UnstructuredNearestNeigbourRegridder`.</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nearest-neighbour interpolation and regridding scheme suitable for</span>
<span class="sd">        interpolating or regridding from un-gridded data such as trajectories</span>
<span class="sd">        or other data where the X and Y coordinates share the same dimensions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;UnstructuredNearest()&quot;</span>

    <span class="c1"># TODO: add interpolator usage</span>
    <span class="c1"># def interpolator(self, cube):</span>

<div class="viewcode-block" id="UnstructuredNearest.regridder"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.UnstructuredNearest.regridder">[docs]</a>    <span class="k">def</span> <span class="nf">regridder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_cube</span><span class="p">,</span> <span class="n">target_grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a nearest-neighbour regridder, of the</span>
<span class="sd">        :class:`~iris.analysis.trajectory.UnstructuredNearestNeigbourRegridder`</span>
<span class="sd">        type, to perform regridding from the source grid to the target grid.</span>

<span class="sd">        This can then be applied to any source data with the same structure as</span>
<span class="sd">        the original &#39;src_cube&#39;.</span>

<span class="sd">        Typically you should use :meth:`iris.cube.Cube.regrid` for</span>
<span class="sd">        regridding a cube. There are, however, some situations when</span>
<span class="sd">        constructing your own regridder is preferable. These are detailed in</span>
<span class="sd">        the :ref:`user guide &lt;caching_a_regridder&gt;`.</span>

<span class="sd">        Does not support lazy regridding.</span>

<span class="sd">        Args:</span>

<span class="sd">        * src_cube:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the source grid.</span>
<span class="sd">            The X and Y coordinates can have any shape, but must be mapped over</span>
<span class="sd">            the same cube dimensions.</span>

<span class="sd">        * target_grid:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the target grid.</span>
<span class="sd">            The X and Y coordinates must be one-dimensional dimension</span>
<span class="sd">            coordinates, mapped to different dimensions.</span>
<span class="sd">            All other cube components are ignored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A callable with the interface:</span>

<span class="sd">                `callable(cube)`</span>

<span class="sd">            where `cube` is a cube with the same grid as `src_cube`</span>
<span class="sd">            that is to be regridded to the `target_grid`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">iris.analysis.trajectory</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">UnstructuredNearestNeigbourRegridder</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">UnstructuredNearestNeigbourRegridder</span><span class="p">(</span><span class="n">src_cube</span><span class="p">,</span> <span class="n">target_grid</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PointInCell"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.PointInCell">[docs]</a><span class="k">class</span> <span class="nc">PointInCell</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class describes the point-in-cell regridding scheme for use</span>
<span class="sd">    typically with :meth:`iris.cube.Cube.regrid()`.</span>

<span class="sd">    The PointInCell regridder can regrid data from a source grid of any</span>
<span class="sd">    dimensionality and in any coordinate system.</span>
<span class="sd">    The location of each source point is specified by X and Y coordinates</span>
<span class="sd">    mapped over the same cube dimensions, aka &quot;grid dimensions&quot; : the grid may</span>
<span class="sd">    have any dimensionality.  The X and Y coordinates must also have the same,</span>
<span class="sd">    defined coord_system.</span>
<span class="sd">    The weights, if specified, must have the same shape as the X and Y</span>
<span class="sd">    coordinates.</span>
<span class="sd">    The output grid can be any &#39;normal&#39; XY grid, specified by *separate* X</span>
<span class="sd">    and Y coordinates :  That is, X and Y have two different cube dimensions.</span>
<span class="sd">    The output X and Y coordinates must also have a common, specified</span>
<span class="sd">    coord_system.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Point-in-cell regridding scheme suitable for regridding over one</span>
<span class="sd">        or more orthogonal coordinates.</span>

<span class="sd">        Optional Args:</span>

<span class="sd">        * weights:</span>
<span class="sd">            A :class:`numpy.ndarray` instance that defines the weights</span>
<span class="sd">            for the grid cells of the source grid. Must have the same shape</span>
<span class="sd">            as the data of the source grid.</span>
<span class="sd">            If unspecified, equal weighting is assumed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>

<div class="viewcode-block" id="PointInCell.regridder"><a class="viewcode-back" href="../../generated/api/iris/analysis.html#iris.analysis.PointInCell.regridder">[docs]</a>    <span class="k">def</span> <span class="nf">regridder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_grid</span><span class="p">,</span> <span class="n">target_grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a point-in-cell regridder to perform regridding from the</span>
<span class="sd">        source grid to the target grid.</span>

<span class="sd">        Typically you should use :meth:`iris.cube.Cube.regrid` for</span>
<span class="sd">        regridding a cube. There are, however, some situations when</span>
<span class="sd">        constructing your own regridder is preferable. These are detailed in</span>
<span class="sd">        the :ref:`user guide &lt;caching_a_regridder&gt;`.</span>

<span class="sd">        Does not support lazy regridding.</span>

<span class="sd">        Args:</span>

<span class="sd">        * src_grid:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the source grid.</span>
<span class="sd">        * target_grid:</span>
<span class="sd">            The :class:`~iris.cube.Cube` defining the target grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A callable with the interface:</span>

<span class="sd">                `callable(cube)`</span>

<span class="sd">            where `cube` is a cube with the same grid as `src_grid`</span>
<span class="sd">            that is to be regridded to the `target_grid`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CurvilinearRegridder</span><span class="p">(</span><span class="n">src_grid</span><span class="p">,</span> <span class="n">target_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        
        &copy; <a href="../../copyright.html">Copyright</a> Iris Contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>