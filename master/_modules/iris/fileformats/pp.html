

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>iris.fileformats.pp &mdash; Iris 3.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/theme_override.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/iris-logo-title.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installing.html">Installing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/gallery/index.html">Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/iris_cubes.html">Iris data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/loading_iris_cubes.html">Loading Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/saving_iris_cubes.html">Saving Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/navigating_a_cube.html">Navigating a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/subsetting_a_cube.html">Subsetting a Cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/real_and_lazy_data.html">Real and Lazy Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/plotting_a_cube.html">Plotting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/interpolation_and_regridding.html">Cube interpolation and regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/merge_and_concat.html">Merge and concatenate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/cube_statistics.html">Cube statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/cube_maths.html">Basic cube mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/citation.html">Citing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/code_maintenance.html">Code maintenance</a></li>
</ul>
<p class="caption"><span class="caption-text">Developers Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/contributing_getting_involved.html">Getting Involved</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/gitwash/index.html">Working with <em>iris</em> source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/contributing_documentation.html">Contributing to the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/contributing_codebase_index.html">Contributing to the code base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/contributing_changes.html">Contributing your changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/release.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/api/iris.html">Iris API</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../whatsnew/index.html">Whatâ€™s new in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../techpapers/index.html">Iris Technical Papers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Iris copyright, licensing and contributors</a></li>
</ul>

            
          

    
    
    
        <p class="caption">
            <span class="caption-text">
            
                Support
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SciTools/iris"><i class="fa fa-github fa-fw"></i> Source Code</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris"><i class="fa fa-comments fa-fw"></i> Users Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris-dev"><i class="fa fa-comments fa-fw"></i> Developers Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://stackoverflow.com/questions/tagged/python-iris"><i class="fa fa-question fa-fw"></i> StackOverflow For "How do I?"</a></li>
            
                <li class="toctree-l1"><a href="https://scitools.org.uk/iris/docs/v2.4.0/index.html"><i class="fa fa-book fa-fw"></i> Legacy documentation</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Iris</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../iris.html">iris</a> &raquo;</li>
        
      <li>iris.fileformats.pp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for iris.fileformats.pp</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Iris contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Iris and is released under the LGPL license.</span>
<span class="c1"># See COPYING and COPYING.LESSER in the root of the repository for full</span>
<span class="c1"># licensing details.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Provides UK Met Office Post Process (PP) format specific capabilities.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">cf_units</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="kn">import</span> <span class="nn">cftime</span>

<span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

<span class="kn">from</span> <span class="nn">iris._lazy_data</span> <span class="kn">import</span> <span class="n">as_concrete_data</span><span class="p">,</span> <span class="n">as_lazy_data</span><span class="p">,</span> <span class="n">is_lazy_data</span>
<span class="kn">import</span> <span class="nn">iris.config</span>
<span class="kn">import</span> <span class="nn">iris.fileformats.pp_load_rules</span>
<span class="kn">from</span> <span class="nn">iris.fileformats.pp_save_rules</span> <span class="kn">import</span> <span class="n">verify</span>

<span class="c1"># NOTE: this is for backwards-compatitibility *ONLY*</span>
<span class="c1"># We could simply remove it for v2.0 ?</span>
<span class="kn">from</span> <span class="nn">iris.fileformats._pp_lbproc_pairs</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa</span>
    <span class="n">LBPROC_PAIRS</span><span class="p">,</span>
    <span class="n">LBPROC_MAP</span> <span class="k">as</span> <span class="n">lbproc_map</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">iris.fileformats.rules</span>
<span class="kn">import</span> <span class="nn">iris.coord_systems</span>
<span class="kn">from</span> <span class="nn">iris.util</span> <span class="kn">import</span> <span class="n">_array_slice_ifempty</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">mo_pack</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">mo_pack</span> <span class="o">=</span> <span class="kc">None</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;load&quot;</span><span class="p">,</span>
    <span class="s2">&quot;save&quot;</span><span class="p">,</span>
    <span class="s2">&quot;load_cubes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PPField&quot;</span><span class="p">,</span>
    <span class="s2">&quot;as_fields&quot;</span><span class="p">,</span>
    <span class="s2">&quot;load_pairs_from_fields&quot;</span><span class="p">,</span>
    <span class="s2">&quot;save_pairs_from_cube&quot;</span><span class="p">,</span>
    <span class="s2">&quot;save_fields&quot;</span><span class="p">,</span>
    <span class="s2">&quot;STASH&quot;</span><span class="p">,</span>
    <span class="s2">&quot;EARTH_RADIUS&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="n">EARTH_RADIUS</span> <span class="o">=</span> <span class="mf">6371229.0</span>


<span class="n">PP_HEADER_DEPTH</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">PP_WORD_DEPTH</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">NUM_LONG_HEADERS</span> <span class="o">=</span> <span class="mi">45</span>
<span class="n">NUM_FLOAT_HEADERS</span> <span class="o">=</span> <span class="mi">19</span>

<span class="c1"># The header definition for header release 2.</span>
<span class="c1">#: A list of (header_name, position_in_header(tuple of)) pairs for</span>
<span class="c1">#: header release 2 - using the one-based UM/FORTRAN indexing convention.</span>
<span class="n">UM_HEADER_2</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;lbyr&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbmon&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbdat&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbhr&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbmin&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbday&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbyrd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbmond&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbdatd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">9</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbhrd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbmind&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">11</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbdayd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">12</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbtim&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">13</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbft&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">14</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lblrec&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">15</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbcode&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">16</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbhem&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">17</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbrow&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">18</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbnpt&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">19</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbext&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbpack&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">21</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbrel&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">22</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbfc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">23</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbcfc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">24</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbproc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">25</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbvc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">26</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbrvc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">27</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbexp&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">28</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbegin&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">29</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbnrec&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">30</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbproj&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">31</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbtyp&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">32</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lblev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">33</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbrsvd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">34</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">37</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;lbsrce&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">38</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbuser&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">39</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">45</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;brsvd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">46</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">49</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;bdatum&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bacc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">51</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;blev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">52</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;brlev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">53</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bhlev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">54</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bhrlev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">55</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bplat&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">56</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bplon&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">57</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bgor&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">58</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bzy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">59</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bdy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">60</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bzx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">61</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bdx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">62</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bmdi&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">63</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bmks&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">64</span><span class="p">,)),</span>
<span class="p">]</span>

<span class="c1"># The header definition for header release 3.</span>
<span class="c1">#: A list of (header_name, position_in_header(tuple of)) pairs for</span>
<span class="c1">#: header release 3 - using the one-based UM/FORTRAN indexing convention.</span>
<span class="n">UM_HEADER_3</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;lbyr&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbmon&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbdat&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbhr&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbmin&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbsec&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbyrd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbmond&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbdatd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">9</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbhrd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbmind&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">11</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbsecd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">12</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbtim&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">13</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbft&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">14</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lblrec&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">15</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbcode&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">16</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbhem&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">17</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbrow&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">18</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbnpt&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">19</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbext&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbpack&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">21</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbrel&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">22</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbfc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">23</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbcfc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">24</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbproc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">25</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbvc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">26</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbrvc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">27</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbexp&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">28</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbegin&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">29</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbnrec&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">30</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbproj&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">31</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbtyp&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">32</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lblev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">33</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbrsvd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">34</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">37</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;lbsrce&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">38</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;lbuser&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">39</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">45</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;brsvd&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">46</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">49</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;bdatum&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bacc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">51</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;blev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">52</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;brlev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">53</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bhlev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">54</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bhrlev&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">55</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bplat&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">56</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bplon&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">57</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bgor&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">58</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bzy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">59</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bdy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">60</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bzx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">61</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bdx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">62</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bmdi&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">63</span><span class="p">,)),</span>
    <span class="p">(</span><span class="s2">&quot;bmks&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">64</span><span class="p">,)),</span>
<span class="p">]</span>

<span class="c1"># A map from header-release-number to header definition</span>
<span class="n">UM_HEADERS</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">UM_HEADER_2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">UM_HEADER_3</span><span class="p">}</span>

<span class="c1"># Offset value to convert from UM_HEADER positions to PP_HEADER offsets.</span>
<span class="n">UM_TO_PP_HEADER_OFFSET</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1">#: A dictionary mapping IB values to their names.</span>
<span class="n">EXTRA_DATA</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;lower_y_domain&quot;</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;lower_x_domain&quot;</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;upper_y_domain&quot;</span><span class="p">,</span>
    <span class="mi">6</span><span class="p">:</span> <span class="s2">&quot;upper_x_domain&quot;</span><span class="p">,</span>
    <span class="mi">7</span><span class="p">:</span> <span class="s2">&quot;lower_z_domain&quot;</span><span class="p">,</span>
    <span class="mi">8</span><span class="p">:</span> <span class="s2">&quot;upper_z_domain&quot;</span><span class="p">,</span>
    <span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;field_title&quot;</span><span class="p">,</span>
    <span class="mi">11</span><span class="p">:</span> <span class="s2">&quot;domain_title&quot;</span><span class="p">,</span>
    <span class="mi">12</span><span class="p">:</span> <span class="s2">&quot;x_lower_bound&quot;</span><span class="p">,</span>
    <span class="mi">13</span><span class="p">:</span> <span class="s2">&quot;x_upper_bound&quot;</span><span class="p">,</span>
    <span class="mi">14</span><span class="p">:</span> <span class="s2">&quot;y_lower_bound&quot;</span><span class="p">,</span>
    <span class="mi">15</span><span class="p">:</span> <span class="s2">&quot;y_upper_bound&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="c1">#: Maps lbuser[0] to numpy data type. &quot;default&quot; will be interpreted if</span>
<span class="c1">#: no match is found, providing a warning in such a case.</span>
<span class="n">LBUSER_DTYPE_LOOKUP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;f4&quot;</span><span class="p">),</span>
    <span class="mi">2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;i4&quot;</span><span class="p">),</span>
    <span class="mi">3</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;i4&quot;</span><span class="p">),</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;f4&quot;</span><span class="p">),</span>
    <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;i4&quot;</span><span class="p">),</span>
    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;i4&quot;</span><span class="p">),</span>
    <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;f4&quot;</span><span class="p">),</span>
<span class="p">}</span>


<div class="viewcode-block" id="STASH"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.STASH">[docs]</a><span class="k">class</span> <span class="nc">STASH</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;STASH&quot;</span><span class="p">,</span> <span class="s2">&quot;model section item&quot;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to hold a single STASH code.</span>

<span class="sd">    Create instances using:</span>
<span class="sd">        &gt;&gt;&gt; model = 1</span>
<span class="sd">        &gt;&gt;&gt; section = 2</span>
<span class="sd">        &gt;&gt;&gt; item = 3</span>
<span class="sd">        &gt;&gt;&gt; my_stash = iris.fileformats.pp.STASH(model, section, item)</span>

<span class="sd">    Access the sub-components via:</span>
<span class="sd">        &gt;&gt;&gt; my_stash.model</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; my_stash.section</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; my_stash.item</span>
<span class="sd">        3</span>

<span class="sd">    String conversion results in the MSI format:</span>
<span class="sd">        &gt;&gt;&gt; print(iris.fileformats.pp.STASH(1, 16, 203))</span>
<span class="sd">        m01s16i203</span>

<span class="sd">    A stash object can be compared directly</span>
<span class="sd">    to its string representation:</span>
<span class="sd">    &gt;&gt;&gt; iris.fileformats.pp.STASH(1, 0, 4) == &#39;m01s0i004&#39;</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

<div class="viewcode-block" id="STASH.__new__"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.STASH.__new__">[docs]</a>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>

<span class="sd">        * model</span>
<span class="sd">            A positive integer less than 100, or None.</span>
<span class="sd">        * section</span>
<span class="sd">            A non-negative integer less than 100, or None.</span>
<span class="sd">        * item</span>
<span class="sd">            A positive integer less than 1000, or None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_validate_member</span><span class="p">(</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
        <span class="n">section</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_validate_member</span><span class="p">(</span><span class="s2">&quot;section&quot;</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_validate_member</span><span class="p">(</span><span class="s2">&quot;item&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">999</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span></div>

<div class="viewcode-block" id="STASH.from_msi"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.STASH.from_msi">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_msi</span><span class="p">(</span><span class="n">msi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a STASH code MSI string to a STASH instance.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msi</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected STASH code MSI string, got </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msi</span><span class="p">,))</span>

        <span class="n">msi_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;^\s*m(\d+|\?+)s(\d+|\?+)i(\d+|\?+)\s*$&quot;</span><span class="p">,</span> <span class="n">msi</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">msi_match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Expected STASH code MSI string &quot;mXXsXXiXXX&quot;, &#39;</span>
                <span class="s2">&quot;got </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msi</span><span class="p">,)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">STASH</span><span class="p">(</span><span class="o">*</span><span class="n">msi_match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_member</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">,</span> <span class="n">upper_limit</span><span class="p">):</span>
        <span class="c1"># Returns a valid integer or None.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lower_limit</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">upper_limit</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_member</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_member</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_member</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;m</span><span class="si">{}</span><span class="s2">s</span><span class="si">{}</span><span class="s2">i</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">num_digits</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;?&quot;</span> <span class="o">*</span> <span class="n">num_digits</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">format_spec</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_digits</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="STASH.lbuser3"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.STASH.lbuser3">[docs]</a>    <span class="k">def</span> <span class="nf">lbuser3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the lbuser[3] value that this stash represents.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="STASH.lbuser6"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.STASH.lbuser6">[docs]</a>    <span class="k">def</span> <span class="nf">lbuser6</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the lbuser[6] value that this stash represents.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="ow">or</span> <span class="mi">0</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;?&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">STASH</span><span class="o">.</span><span class="n">from_msi</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">SplittableInt</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to hold integers which can easily get each decimal digit</span>
<span class="sd">    individually.</span>

<span class="sd">    &gt;&gt;&gt; three_six_two = SplittableInt(362)</span>
<span class="sd">    &gt;&gt;&gt; print(three_six_two)</span>
<span class="sd">    362</span>
<span class="sd">    &gt;&gt;&gt; print(three_six_two[0])</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; print(three_six_two[2])</span>
<span class="sd">    3</span>

<span class="sd">    .. note:: No support for negative numbers</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">name_mapping_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a SplittableInt given the positive integer value provided.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * name_mapping_dict - (dict)</span>
<span class="sd">            A special mapping to provide name based access to specific integer</span>
<span class="sd">            positions:</span>

<span class="sd">                &gt;&gt;&gt; a = SplittableInt(1234, {&#39;hundreds&#39;: 2})</span>
<span class="sd">                &gt;&gt;&gt; print(a.hundreds)</span>
<span class="sd">                2</span>
<span class="sd">                &gt;&gt;&gt; a.hundreds = 9</span>
<span class="sd">                &gt;&gt;&gt; print(a.hundreds)</span>
<span class="sd">                9</span>
<span class="sd">                &gt;&gt;&gt; print(a)</span>
<span class="sd">                1934</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Negative numbers not supported with splittable&quot;</span>
                <span class="s2">&quot; integers object&quot;</span>
            <span class="p">)</span>

        <span class="c1"># define the name lookup first (as this is the way __setattr__ is</span>
        <span class="c1"># plumbed)</span>
        <span class="c1">#: A dictionary mapping special attribute names on this object</span>
        <span class="c1">#: to the slices/indices required to access them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_lookup</span> <span class="o">=</span> <span class="n">name_mapping_dict</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_str_value_from_value</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_str_value_from_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Reverse the string to get the appropriate index when getting the</span>
        <span class="c1"># sliced value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strvalue</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># Associate the names in the lookup table to attributes</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_calculate_value_from_str_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">10</span> <span class="o">**</span> <span class="n">i</span> <span class="o">*</span> <span class="n">val</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strvalue</span><span class="p">)]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strvalue</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strvalue</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># if the key returns a list of values, then combine them together</span>
        <span class="c1"># to an integer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">10</span> <span class="o">**</span> <span class="n">i</span> <span class="o">*</span> <span class="n">val</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># The setitem method has been overridden so that assignment using</span>
        <span class="c1"># ``val[0] = 1`` style syntax updates</span>
        <span class="c1"># the entire object appropriately.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can only set </span><span class="si">%s</span><span class="s2"> as a positive integer value.&quot;</span> <span class="o">%</span> <span class="n">key</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot assign a value with slice objects&quot;</span>
                    <span class="s2">&quot; containing negative indices.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># calculate the current length of the value of this string</span>
            <span class="n">current_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))))</span>

            <span class="c1"># get indices for as many digits as have been requested. Putting</span>
            <span class="c1"># the upper limit on the number of digits at 100.</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot put </span><span class="si">%s</span><span class="s2"> into </span><span class="si">%s</span><span class="s2"> as it has too many&quot;</span>
                    <span class="s2">&quot; digits.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Iterate over each of the indices in the slice,</span>
            <span class="c1"># zipping them together with the associated digit</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">digit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">indices</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">current_length</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="c1"># assign each digit to the associated index</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">digit</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we are trying to set to an index which does not currently</span>
            <span class="c1"># exist in _strvalue then extend it to the</span>
            <span class="c1"># appropriate length</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">new_str_value</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">new_str_value</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strvalue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_strvalue</span> <span class="o">=</span> <span class="n">new_str_value</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_strvalue</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_lookup</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_value_from_str_value</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># if the attribute is a special value, update the index value which</span>
        <span class="c1"># will in turn update the attribute value</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;_name_lookup&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_lookup</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name_lookup</span><span class="p">[</span><span class="n">name</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;SplittableInt(</span><span class="si">%r</span><span class="s2">, name_mapping_dict=</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name_lookup</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SplittableInt</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SplittableInt</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PPDataProxy</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A reference to the data payload of a single PP field.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;shape&quot;</span><span class="p">,</span>
        <span class="s2">&quot;src_dtype&quot;</span><span class="p">,</span>
        <span class="s2">&quot;path&quot;</span><span class="p">,</span>
        <span class="s2">&quot;offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;data_len&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lbpack&quot;</span><span class="p">,</span>
        <span class="s2">&quot;boundary_packing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mdi&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">src_dtype</span><span class="p">,</span>
        <span class="n">path</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">,</span>
        <span class="n">data_len</span><span class="p">,</span>
        <span class="n">lbpack</span><span class="p">,</span>
        <span class="n">boundary_packing</span><span class="p">,</span>
        <span class="n">mdi</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_dtype</span> <span class="o">=</span> <span class="n">src_dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">data_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbpack</span> <span class="o">=</span> <span class="n">lbpack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_packing</span> <span class="o">=</span> <span class="n">boundary_packing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdi</span> <span class="o">=</span> <span class="n">mdi</span>

    <span class="c1"># lbpack</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lbpack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lbpack</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lbpack</span><span class="p">,</span> <span class="n">SplittableInt</span><span class="p">):</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">n5</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">n4</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n3</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">SplittableInt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lbpack</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@lbpack</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lbpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lbpack</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="c1"># Check for &#39;empty&#39; slicings, in which case don&#39;t fetch the data.</span>
        <span class="c1"># Because, since Dask v2, &#39;dask.array.from_array&#39; performs an empty</span>
        <span class="c1"># slicing and we must not fetch the data at that time.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_array_slice_ifempty</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pp_file</span><span class="p">:</span>
                <span class="n">pp_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span>
                <span class="n">data_bytes</span> <span class="o">=</span> <span class="n">pp_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_len</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_data_bytes_to_shaped_array</span><span class="p">(</span>
                    <span class="n">data_bytes</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lbpack</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">boundary_packing</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">src_dtype</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mdi</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;&lt;</span><span class="si">{self.__class__.__name__}</span><span class="s2"> shape=</span><span class="si">{self.shape}</span><span class="s2">&quot;</span>
            <span class="s2">&quot; src_dtype=</span><span class="si">{self.dtype!r}</span><span class="s2"> path=</span><span class="si">{self.path!r}</span><span class="s2">&quot;</span>
            <span class="s2">&quot; offset=</span><span class="si">{self.offset}</span><span class="s2">&gt;&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Because we have __slots__, this is needed to support Pickle.dump()</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Because we have __slots__, this is needed to support Pickle.load()</span>
        <span class="c1"># (Use setattr, as there is no object dictionary.)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PPDataProxy</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_data_bytes_to_shaped_array</span><span class="p">(</span>
    <span class="n">data_bytes</span><span class="p">,</span> <span class="n">lbpack</span><span class="p">,</span> <span class="n">boundary_packing</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">mdi</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the already read binary data payload into a numpy array, unpacking</span>
<span class="sd">    and decompressing as per the F3 specification.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lbpack</span><span class="o">.</span><span class="n">n1</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">data_bytes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">lbpack</span><span class="o">.</span><span class="n">n1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mo_pack</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">decompress_wgdos</span> <span class="o">=</span> <span class="n">mo_pack</span><span class="o">.</span><span class="n">decompress_wgdos</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">decompress_wgdos</span> <span class="o">=</span> <span class="n">mo_pack</span><span class="o">.</span><span class="n">unpack_wgdos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Unpacking PP fields with LBPACK of </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;requires mo_pack to be installed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lbpack</span><span class="o">.</span><span class="n">n1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">decompress_wgdos</span><span class="p">(</span><span class="n">data_bytes</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mdi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">lbpack</span><span class="o">.</span><span class="n">n1</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mo_pack</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mo_pack</span><span class="p">,</span> <span class="s2">&quot;decompress_rle&quot;</span><span class="p">):</span>
            <span class="n">decompress_rle</span> <span class="o">=</span> <span class="n">mo_pack</span><span class="o">.</span><span class="n">decompress_rle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Unpacking PP fields with LBPACK of </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;requires mo_pack to be installed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lbpack</span><span class="o">.</span><span class="n">n1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">decompress_rle</span><span class="p">(</span><span class="n">data_bytes</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mdi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">NotYetImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;PP fields with LBPACK of </span><span class="si">%s</span><span class="s2"> are not yet supported.&quot;</span> <span class="o">%</span> <span class="n">lbpack</span>
        <span class="p">)</span>

    <span class="c1"># Ensure we have a writeable data buffer.</span>
    <span class="c1"># NOTE: &quot;data.setflags(write=True)&quot; is not valid for numpy &gt;= 1.16.0.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;WRITEABLE&quot;</span><span class="p">]:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Ensure the data is in the native byte order</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">isnative</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">boundary_packing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Convert a long string of numbers into a &quot;lateral boundary</span>
        <span class="c1"># condition&quot; array, which is split into 4 quartiles, North</span>
        <span class="c1"># East, South, West and where North and South contain the corners.</span>
        <span class="n">compressed_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">data_shape</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">mdi</span>

        <span class="n">boundary_height</span> <span class="o">=</span> <span class="n">boundary_packing</span><span class="o">.</span><span class="n">y_halo</span> <span class="o">+</span> <span class="n">boundary_packing</span><span class="o">.</span><span class="n">rim_width</span>
        <span class="n">boundary_width</span> <span class="o">=</span> <span class="n">boundary_packing</span><span class="o">.</span><span class="n">x_halo</span> <span class="o">+</span> <span class="n">boundary_packing</span><span class="o">.</span><span class="n">rim_width</span>
        <span class="n">y_height</span><span class="p">,</span> <span class="n">x_width</span> <span class="o">=</span> <span class="n">data_shape</span>
        <span class="c1"># The height of the east and west components.</span>
        <span class="n">mid_height</span> <span class="o">=</span> <span class="n">y_height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">boundary_height</span>

        <span class="n">n_s_shape</span> <span class="o">=</span> <span class="n">boundary_height</span><span class="p">,</span> <span class="n">x_width</span>
        <span class="n">e_w_shape</span> <span class="o">=</span> <span class="n">mid_height</span><span class="p">,</span> <span class="n">boundary_width</span>

        <span class="c1"># Keep track of our current position in the array.</span>
        <span class="n">current_posn</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">north</span> <span class="o">=</span> <span class="n">compressed_data</span><span class="p">[:</span> <span class="n">boundary_height</span> <span class="o">*</span> <span class="n">x_width</span><span class="p">]</span>
        <span class="n">current_posn</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">north</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">boundary_height</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">north</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">n_s_shape</span><span class="p">)</span>

        <span class="n">east</span> <span class="o">=</span> <span class="n">compressed_data</span><span class="p">[</span>
            <span class="n">current_posn</span> <span class="p">:</span> <span class="n">current_posn</span> <span class="o">+</span> <span class="n">boundary_width</span> <span class="o">*</span> <span class="n">mid_height</span>
        <span class="p">]</span>
        <span class="n">current_posn</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">east</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span>
            <span class="n">boundary_height</span><span class="p">:</span><span class="o">-</span><span class="n">boundary_height</span><span class="p">,</span> <span class="o">-</span><span class="n">boundary_width</span><span class="p">:</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">east</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">e_w_shape</span><span class="p">)</span>

        <span class="n">south</span> <span class="o">=</span> <span class="n">compressed_data</span><span class="p">[</span>
            <span class="n">current_posn</span> <span class="p">:</span> <span class="n">current_posn</span> <span class="o">+</span> <span class="n">boundary_height</span> <span class="o">*</span> <span class="n">x_width</span>
        <span class="p">]</span>
        <span class="n">current_posn</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">south</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[:</span><span class="n">boundary_height</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">south</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">n_s_shape</span><span class="p">)</span>

        <span class="n">west</span> <span class="o">=</span> <span class="n">compressed_data</span><span class="p">[</span>
            <span class="n">current_posn</span> <span class="p">:</span> <span class="n">current_posn</span> <span class="o">+</span> <span class="n">boundary_width</span> <span class="o">*</span> <span class="n">mid_height</span>
        <span class="p">]</span>
        <span class="n">current_posn</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">west</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">boundary_height</span><span class="p">:</span><span class="o">-</span><span class="n">boundary_height</span><span class="p">,</span> <span class="p">:</span><span class="n">boundary_width</span><span class="p">]</span> <span class="o">=</span> <span class="n">west</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="o">*</span><span class="n">e_w_shape</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">lbpack</span><span class="o">.</span><span class="n">n2</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If we are given no mask to apply, then just return raw data, even</span>
            <span class="c1"># though it does not have the correct shape.</span>
            <span class="c1"># For dask-delayed loading, this means that mask, data and the</span>
            <span class="c1"># combination can be properly handled within a dask graph.</span>
            <span class="c1"># However, we still mask any MDI values in the array (below).</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">land_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">sea_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">land_mask</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">land_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">mdi</span>
            <span class="k">if</span> <span class="n">lbpack</span><span class="o">.</span><span class="n">n3</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Land mask packed data.</span>
                <span class="c1"># Sometimes the data comes in longer than it should be (i.e. it</span>
                <span class="c1"># looks like the compressed data is compressed, but the</span>
                <span class="c1"># trailing data hasn&#39;t been clipped off!).</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">land_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span> <span class="n">land_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span>
            <span class="k">elif</span> <span class="n">lbpack</span><span class="o">.</span><span class="n">n3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Sea mask packed data.</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">sea_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span> <span class="n">sea_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported mask compression.&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Reform in row-column order</span>
        <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data_shape</span>

    <span class="c1"># Mask the array</span>
    <span class="k">if</span> <span class="n">mdi</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_values</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mdi</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="c1"># The special headers of the PPField classes which get some improved</span>
<span class="c1"># functionality</span>
<span class="n">_SPECIAL_HEADERS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;lbtim&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lbcode&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lbpack&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lbproc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;data&quot;</span><span class="p">,</span>
    <span class="s2">&quot;stash&quot;</span><span class="p">,</span>
    <span class="s2">&quot;t1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;t2&quot;</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_header_defn</span><span class="p">(</span><span class="n">release_number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the zero-indexed header definition for a particular release of</span>
<span class="sd">    a PPField.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">um_header</span> <span class="o">=</span> <span class="n">UM_HEADERS</span><span class="p">[</span><span class="n">release_number</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">UM_TO_PP_HEADER_OFFSET</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">positions</span> <span class="ow">in</span> <span class="n">um_header</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_pp_attribute_names</span><span class="p">(</span><span class="n">header_defn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the allowed attributes of a PPField:</span>
<span class="sd">        all of the normal headers (i.e. not the _SPECIAL_HEADERS),</span>
<span class="sd">        the _SPECIAL_HEADERS with &#39;_&#39; prefixed,</span>
<span class="sd">        the possible extra data headers.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal_headers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">positions</span> <span class="ow">in</span> <span class="n">header_defn</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_SPECIAL_HEADERS</span>
    <span class="p">)</span>
    <span class="n">special_headers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_SPECIAL_HEADERS</span><span class="p">)</span>
    <span class="n">extra_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">EXTRA_DATA</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">special_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_raw_header&quot;</span><span class="p">,</span>
        <span class="s2">&quot;raw_lbtim&quot;</span><span class="p">,</span>
        <span class="s2">&quot;raw_lbpack&quot;</span><span class="p">,</span>
        <span class="s2">&quot;boundary_packing&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_index_in_structured_load_file&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">normal_headers</span> <span class="o">+</span> <span class="n">special_headers</span> <span class="o">+</span> <span class="n">extra_data</span> <span class="o">+</span> <span class="n">special_attributes</span>


<div class="viewcode-block" id="PPField"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.PPField">[docs]</a><span class="k">class</span> <span class="nc">PPField</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic class for PP fields - not specific to a particular</span>
<span class="sd">    header release number.</span>

<span class="sd">    A PPField instance can easily access the PP header &quot;words&quot; as attributes</span>
<span class="sd">    with some added useful capabilities::</span>

<span class="sd">        for field in iris.fileformats.pp.load(filename):</span>
<span class="sd">            print(field.lbyr)</span>
<span class="sd">            print(field.lbuser)</span>
<span class="sd">            print(field.lbuser[0])</span>
<span class="sd">            print(field.lbtim)</span>
<span class="sd">            print(field.lbtim.ia)</span>
<span class="sd">            print(field.t1)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># NB. Subclasses must define the attribute HEADER_DEFN to be their</span>
    <span class="c1"># zero-based header definition. See PPField2 and PPField3 for examples.</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Combined header longs and floats data cache.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_lbtim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_lbpack</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_packing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_in_structured_load_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_lbtim</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;lbtim&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_lbpack</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;lbpack&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

<div class="viewcode-block" id="PPField.__getattr__"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.PPField.__getattr__">[docs]</a>    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method supports deferred attribute creation, which offers a</span>
<span class="sd">        significant loading optimisation, particularly when not all attributes</span>
<span class="sd">        are referenced and therefore created on the instance.</span>

<span class="sd">        When an &#39;ordinary&#39; HEADER_DICT attribute is required, its associated</span>
<span class="sd">        header offset is used to lookup the data value/s from the combined</span>
<span class="sd">        header longs and floats data cache. The attribute is then set with this</span>
<span class="sd">        value/s on the instance. Thus future lookups for this attribute will be</span>
<span class="sd">        optimised, avoiding the __getattr__ lookup mechanism again.</span>

<span class="sd">        When a &#39;special&#39; HEADER_DICT attribute (leading underscore) is</span>
<span class="sd">        required, its associated &#39;ordinary&#39; (no leading underscore) header</span>
<span class="sd">        offset is used to lookup the data value/s from the combined header</span>
<span class="sd">        longs and floats data cache. The &#39;ordinary&#39; attribute is then set</span>
<span class="sd">        with this value/s on the instance. This is required as &#39;special&#39;</span>
<span class="sd">        attributes have supporting property convenience functionality base on</span>
<span class="sd">        the attribute value e.g. see &#39;lbpack&#39; and &#39;lbtim&#39;. Note that, for</span>
<span class="sd">        &#39;special&#39; attributes the interface is via the &#39;ordinary&#39; attribute but</span>
<span class="sd">        the underlying attribute value is stored within the &#39;special&#39;</span>
<span class="sd">        attribute.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;_&quot;</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">:</span>
                <span class="c1"># Must be a special attribute.</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> object has no attribute </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_header</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_header</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">])</span>

        <span class="c1"># Now cache the attribute value on the instance.</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;_&quot;</span><span class="p">:</span>
            <span class="c1"># First we need to assign to the attribute so that the</span>
            <span class="c1"># special attribute is calculated, then we retrieve it.</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">t1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">t2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="PPField.__repr__"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.PPField.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string representation of the PP field.&quot;&quot;&quot;</span>

        <span class="c1"># Define an ordering on the basic header names</span>
        <span class="n">attribute_priority_lookup</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DEFN</span>
        <span class="p">}</span>

        <span class="c1"># With the attributes sorted the order will remain stable if extra</span>
        <span class="c1"># attributes are added.</span>
        <span class="n">public_attribute_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attribute_priority_lookup</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">EXTRA_DATA</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">self_attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">public_attribute_names</span>
        <span class="p">]</span>
        <span class="n">self_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">self_attrs</span> <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">self_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

        <span class="c1"># sort the attributes by position in the pp header followed,</span>
        <span class="c1"># then by alphabetical order.</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">self_attrs</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">attribute_priority_lookup</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">999</span><span class="p">),</span>
                <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;PP Field&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">   </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">])</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A stash property giving access to the associated STASH object,</span>
<span class="sd">        now supporting __eq__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_stash&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stash</span><span class="o">.</span><span class="n">lbuser6</span><span class="p">()</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stash</span><span class="o">.</span><span class="n">lbuser3</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stash</span> <span class="o">=</span> <span class="n">STASH</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">//</span> <span class="mi">1000</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1000</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stash</span>

    <span class="nd">@stash</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">stash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stash</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stash</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stash</span> <span class="o">=</span> <span class="n">STASH</span><span class="o">.</span><span class="n">from_msi</span><span class="p">(</span><span class="n">stash</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stash</span><span class="p">,</span> <span class="n">STASH</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stash</span> <span class="o">=</span> <span class="n">stash</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set stash to </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stash</span><span class="p">))</span>

        <span class="c1"># Keep the lbuser up to date.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stash</span><span class="o">.</span><span class="n">lbuser6</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stash</span><span class="o">.</span><span class="n">lbuser3</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lbtim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lbtim</span>

    <span class="nd">@lbtim</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lbtim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_lbtim</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lbtim</span> <span class="o">=</span> <span class="n">SplittableInt</span><span class="p">(</span>
            <span class="n">value</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;ia&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;ib&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;ic&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="c1"># lbcode</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lbcode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lbcode</span>

    <span class="nd">@lbcode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lbcode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="n">SplittableInt</span><span class="p">):</span>
            <span class="c1"># add the ix/iy values for lbcode</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">SplittableInt</span><span class="p">(</span>
                <span class="n">new_value</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;iy&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;ix&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lbcode</span> <span class="o">=</span> <span class="n">new_value</span>

    <span class="c1"># lbpack</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lbpack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lbpack</span>

    <span class="nd">@lbpack</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lbpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="n">SplittableInt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_lbpack</span> <span class="o">=</span> <span class="n">new_value</span>
            <span class="c1"># add the n1/n2/n3/n4/n5 values for lbpack</span>
            <span class="n">name_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">n5</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">n4</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n3</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n1</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">SplittableInt</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="n">name_mapping</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_lbpack</span> <span class="o">=</span> <span class="n">new_value</span><span class="o">.</span><span class="n">_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lbpack</span> <span class="o">=</span> <span class="n">new_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lbproc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lbproc</span>

    <span class="nd">@lbproc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lbproc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PPField.lbproc cannot be a negative number.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lbproc</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`numpy.ndarray` representing the multidimensional data</span>
<span class="sd">        of the pp file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_lazy_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
            <span class="c1"># Replace with real data on the first access.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">as_concrete_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="PPField.core_data"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.PPField.core_data">[docs]</a>    <span class="k">def</span> <span class="nf">core_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">calendar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the calendar of the field.&quot;&quot;&quot;</span>
        <span class="c1"># TODO #577 What calendar to return when ibtim.ic in [0, 3]</span>
        <span class="n">calendar</span> <span class="o">=</span> <span class="n">cf_units</span><span class="o">.</span><span class="n">CALENDAR_GREGORIAN</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbtim</span><span class="o">.</span><span class="n">ic</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">calendar</span> <span class="o">=</span> <span class="n">cf_units</span><span class="o">.</span><span class="n">CALENDAR_360_DAY</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbtim</span><span class="o">.</span><span class="n">ic</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">calendar</span> <span class="o">=</span> <span class="n">cf_units</span><span class="o">.</span><span class="n">CALENDAR_365_DAY</span>
        <span class="k">return</span> <span class="n">calendar</span>

    <span class="k">def</span> <span class="nf">_read_extra_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pp_file</span><span class="p">,</span> <span class="n">file_reader</span><span class="p">,</span> <span class="n">extra_len</span><span class="p">,</span> <span class="n">little_ended</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the extra data section and update the self appropriately.&quot;&quot;&quot;</span>

        <span class="n">dtype_endian_char</span> <span class="o">=</span> <span class="s2">&quot;&lt;&quot;</span> <span class="k">if</span> <span class="n">little_ended</span> <span class="k">else</span> <span class="s2">&quot;&gt;&quot;</span>
        <span class="c1"># While there is still extra data to decode run this loop</span>
        <span class="k">while</span> <span class="n">extra_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%c</span><span class="s2">L&quot;</span> <span class="o">%</span> <span class="n">dtype_endian_char</span>
            <span class="n">extra_int_code</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span>
                <span class="n">dtype</span><span class="p">,</span> <span class="n">file_reader</span><span class="p">(</span><span class="n">PP_WORD_DEPTH</span><span class="p">)</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">extra_len</span> <span class="o">-=</span> <span class="n">PP_WORD_DEPTH</span>

            <span class="n">ib</span> <span class="o">=</span> <span class="n">extra_int_code</span> <span class="o">%</span> <span class="mi">1000</span>
            <span class="n">ia</span> <span class="o">=</span> <span class="n">extra_int_code</span> <span class="o">//</span> <span class="mi">1000</span>

            <span class="n">data_len</span> <span class="o">=</span> <span class="n">ia</span> <span class="o">*</span> <span class="n">PP_WORD_DEPTH</span>

            <span class="k">if</span> <span class="n">ib</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%c%d</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtype_endian_char</span><span class="p">,</span> <span class="n">data_len</span><span class="p">)</span>
                <span class="n">field_title</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">file_reader</span><span class="p">(</span><span class="n">data_len</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">field_title</span> <span class="o">=</span> <span class="n">field_title</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\00</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">ib</span> <span class="o">==</span> <span class="mi">11</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%c%d</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtype_endian_char</span><span class="p">,</span> <span class="n">data_len</span><span class="p">)</span>
                <span class="n">domain_title</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">file_reader</span><span class="p">(</span><span class="n">data_len</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">domain_title</span> <span class="o">=</span> <span class="n">domain_title</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\00</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">ib</span> <span class="ow">in</span> <span class="n">EXTRA_DATA</span><span class="p">:</span>
                <span class="n">attr_name</span> <span class="o">=</span> <span class="n">EXTRA_DATA</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%c</span><span class="s2">f</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtype_endian_char</span><span class="p">,</span> <span class="n">PP_WORD_DEPTH</span><span class="p">))</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">pp_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">ia</span><span class="p">)</span>
                <span class="c1"># Ensure the values are in the native byte order</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">isnative</span><span class="p">:</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown IB value for extra data: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ib</span><span class="p">)</span>

            <span class="n">extra_len</span> <span class="o">-=</span> <span class="n">data_len</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;x_lower_bound&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;x_upper_bound&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x_lower_bound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_upper_bound</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;y_lower_bound&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;y_upper_bound&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y_lower_bound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_upper_bound</span><span class="p">))</span>

<div class="viewcode-block" id="PPField.save"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.PPField.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the PPField to the given file object</span>
<span class="sd">        (typically created with :func:`open`).</span>

<span class="sd">        ::</span>

<span class="sd">            # to append the field to a file</span>
<span class="sd">            with open(filename, &#39;ab&#39;) as fh:</span>
<span class="sd">                a_pp_field.save(fh)</span>

<span class="sd">            # to overwrite/create a file</span>
<span class="sd">            with open(filename, &#39;wb&#39;) as fh:</span>
<span class="sd">                a_pp_field.save(fh)</span>


<span class="sd">        .. note::</span>

<span class="sd">            The fields which are automatically calculated are: &#39;lbext&#39;,</span>
<span class="sd">            &#39;lblrec&#39; and &#39;lbuser[0]&#39;. Some fields are not currently</span>
<span class="sd">            populated, these are: &#39;lbegin&#39;, &#39;lbnrec&#39;, &#39;lbuser[1]&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the actual data content.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">mdi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bmdi</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="n">mdi</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;PPField data contains unmasked points equal to the fill &quot;</span>
                <span class="s2">&quot;value, </span><span class="si">{}</span><span class="s2">. As saved, these points will read back as &quot;</span>
                <span class="s2">&quot;missing data. To save these as normal values, please &quot;</span>
                <span class="s2">&quot;set the field BMDI not equal to any valid data points.&quot;</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mdi</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="n">mdi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Make sure the data is big-endian</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="c1"># take a copy of the data when byteswapping</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

        <span class="c1"># Create the arrays which will hold the header information</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">NUM_LONG_HEADERS</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;u</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">PP_WORD_DEPTH</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">NUM_FLOAT_HEADERS</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;f</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">PP_WORD_DEPTH</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Fill in the header elements from the PPField</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DEFN</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">header_elem</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;PPField.save() could not find </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">NUM_LONG_HEADERS</span> <span class="o">-</span> <span class="n">UM_TO_PP_HEADER_OFFSET</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header_elem</span><span class="p">,</span> <span class="n">SplittableInt</span><span class="p">):</span>
                    <span class="n">header_elem</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header_elem</span><span class="p">)</span>
                <span class="n">lb</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">header_elem</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                    <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">NUM_LONG_HEADERS</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">NUM_LONG_HEADERS</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">b</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">header_elem</span>

        <span class="c1"># Although all of the elements are now populated, we still need to</span>
        <span class="c1"># update some of the elements in case</span>
        <span class="c1"># things have changed (for example, the data length etc.)</span>

        <span class="c1"># Set up a variable to represent the datalength of this PPField in</span>
        <span class="c1"># WORDS.</span>
        <span class="n">len_of_data_payload</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># set up a list to hold the extra data which will need to be encoded</span>
        <span class="c1"># at the end of the data</span>
        <span class="n">extra_items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># iterate through all of the possible extra data fields</span>
        <span class="k">for</span> <span class="n">ib</span><span class="p">,</span> <span class="n">extra_data_attr_name</span> <span class="ow">in</span> <span class="n">EXTRA_DATA</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># try to get the extra data field, returning None if it doesn&#39;t</span>
            <span class="c1"># exist</span>
            <span class="n">extra_elem</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extra_data_attr_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">extra_elem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># The special case of character extra data must be caught</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra_elem</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ia</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_elem</span><span class="p">)</span>
                    <span class="c1"># pad any strings up to a multiple of PP_WORD_DEPTH</span>
                    <span class="c1"># (this length is # of bytes)</span>
                    <span class="n">ia</span> <span class="o">=</span> <span class="p">(</span><span class="n">PP_WORD_DEPTH</span> <span class="o">-</span> <span class="p">(</span><span class="n">ia</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">PP_WORD_DEPTH</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ia</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">extra_elem</span> <span class="o">=</span> <span class="n">extra_elem</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\00</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># ia is now the datalength in WORDS of the string</span>
                    <span class="n">ia</span> <span class="o">//=</span> <span class="n">PP_WORD_DEPTH</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># ia is the datalength in WORDS</span>
                    <span class="n">ia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">extra_elem</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="c1"># flip the byteorder if the data is not big-endian</span>
                    <span class="k">if</span> <span class="n">extra_elem</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">extra_elem</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                        <span class="c1"># take a copy of the extra data when byte swapping</span>
                        <span class="n">extra_elem</span> <span class="o">=</span> <span class="n">extra_elem</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">extra_elem</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">extra_elem</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

                <span class="c1"># add the number of bytes to the len_of_data_payload variable</span>
                <span class="c1"># + the extra integer which will encode ia/ib</span>
                <span class="n">len_of_data_payload</span> <span class="o">+=</span> <span class="n">PP_WORD_DEPTH</span> <span class="o">*</span> <span class="n">ia</span> <span class="o">+</span> <span class="n">PP_WORD_DEPTH</span>
                <span class="n">integer_code</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">ia</span> <span class="o">+</span> <span class="n">ib</span>
                <span class="n">extra_items</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">integer_code</span><span class="p">,</span> <span class="n">extra_elem</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">ia</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                        <span class="s2">&quot;PP files cannot write extra data with more&quot;</span>
                        <span class="s1">&#39; than 1000 elements. Tried to write &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span>
                        <span class="s2">&quot; which has </span><span class="si">%s</span><span class="s2"> elements.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">extra_data_attr_name</span><span class="p">,</span> <span class="n">ib</span><span class="p">)</span>
                    <span class="p">)</span>

        <span class="c1"># populate lbext in WORDS</span>
        <span class="n">lb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;lbext&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">len_of_data_payload</span> <span class="o">//</span> <span class="n">PP_WORD_DEPTH</span>

        <span class="c1"># Put the data length of pp.data into len_of_data_payload (in BYTES)</span>
        <span class="n">lbpack</span> <span class="o">=</span> <span class="n">lb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;lbpack&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">lbpack</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">len_of_data_payload</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">PP_WORD_DEPTH</span>
        <span class="k">elif</span> <span class="n">lbpack</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mo_pack</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">compress_wgdos</span> <span class="o">=</span> <span class="n">mo_pack</span><span class="o">.</span><span class="n">compress_wgdos</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">compress_wgdos</span> <span class="o">=</span> <span class="n">mo_pack</span><span class="o">.</span><span class="n">pack_wgdos</span>
                <span class="n">packed_data</span> <span class="o">=</span> <span class="n">compress_wgdos</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                    <span class="n">b</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;bacc&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">45</span><span class="p">],</span>
                    <span class="n">b</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;bmdi&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">45</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">len_of_data_payload</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">packed_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Writing packed pp data with lbpack of </span><span class="si">{}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;requires mo_pack to be installed.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lbpack</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># populate lbrec in WORDS</span>
        <span class="n">lb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;lblrec&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">len_of_data_payload</span> <span class="o">//</span> <span class="n">PP_WORD_DEPTH</span>
        <span class="p">)</span>

        <span class="c1"># populate lbuser[0] to have the data&#39;s datatype</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;f4&quot;</span><span class="p">):</span>
            <span class="n">lb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;lbuser&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;f8&quot;</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Downcasting array precision from float64 to float32&quot;</span>
                <span class="s2">&quot; for save.If float64 precision is required then&quot;</span>
                <span class="s2">&quot; please save in a different format&quot;</span>
            <span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;&gt;f4&quot;</span><span class="p">)</span>
            <span class="n">lb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;lbuser&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;i4&quot;</span><span class="p">):</span>
            <span class="c1"># NB: there is no physical difference between lbuser[0] of 2 or 3</span>
            <span class="c1"># so we encode just 2</span>
            <span class="n">lb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_DICT</span><span class="p">[</span><span class="s2">&quot;lbuser&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to write data array to a PP file. &quot;</span>
                <span class="s2">&quot;The datatype was </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>

        <span class="c1"># NB: lbegin, lbnrec, lbuser[1] not set up</span>

        <span class="c1"># Now that we have done the manouvering required, write to the file...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The file_handle argument must be an instance of a&quot;</span>
                <span class="s2">&quot; Python file object, but got </span><span class="si">%r</span><span class="s2">. </span><span class="se">\n</span><span class="s2"> e.g. &quot;</span>
                <span class="s1">&#39;open(filename, &quot;wb&quot;) to open a binary file with&#39;</span>
                <span class="s2">&quot; write permission.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">pp_file</span> <span class="o">=</span> <span class="n">file_handle</span>

        <span class="c1"># header length</span>
        <span class="n">pp_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;L&quot;</span><span class="p">,</span> <span class="n">PP_HEADER_DEPTH</span><span class="p">))</span>

        <span class="c1"># 45 integers</span>
        <span class="n">lb</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pp_file</span><span class="p">)</span>
        <span class="c1"># 19 floats</span>
        <span class="n">b</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pp_file</span><span class="p">)</span>

        <span class="c1"># Header length (again)</span>
        <span class="n">pp_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;L&quot;</span><span class="p">,</span> <span class="n">PP_HEADER_DEPTH</span><span class="p">))</span>

        <span class="c1"># Data length (including extra data length)</span>
        <span class="n">pp_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;L&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">len_of_data_payload</span><span class="p">)))</span>

        <span class="c1"># the data itself</span>
        <span class="k">if</span> <span class="n">lbpack</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pp_file</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lbpack</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pp_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">packed_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Writing packed pp data with lbpack of </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;is not supported.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lbpack</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># extra data elements</span>
        <span class="k">for</span> <span class="n">int_code</span><span class="p">,</span> <span class="n">extra_data</span> <span class="ow">in</span> <span class="n">extra_items</span><span class="p">:</span>
            <span class="n">pp_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;L&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">int_code</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra_data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">pp_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;</span><span class="si">%s</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_data</span><span class="p">),</span> <span class="n">extra_data</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extra_data</span> <span class="o">=</span> <span class="n">extra_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&gt;f4&quot;</span><span class="p">))</span>
                <span class="n">extra_data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pp_file</span><span class="p">)</span>

        <span class="c1"># Data length (again)</span>
        <span class="n">pp_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;L&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">len_of_data_payload</span><span class="p">)))</span></div>

    <span class="c1">##############################################################</span>
    <span class="c1">#</span>
    <span class="c1"># From here on define helper methods for PP -&gt; Cube conversion.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="PPField.time_unit"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.PPField.time_unit">[docs]</a>    <span class="k">def</span> <span class="nf">time_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="s2">&quot;epoch&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cf_units</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> since </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time_unit</span><span class="p">,</span> <span class="n">epoch</span><span class="p">),</span> <span class="n">calendar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calendar</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="PPField.coord_system"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.PPField.coord_system">[docs]</a>    <span class="k">def</span> <span class="nf">coord_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a CoordSystem for this PPField.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Currently, a :class:`~iris.coord_systems.GeogCS` or</span>
<span class="sd">            :class:`~iris.coord_systems.RotatedGeogCS`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geog_cs</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coord_systems</span><span class="o">.</span><span class="n">GeogCS</span><span class="p">(</span><span class="n">EARTH_RADIUS</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">degrees_ne</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">ref_angle</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return whether an angle differs significantly from a set value.</span>

<span class="sd">            The inputs are in degrees.</span>
<span class="sd">            The difference is judged significant if more than 0.0001 degrees.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="n">ref_angle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0001</span>

        <span class="k">if</span> <span class="n">degrees_ne</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bplat</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">degrees_ne</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bplon</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">degrees_ne</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bplon</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># NOTE: when bplat,bplon=90,0 this encodes an unrotated system.</span>
            <span class="c1"># However, the rotated system which is *equivalent* to an unrotated</span>
            <span class="c1"># one actually has blat,bplon=90,180, due to a quirk in the</span>
            <span class="c1"># definition equations.</span>
            <span class="c1"># So we accept BPLON of 0 *or* 180 to mean &#39;unrotated&#39;.</span>
            <span class="n">geog_cs</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coord_systems</span><span class="o">.</span><span class="n">RotatedGeogCS</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bplat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bplon</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">=</span><span class="n">geog_cs</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">geog_cs</span></div>

    <span class="k">def</span> <span class="nf">_x_coord_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Remove once we have the ability to derive this in the rules.</span>
        <span class="n">x_name</span> <span class="o">=</span> <span class="s2">&quot;longitude&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span><span class="p">(),</span> <span class="n">iris</span><span class="o">.</span><span class="n">coord_systems</span><span class="o">.</span><span class="n">RotatedGeogCS</span><span class="p">):</span>
            <span class="n">x_name</span> <span class="o">=</span> <span class="s2">&quot;grid_longitude&quot;</span>
        <span class="k">return</span> <span class="n">x_name</span>

    <span class="k">def</span> <span class="nf">_y_coord_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Remove once we have the ability to derive this in the rules.</span>
        <span class="n">y_name</span> <span class="o">=</span> <span class="s2">&quot;latitude&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span><span class="p">(),</span> <span class="n">iris</span><span class="o">.</span><span class="n">coord_systems</span><span class="o">.</span><span class="n">RotatedGeogCS</span><span class="p">):</span>
            <span class="n">y_name</span> <span class="o">=</span> <span class="s2">&quot;grid_latitude&quot;</span>
        <span class="k">return</span> <span class="n">y_name</span>

<div class="viewcode-block" id="PPField.copy"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.PPField.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of this PPField.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy instance of the :class:`PPField`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deepcopy</span><span class="p">({})</span></div>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deepcopy</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="c1"># Cope with inability to deepcopy a 0-d NumPy array.</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_data&quot;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value</span><span class="p">[()],</span> <span class="n">memo</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">field</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PPField</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">attrs</span><span class="p">):</span>
                    <span class="n">self_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                    <span class="n">other_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">self_attr</span> <span class="o">==</span> <span class="n">other_attr</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">attrs</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span></div>


<span class="k">class</span> <span class="nc">PPField2</span><span class="p">(</span><span class="n">PPField</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to hold a single field from a PP file, with a</span>
<span class="sd">    header release number of 2.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">HEADER_DEFN</span> <span class="o">=</span> <span class="n">_header_defn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">HEADER_DICT</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">HEADER_DEFN</span><span class="p">)</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="n">_pp_attribute_names</span><span class="p">(</span><span class="n">HEADER_DEFN</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">t1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A cftime.datetime object consisting of the lbyr, lbmon, lbdat, lbhr,</span>
<span class="sd">        and lbmin attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t1&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t1</span> <span class="o">=</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbyr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbmon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbdat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbhr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbmin</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t1</span>

    <span class="nd">@t1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">t1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbyr</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbmon</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbdat</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbhr</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbmin</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">minute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbday</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%j&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t1&quot;</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t1&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">t2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A cftime.datetime object consisting of the lbyrd, lbmond, lbdatd,</span>
<span class="sd">        lbhrd, and lbmind attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t2&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t2</span> <span class="o">=</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbyrd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbmond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbdatd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbhrd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbmind</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t2</span>

    <span class="nd">@t2</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">t2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbyrd</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbmond</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbdatd</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbhrd</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbmind</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">minute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbdayd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%j&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t2&quot;</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t2&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PPField3</span><span class="p">(</span><span class="n">PPField</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to hold a single field from a PP file, with a</span>
<span class="sd">    header release number of 3.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">HEADER_DEFN</span> <span class="o">=</span> <span class="n">_header_defn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">HEADER_DICT</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">HEADER_DEFN</span><span class="p">)</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="n">_pp_attribute_names</span><span class="p">(</span><span class="n">HEADER_DEFN</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">t1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A cftime.datetime object consisting of the lbyr, lbmon, lbdat, lbhr,</span>
<span class="sd">        lbmin, and lbsec attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t1&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t1</span> <span class="o">=</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbyr</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbmon</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbdat</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbhr</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbmin</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbsec</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t1</span>

    <span class="nd">@t1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">t1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbyr</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbmon</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbdat</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbhr</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbmin</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">minute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbsec</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">second</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t1&quot;</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t1&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">t2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A cftime.datetime object consisting of the lbyrd, lbmond, lbdatd,</span>
<span class="sd">        lbhrd, lbmind, and lbsecd attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t2&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t2</span> <span class="o">=</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbyrd</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbmond</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbdatd</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbhrd</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbmind</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbsecd</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t2</span>

    <span class="nd">@t2</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">t2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbyrd</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbmond</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbdatd</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbhrd</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbmind</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">minute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbsecd</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">second</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t2&quot;</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_t2&quot;</span><span class="p">)</span>


<span class="n">PP_CLASSES</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">PPField2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">PPField3</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">make_pp_field</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
    <span class="c1"># Choose a PP field class from the value of LBREL</span>
    <span class="n">lbrel</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">lbrel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">PP_CLASSES</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported header release number: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lbrel</span><span class="p">))</span>
    <span class="n">pp_field</span> <span class="o">=</span> <span class="n">PP_CLASSES</span><span class="p">[</span><span class="n">lbrel</span><span class="p">](</span><span class="n">header</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pp_field</span>


<span class="n">LoadedArrayBytes</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;LoadedArrayBytes&quot;</span><span class="p">,</span> <span class="s2">&quot;bytes, dtype&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">read_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">little_ended</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an iterator of PPFields given a filename.</span>

<span class="sd">    Args:</span>

<span class="sd">    * filename - string of the filename to load.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * read_data - boolean</span>
<span class="sd">        Flag whether or not the data should be read, if False an empty</span>
<span class="sd">        data manager will be provided which can subsequently load the data</span>
<span class="sd">        on demand. Default False.</span>

<span class="sd">    * little_ended - boolean</span>
<span class="sd">        If True, file contains all little-ended words (header and data).</span>

<span class="sd">    To iterate through all of the fields in a pp file::</span>

<span class="sd">        for field in iris.fileformats.pp.load(filename):</span>
<span class="sd">            print(field)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_interpret_fields</span><span class="p">(</span>
        <span class="n">_field_gen</span><span class="p">(</span>
            <span class="n">filename</span><span class="p">,</span> <span class="n">read_data_bytes</span><span class="o">=</span><span class="n">read_data</span><span class="p">,</span> <span class="n">little_ended</span><span class="o">=</span><span class="n">little_ended</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_interpret_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn the fields read with load and FF2PP._extract_field into useable</span>
<span class="sd">    fields. One of the primary purposes of this function is to either convert</span>
<span class="sd">    &quot;deferred bytes&quot; into &quot;deferred arrays&quot; or &quot;loaded bytes&quot; into actual</span>
<span class="sd">    numpy arrays (via the _create_field_data) function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">land_mask_field</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">landmask_compressed_fields</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
        <span class="c1"># Store the first reference to a land mask, and use this as the</span>
        <span class="c1"># definitive mask for future fields in this generator.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">land_mask_field</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">//</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">30</span>
        <span class="p">):</span>
            <span class="n">land_mask_field</span> <span class="o">=</span> <span class="n">field</span>

        <span class="c1"># Handle land compressed data payloads, when lbpack.n2 is 2.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">raw_lbpack</span> <span class="o">//</span> <span class="mi">10</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Field uses land-mask packing, so needs a related land-mask field.</span>
            <span class="k">if</span> <span class="n">land_mask_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">landmask_compressed_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                <span class="c1"># Land-masked fields have their size+shape defined by the</span>
                <span class="c1"># reference landmask field, so we can&#39;t yield them if they</span>
                <span class="c1"># are encountered *before* the landmask.</span>
                <span class="c1"># In that case, defer them, and process them all afterwards at</span>
                <span class="c1"># the end of the file.</span>
                <span class="k">continue</span>

            <span class="c1"># Land-mask compressed fields don&#39;t have an lbrow and lbnpt.</span>
            <span class="n">field</span><span class="o">.</span><span class="n">lbrow</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">lbnpt</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">land_mask_field</span><span class="o">.</span><span class="n">lbrow</span><span class="p">,</span>
                <span class="n">land_mask_field</span><span class="o">.</span><span class="n">lbnpt</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_create_field_data</span><span class="p">(</span>
                <span class="n">field</span><span class="p">,</span>
                <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">lbrow</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">lbnpt</span><span class="p">),</span>
                <span class="n">land_mask_field</span><span class="o">=</span><span class="n">land_mask_field</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Field does not use land-mask packing.</span>
            <span class="n">_create_field_data</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">lbrow</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">lbnpt</span><span class="p">))</span>

        <span class="k">yield</span> <span class="n">field</span>

    <span class="c1"># At file end, return any land-masked fields that were deferred because</span>
    <span class="c1"># they were encountered before the landmask reference field.</span>
    <span class="k">if</span> <span class="n">landmask_compressed_fields</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">land_mask_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Landmask compressed fields existed without a &quot;</span>
                <span class="s2">&quot;landmask to decompress with. The data will have &quot;</span>
                <span class="s2">&quot;a shape of (0, 0) and will not read.&quot;</span>
            <span class="p">)</span>
            <span class="n">mask_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">land_mask_field</span><span class="o">.</span><span class="n">lbrow</span><span class="p">,</span> <span class="n">land_mask_field</span><span class="o">.</span><span class="n">lbnpt</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">landmask_compressed_fields</span><span class="p">:</span>
            <span class="n">field</span><span class="o">.</span><span class="n">lbrow</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">lbnpt</span> <span class="o">=</span> <span class="n">mask_shape</span>
            <span class="n">_create_field_data</span><span class="p">(</span>
                <span class="n">field</span><span class="p">,</span> <span class="n">mask_shape</span><span class="p">,</span> <span class="n">land_mask_field</span><span class="o">=</span><span class="n">land_mask_field</span>
            <span class="p">)</span>
            <span class="k">yield</span> <span class="n">field</span>


<span class="k">def</span> <span class="nf">_create_field_data</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">,</span> <span class="n">land_mask_field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modifies a field&#39;s ``_data`` attribute either by:</span>
<span class="sd">     * converting a &#39;deferred array bytes&#39; tuple into a lazy array,</span>
<span class="sd">     * converting LoadedArrayBytes into an actual numpy array.</span>

<span class="sd">    If &#39;land_mask_field&#39; is passed (not None), then it contains the associated</span>
<span class="sd">    landmask, which is also a field :  Its data array is used as a template for</span>
<span class="sd">    `field`&#39;s data, determining its size, shape and the locations of all the</span>
<span class="sd">    valid (non-missing) datapoints.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">core_data</span><span class="p">(),</span> <span class="n">LoadedArrayBytes</span><span class="p">):</span>
        <span class="n">loaded_bytes</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>
        <span class="n">field</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_data_bytes_to_shaped_array</span><span class="p">(</span>
            <span class="n">loaded_bytes</span><span class="o">.</span><span class="n">bytes</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">lbpack</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">boundary_packing</span><span class="p">,</span>
            <span class="n">data_shape</span><span class="p">,</span>
            <span class="n">loaded_bytes</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">bmdi</span><span class="p">,</span>
            <span class="n">land_mask_field</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Wrap the reference to the data payload within a data proxy</span>
        <span class="c1"># in order to support deferred data loading.</span>
        <span class="n">fname</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">n_bytes</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>
        <span class="n">proxy</span> <span class="o">=</span> <span class="n">PPDataProxy</span><span class="p">(</span>
            <span class="n">data_shape</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">,</span>
            <span class="n">fname</span><span class="p">,</span>
            <span class="n">position</span><span class="p">,</span>
            <span class="n">n_bytes</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">raw_lbpack</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">boundary_packing</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">bmdi</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">block_shape</span> <span class="o">=</span> <span class="n">data_shape</span> <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_shape</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">land_mask_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># For a &quot;normal&quot; (non-landsea-masked) field, the proxy can be</span>
            <span class="c1"># wrapped directly as a deferred array.</span>
            <span class="n">field</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">as_lazy_data</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">block_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is a landsea-masked field, and its data must be handled in</span>
            <span class="c1"># a different way :  Because data shape/size is not known in</span>
            <span class="c1"># advance, the data+mask calculation can&#39;t be represented</span>
            <span class="c1"># as a dask-array operation.  Instead, we make that calculation</span>
            <span class="c1"># &#39;delayed&#39;, and then use &#39;from_delayed&#39; to make the result back</span>
            <span class="c1"># into a dask array -- because the final result shape *is* known.</span>
            <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
            <span class="k">def</span> <span class="nf">fetch_valid_values_array</span><span class="p">():</span>
                <span class="c1"># Return the data values array (shape+size unknown).</span>
                <span class="k">return</span> <span class="n">proxy</span><span class="p">[:]</span>

            <span class="n">delayed_valid_values</span> <span class="o">=</span> <span class="n">fetch_valid_values_array</span><span class="p">()</span>

            <span class="c1"># Get the mask data-array from the landsea-mask field.</span>
            <span class="c1"># This is *either* a lazy or a real array, we don&#39;t actually care.</span>
            <span class="c1"># If this is a deferred dependency, the delayed calc can see that.</span>
            <span class="n">mask_field_array</span> <span class="o">=</span> <span class="n">land_mask_field</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>

            <span class="c1"># Check whether this field uses a land or a sea mask.</span>
            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">lbpack</span><span class="o">.</span><span class="n">n3</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported mask compression : &quot;</span>
                    <span class="s2">&quot;lbpack.n3 = </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">lbpack</span><span class="o">.</span><span class="n">n3</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">lbpack</span><span class="o">.</span><span class="n">n3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Sea-mask packing : points are inverse of the land-mask.</span>
                <span class="n">mask_field_array</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask_field_array</span>

            <span class="c1"># Define the mask+data calculation as a deferred operation.</span>
            <span class="c1"># NOTE: duplicates the operation in _data_bytes_to_shaped_array.</span>
            <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
            <span class="k">def</span> <span class="nf">calc_array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="c1"># Note: &quot;mask&quot; is True at *valid* points, not missing ones.</span>
                <span class="c1"># First ensure the mask array is boolean (not int).</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="c1"># Apply the fill-value from the proxy object.</span>
                <span class="c1"># Note: &#39;values&#39; is just &#39;proxy&#39; in a dask wrapper.  This arg</span>
                <span class="c1"># must be a dask type so that &#39;delayed&#39; can recognise it, but</span>
                <span class="c1"># that provides no access to the underlying fill value.</span>
                <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">proxy</span><span class="o">.</span><span class="n">mdi</span>
                <span class="n">n_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Note: data field can have excess values, but not fewer.</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:</span><span class="n">n_values</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="n">delayed_result</span> <span class="o">=</span> <span class="n">calc_array</span><span class="p">(</span><span class="n">mask_field_array</span><span class="p">,</span> <span class="n">delayed_valid_values</span><span class="p">)</span>
            <span class="n">lazy_result_array</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_delayed</span><span class="p">(</span>
                <span class="n">delayed_result</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">block_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
            <span class="p">)</span>
            <span class="n">field</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">lazy_result_array</span>


<span class="k">def</span> <span class="nf">_field_gen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">read_data_bytes</span><span class="p">,</span> <span class="n">little_ended</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a generator of &quot;half-formed&quot; PPField instances derived from</span>
<span class="sd">    the given filename.</span>

<span class="sd">    A field returned by the generator is only &quot;half-formed&quot; because its</span>
<span class="sd">    `_data` attribute represents a simple one-dimensional stream of</span>
<span class="sd">    bytes. (Encoded either as an instance of LoadedArrayBytes or as a</span>
<span class="sd">    &#39;deferred array bytes&#39; tuple, depending on the value of `read_data_bytes`.)</span>
<span class="sd">    This is because fields encoded with a land/sea mask do not contain</span>
<span class="sd">    sufficient information within the field to determine the final</span>
<span class="sd">    two-dimensional shape of the data.</span>

<span class="sd">    The callers of this routine are the &#39;load&#39; routines (both PP and FF).</span>
<span class="sd">    They both filter the resulting stream of fields with `_interpret_fields`,</span>
<span class="sd">    which replaces each field.data with an actual array (real or lazy).</span>
<span class="sd">    This is done separately so that `_interpret_fields` can detect land-mask</span>
<span class="sd">    fields and use them to construct data arrays for any fields which use</span>
<span class="sd">    land/sea-mask packing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype_endian_char</span> <span class="o">=</span> <span class="s2">&quot;&lt;&quot;</span> <span class="k">if</span> <span class="n">little_ended</span> <span class="k">else</span> <span class="s2">&quot;&gt;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pp_file</span><span class="p">:</span>
        <span class="c1"># Get a reference to the seek method on the file</span>
        <span class="c1"># (this is accessed 3* #number of headers so can provide a small</span>
        <span class="c1"># performance boost)</span>
        <span class="n">pp_file_seek</span> <span class="o">=</span> <span class="n">pp_file</span><span class="o">.</span><span class="n">seek</span>
        <span class="n">pp_file_read</span> <span class="o">=</span> <span class="n">pp_file</span><span class="o">.</span><span class="n">read</span>

        <span class="n">field_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Keep reading until we reach the end of file</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Move past the leading header length word</span>
            <span class="n">pp_file_seek</span><span class="p">(</span><span class="n">PP_WORD_DEPTH</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>
            <span class="c1"># Get the LONG header entries</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%c</span><span class="s2">i</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtype_endian_char</span><span class="p">,</span> <span class="n">PP_WORD_DEPTH</span><span class="p">)</span>
            <span class="n">header_longs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span>
                <span class="n">pp_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">NUM_LONG_HEADERS</span>
            <span class="p">)</span>
            <span class="c1"># Nothing returned =&gt; EOF</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_longs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># Get the FLOAT header entries</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%c</span><span class="s2">f</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtype_endian_char</span><span class="p">,</span> <span class="n">PP_WORD_DEPTH</span><span class="p">)</span>
            <span class="n">header_floats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span>
                <span class="n">pp_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">NUM_FLOAT_HEADERS</span>
            <span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">header_longs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">header_floats</span><span class="p">)</span>

            <span class="c1"># Make a PPField of the appropriate sub-class (depends on header</span>
            <span class="c1"># release number)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pp_field</span> <span class="o">=</span> <span class="n">make_pp_field</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Unable to interpret field </span><span class="si">{}</span><span class="s2">. </span><span class="si">{}</span><span class="s2">. Skipping &quot;</span>
                    <span class="s2">&quot;the remainder of the file.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_count</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="c1"># Skip the trailing 4-byte word containing the header length</span>
            <span class="n">pp_file_seek</span><span class="p">(</span><span class="n">PP_WORD_DEPTH</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>

            <span class="c1"># Read the word telling me how long the data + extra data is</span>
            <span class="c1"># This value is # of bytes</span>
            <span class="n">len_of_data_plus_extra</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%c</span><span class="s2">L&quot;</span> <span class="o">%</span> <span class="n">dtype_endian_char</span><span class="p">,</span> <span class="n">pp_file_read</span><span class="p">(</span><span class="n">PP_WORD_DEPTH</span><span class="p">)</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">len_of_data_plus_extra</span> <span class="o">!=</span> <span class="n">pp_field</span><span class="o">.</span><span class="n">lblrec</span> <span class="o">*</span> <span class="n">PP_WORD_DEPTH</span><span class="p">:</span>
                <span class="n">wmsg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;LBLREC has a different value to the integer recorded &quot;</span>
                    <span class="s2">&quot;after the header in the file (</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">). &quot;</span>
                    <span class="s2">&quot;Skipping the remainder of the file.&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="n">wmsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">pp_field</span><span class="o">.</span><span class="n">lblrec</span> <span class="o">*</span> <span class="n">PP_WORD_DEPTH</span><span class="p">,</span> <span class="n">len_of_data_plus_extra</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">break</span>

            <span class="c1"># calculate the extra length in bytes</span>
            <span class="n">extra_len</span> <span class="o">=</span> <span class="n">pp_field</span><span class="o">.</span><span class="n">lbext</span> <span class="o">*</span> <span class="n">PP_WORD_DEPTH</span>

            <span class="c1"># Derive size and datatype of payload</span>
            <span class="n">data_len</span> <span class="o">=</span> <span class="n">len_of_data_plus_extra</span> <span class="o">-</span> <span class="n">extra_len</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">LBUSER_DTYPE_LOOKUP</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">pp_field</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LBUSER_DTYPE_LOOKUP</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">little_ended</span><span class="p">:</span>
                <span class="c1"># Change data dtype for a little-ended file.</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Unexpected dtype </span><span class="si">{!r}</span><span class="s2"> can&#39;t be converted to &quot;</span>
                        <span class="s2">&quot;little-endian&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="n">dtype</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

            <span class="k">if</span> <span class="n">read_data_bytes</span><span class="p">:</span>
                <span class="c1"># Read the actual bytes. This can then be converted to a numpy</span>
                <span class="c1"># array at a higher level.</span>
                <span class="n">pp_field</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">LoadedArrayBytes</span><span class="p">(</span><span class="n">pp_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">data_len</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Provide enough context to read the data bytes later on,</span>
                <span class="c1"># as a &#39;deferred array bytes&#39; tuple.</span>
                <span class="c1"># N.B. this used to be a namedtuple called DeferredArrayBytes,</span>
                <span class="c1"># but it no longer is. Possibly for performance reasons?</span>
                <span class="n">pp_field</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">pp_file</span><span class="o">.</span><span class="n">tell</span><span class="p">(),</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                <span class="c1"># Seek over the actual data payload.</span>
                <span class="n">pp_file_seek</span><span class="p">(</span><span class="n">data_len</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>

            <span class="c1"># Do we have any extra data to deal with?</span>
            <span class="k">if</span> <span class="n">extra_len</span><span class="p">:</span>
                <span class="n">pp_field</span><span class="o">.</span><span class="n">_read_extra_data</span><span class="p">(</span>
                    <span class="n">pp_file</span><span class="p">,</span> <span class="n">pp_file_read</span><span class="p">,</span> <span class="n">extra_len</span><span class="p">,</span> <span class="n">little_ended</span><span class="o">=</span><span class="n">little_ended</span>
                <span class="p">)</span>

            <span class="c1"># Skip that last 4 byte record telling me the length of the field I</span>
            <span class="c1"># have already read</span>
            <span class="n">pp_file_seek</span><span class="p">(</span><span class="n">PP_WORD_DEPTH</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>
            <span class="n">field_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">yield</span> <span class="n">pp_field</span>


<span class="c1"># Stash codes not to be filtered (reference altitude and pressure fields).</span>
<span class="n">_STASH_ALLOW</span> <span class="o">=</span> <span class="p">[</span><span class="n">STASH</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">33</span><span class="p">),</span> <span class="n">STASH</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_convert_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts known constraints from Iris semantics to PP semantics</span>
<span class="sd">    ignoring all unknown constraints.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">constraints</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_constraints</span><span class="o">.</span><span class="n">list_of_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
    <span class="n">pp_constraints</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">unhandled_constraints</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_make_func</span><span class="p">(</span><span class="n">stashobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides unique name-space for each lambda function&#39;s stashobj</span>
<span class="sd">        variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">stash</span><span class="p">:</span> <span class="n">stash</span> <span class="o">==</span> <span class="n">stashobj</span>

    <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">AttributeConstraint</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">con</span><span class="o">.</span><span class="n">_attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;STASH&quot;</span><span class="p">]:</span>
            <span class="c1"># Convert a STASH constraint.</span>
            <span class="c1"># The attribute can be a STASH object, a stashcode string, or a</span>
            <span class="c1"># callable.</span>
            <span class="n">stashobj</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">_attributes</span><span class="p">[</span><span class="s2">&quot;STASH&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">stashobj</span><span class="p">):</span>
                <span class="n">call_func</span> <span class="o">=</span> <span class="n">stashobj</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stashobj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">STASH</span><span class="p">)):</span>
                <span class="n">call_func</span> <span class="o">=</span> <span class="n">_make_func</span><span class="p">(</span><span class="n">stashobj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;STASH constraints should be either a&quot;</span>
                    <span class="s2">&quot; callable, string or STASH object&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;stash&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pp_constraints</span><span class="p">:</span>
                <span class="n">pp_constraints</span><span class="p">[</span><span class="s2">&quot;stash&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">call_func</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pp_constraints</span><span class="p">[</span><span class="s2">&quot;stash&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">call_func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only keep the pp constraints set if they are all handled as</span>
            <span class="c1"># pp constraints</span>
            <span class="n">unhandled_constraints</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">pp_filter</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return True if field is to be kept,</span>
<span class="sd">        False if field does not match filter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">stash</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_STASH_ALLOW</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pp_constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stash&quot;</span><span class="p">):</span>

                <span class="n">res</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">call_func</span> <span class="ow">in</span> <span class="n">pp_constraints</span><span class="p">[</span><span class="s2">&quot;stash&quot;</span><span class="p">]:</span>

                    <span class="k">if</span> <span class="n">call_func</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">stash</span><span class="p">)):</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">if</span> <span class="n">pp_constraints</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">unhandled_constraints</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pp_filter</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="load_cubes"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.load_cubes">[docs]</a><span class="k">def</span> <span class="nf">load_cubes</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads cubes from a list of pp filenames.</span>

<span class="sd">    Args:</span>

<span class="sd">    * filenames - list of pp filenames to load</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * constraints - a list of Iris constraints</span>

<span class="sd">    * callback - a function which can be passed on to</span>
<span class="sd">                 :func:`iris.io.run_callback`</span>

<span class="sd">    .. note::</span>

<span class="sd">        The resultant cubes may not be in the order that they are in the file</span>
<span class="sd">        (order is not preserved when there is a field with orography</span>
<span class="sd">        references)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_load_cubes_variable_loader</span><span class="p">(</span>
        <span class="n">filenames</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">load</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">load_cubes_little_endian</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads cubes from a list of pp filenames containing little-endian data.</span>

<span class="sd">    Args:</span>

<span class="sd">    * filenames - list of pp filenames to load</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * constraints - a list of Iris constraints</span>

<span class="sd">    * callback - a function which can be passed on to</span>
<span class="sd">                 :func:`iris.io.run_callback`</span>

<span class="sd">    .. note::</span>

<span class="sd">        The resultant cubes may not be in the order that they are in the file</span>
<span class="sd">        (order is not preserved when there is a field with orography</span>
<span class="sd">        references)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_load_cubes_variable_loader</span><span class="p">(</span>
        <span class="n">filenames</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">,</span>
        <span class="n">load</span><span class="p">,</span>
        <span class="p">{</span><span class="s2">&quot;little_ended&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
        <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="load_pairs_from_fields"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.load_pairs_from_fields">[docs]</a><span class="k">def</span> <span class="nf">load_pairs_from_fields</span><span class="p">(</span><span class="n">pp_fields</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an iterable of PP fields into an iterable of tuples of</span>
<span class="sd">    (Cubes, PPField).</span>

<span class="sd">    Args:</span>

<span class="sd">    * pp_fields:</span>
<span class="sd">        An iterable of :class:`iris.fileformats.pp.PPField`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An iterable of :class:`iris.cube.Cube`\ s.</span>

<span class="sd">    This capability can be used to filter out fields before they are passed to</span>
<span class="sd">    the load pipeline, and amend the cubes once they are created, using</span>
<span class="sd">    PP metadata conditions.  Where this filtering</span>
<span class="sd">    removes a significant number of fields, the speed up to load can be</span>
<span class="sd">    significant:</span>

<span class="sd">        &gt;&gt;&gt; import iris</span>
<span class="sd">        &gt;&gt;&gt; from iris.fileformats.pp import load_pairs_from_fields</span>
<span class="sd">        &gt;&gt;&gt; filename = iris.sample_data_path(&#39;E1.2098.pp&#39;)</span>
<span class="sd">        &gt;&gt;&gt; filtered_fields = []</span>
<span class="sd">        &gt;&gt;&gt; for field in iris.fileformats.pp.load(filename):</span>
<span class="sd">        ...     if field.lbproc == 128:</span>
<span class="sd">        ...         filtered_fields.append(field)</span>
<span class="sd">        &gt;&gt;&gt; cube_field_pairs = load_pairs_from_fields(filtered_fields)</span>
<span class="sd">        &gt;&gt;&gt; for cube, field in cube_field_pairs:</span>
<span class="sd">        ...     cube.attributes[&#39;lbproc&#39;] = field.lbproc</span>
<span class="sd">        ...     print(cube.attributes[&#39;lbproc&#39;])</span>
<span class="sd">        128</span>

<span class="sd">    This capability can also be used to alter fields before they are passed to</span>
<span class="sd">    the load pipeline.  Fields with out of specification header elements can</span>
<span class="sd">    be cleaned up this way and cubes created:</span>

<span class="sd">        &gt;&gt;&gt; filename = iris.sample_data_path(&#39;E1.2098.pp&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cleaned_fields = list(iris.fileformats.pp.load(filename))</span>
<span class="sd">        &gt;&gt;&gt; for field in cleaned_fields:</span>
<span class="sd">        ...     if field.lbrel == 0:</span>
<span class="sd">        ...         field.lbrel = 3</span>
<span class="sd">        &gt;&gt;&gt; cubes_field_pairs = list(load_pairs_from_fields(cleaned_fields))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">load_pairs_from_fields</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">fileformats</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">load_pairs_from_fields</span>
    <span class="k">return</span> <span class="n">load_pairs_from_fields</span><span class="p">(</span>
        <span class="n">pp_fields</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">fileformats</span><span class="o">.</span><span class="n">pp_load_rules</span><span class="o">.</span><span class="n">convert</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_load_cubes_variable_loader</span><span class="p">(</span>
    <span class="n">filenames</span><span class="p">,</span>
    <span class="n">callback</span><span class="p">,</span>
    <span class="n">loading_function</span><span class="p">,</span>
    <span class="n">loading_function_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="kn">import</span> <span class="nn">iris.fileformats.um._fast_load</span> <span class="k">as</span> <span class="nn">um_fast_load</span>

    <span class="n">pp_filter</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pp_filter</span> <span class="o">=</span> <span class="n">_convert_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">um_fast_load</span><span class="o">.</span><span class="n">STRUCTURED_LOAD_CONTROLS</span><span class="o">.</span><span class="n">loads_use_structured</span><span class="p">:</span>
        <span class="c1"># For structured loads, pass down the pp_filter function as an extra</span>
        <span class="c1"># keyword to the low-level generator function.</span>
        <span class="n">loading_function_kwargs</span> <span class="o">=</span> <span class="n">loading_function_kwargs</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">loading_function_kwargs</span><span class="p">[</span><span class="s2">&quot;pp_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp_filter</span>
        <span class="c1"># Also do *not* use this filter in generic rules processing, as for</span>
        <span class="c1"># structured loading, the &#39;field&#39; of rules processing is no longer a</span>
        <span class="c1"># PPField but a FieldCollation.</span>
        <span class="n">pp_filter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Make a loader object for the generic rules code.</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">fileformats</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Loader</span><span class="p">(</span>
            <span class="n">um_fast_load</span><span class="o">.</span><span class="n">_basic_load_function</span><span class="p">,</span>
            <span class="n">loading_function_kwargs</span><span class="p">,</span>
            <span class="n">um_fast_load</span><span class="o">.</span><span class="n">_convert_collation</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">fileformats</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Loader</span><span class="p">(</span>
            <span class="n">loading_function</span><span class="p">,</span>
            <span class="n">loading_function_kwargs</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="n">iris</span><span class="o">.</span><span class="n">fileformats</span><span class="o">.</span><span class="n">pp_load_rules</span><span class="o">.</span><span class="n">convert</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">fileformats</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">load_cubes</span><span class="p">(</span>
        <span class="n">filenames</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">pp_filter</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">um_fast_load</span><span class="o">.</span><span class="n">STRUCTURED_LOAD_CONTROLS</span><span class="o">.</span><span class="n">loads_use_structured</span><span class="p">:</span>
        <span class="c1"># We need an additional concatenate-like operation to combine cubes</span>
        <span class="c1"># from different files.  Unfortunately, the &#39;merge&#39; call provided in</span>
        <span class="c1"># the iris_load_xx functions cannot do this.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">um_fast_load</span><span class="o">.</span><span class="n">_combine_structured_cubes</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="save"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.save">[docs]</a><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">field_coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use the PP saving rules (and any user rules) to save a cube to a PP file.</span>

<span class="sd">    Args:</span>

<span class="sd">        * cube         - A :class:`iris.cube.Cube`</span>
<span class="sd">        * target       - A filename or open file handle.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">        * append       - Whether to start a new file afresh or add the cube(s)</span>
<span class="sd">                         to the end of the file.</span>
<span class="sd">                         Only applicable when target is a filename, not a file</span>
<span class="sd">                         handle.</span>
<span class="sd">                         Default is False.</span>

<span class="sd">        * field_coords - list of 2 coords or coord names which are to be used</span>
<span class="sd">                         for reducing the given cube into 2d slices,</span>
<span class="sd">                         which will ultimately determine the x and y</span>
<span class="sd">                         coordinates of the resulting fields.</span>
<span class="sd">                         If None, the final two  dimensions are chosen</span>
<span class="sd">                         for slicing.</span>

<span class="sd">    See also :func:`iris.io.save`. Note that :func:`iris.save` is the preferred</span>
<span class="sd">    method of saving. This allows a :class:`iris.cube.CubeList` or a sequence</span>
<span class="sd">    of cubes to be saved to a PP file.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="n">as_fields</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">field_coords</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="n">save_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">)</span></div>


<div class="viewcode-block" id="save_pairs_from_cube"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.save_pairs_from_cube">[docs]</a><span class="k">def</span> <span class="nf">save_pairs_from_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">field_coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use the PP saving rules to convert a cube or</span>
<span class="sd">    iterable of cubes to an iterable of (2D cube, PP field) pairs.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube:</span>
<span class="sd">        A :class:`iris.cube.Cube`</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * field_coords:</span>
<span class="sd">        List of 2 coords or coord names which are to be used for</span>
<span class="sd">        reducing the given cube into 2d slices, which will ultimately</span>
<span class="sd">        determine the x and y coordinates of the resulting fields.</span>
<span class="sd">        If None, the final two  dimensions are chosen for slicing.</span>

<span class="sd">    * target:</span>
<span class="sd">        A filename or open file handle.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Open issues</span>
    <span class="c1"># Could use rules in &quot;sections&quot; ... e.g. to process the extensive</span>
    <span class="c1"># dimensions; ...?</span>
    <span class="c1"># Could pre-process the cube to add extra convenient terms?</span>
    <span class="c1">#    e.g. x-coord, y-coord ... but what about multiple coordinates on the</span>
    <span class="c1">#    dimension?</span>

    <span class="c1"># How to perform the slicing?</span>
    <span class="c1">#   Do we always slice in the last two dimensions?</span>
    <span class="c1">#   Not all source data will contain lat-lon slices.</span>
    <span class="c1"># What do we do about dimensions with multiple coordinates?</span>

    <span class="c1"># Deal with:</span>
    <span class="c1">#   LBLREC - Length of data record in words (incl. extra data)</span>
    <span class="c1">#       Done on save(*)</span>
    <span class="c1">#   LBUSER[0] - Data type</span>
    <span class="c1">#       Done on save(*)</span>
    <span class="c1">#   LBUSER[1] - Start address in DATA (?! or just set to &quot;null&quot;?)</span>
    <span class="c1">#   BLEV - Level - the value of the coordinate for LBVC</span>

    <span class="c1"># *) With the current on-save way of handling LBLREC and LBUSER[0] we can&#39;t</span>
    <span class="c1"># check if they&#39;ve been set correctly without *actually* saving as a binary</span>
    <span class="c1"># PP file. That also means you can&#39;t use the same reference.txt file for</span>
    <span class="c1"># loaded vs saved fields (unless you re-load the saved field!).</span>

    <span class="c1"># Set to (or leave as) &quot;null&quot;:</span>
    <span class="c1">#   LBEGIN - Address of start of field in direct access dataset</span>
    <span class="c1">#   LBEXP - Experiment identification</span>
    <span class="c1">#   LBPROJ - Fields file projection number</span>
    <span class="c1">#   LBTYP - Fields file field type code</span>
    <span class="c1">#   LBLEV - Fields file level code / hybrid height model level</span>

    <span class="c1"># Build confidence by having a PP object that records which header items</span>
    <span class="c1"># have been set, and only saves if they&#39;ve all been set?</span>
    <span class="c1">#   Watch out for extra-data.</span>

    <span class="c1"># On the flip side, record which Cube metadata has been &quot;used&quot; and flag up</span>
    <span class="c1"># unused?</span>

    <span class="n">n_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_dims</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to save a cube of fewer than 2 dimensions.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">field_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># cast the given coord/coord names into cube coords</span>
        <span class="n">field_coords</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">_as_list_of_coords</span><span class="p">(</span><span class="n">field_coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Got </span><span class="si">%s</span><span class="s2"> coordinates in field_coords, expecting&quot;</span>
                <span class="s2">&quot; exactly 2.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_coords</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># default to the last two dimensions</span>
        <span class="c1"># (if result of coords is an empty list, will raise an IndexError)</span>
        <span class="c1"># NB watch out for the ordering of the dimensions</span>
        <span class="n">field_coords</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="n">n_dims</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="n">n_dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="c1"># Save each named or latlon slice2D in the cube</span>
    <span class="k">for</span> <span class="n">slice2D</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">slices</span><span class="p">(</span><span class="n">field_coords</span><span class="p">):</span>
        <span class="c1"># Start with a blank PPField</span>
        <span class="n">pp_field</span> <span class="o">=</span> <span class="n">PPField3</span><span class="p">()</span>

        <span class="c1"># Set all items to 0 because we need lbuser, lbtim</span>
        <span class="c1"># and some others to be present before running the rules.</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">positions</span> <span class="ow">in</span> <span class="n">pp_field</span><span class="o">.</span><span class="n">HEADER_DEFN</span><span class="p">:</span>
            <span class="c1"># Establish whether field name is integer or real</span>
            <span class="n">default</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">0</span>
                <span class="k">if</span> <span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">NUM_LONG_HEADERS</span> <span class="o">-</span> <span class="n">UM_TO_PP_HEADER_OFFSET</span>
                <span class="k">else</span> <span class="mf">0.0</span>
            <span class="p">)</span>
            <span class="c1"># Establish whether field position is scalar or composite</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">default</span> <span class="o">=</span> <span class="p">[</span><span class="n">default</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">pp_field</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

        <span class="c1"># Some defaults should not be 0</span>
        <span class="n">pp_field</span><span class="o">.</span><span class="n">lbrel</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Header release 3.</span>
        <span class="n">pp_field</span><span class="o">.</span><span class="n">lbcode</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Grid code.</span>
        <span class="n">pp_field</span><span class="o">.</span><span class="n">bmks</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Some scaley thing.</span>
        <span class="n">pp_field</span><span class="o">.</span><span class="n">lbproc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Set the missing-data value to the standard default value.</span>
        <span class="c1"># The save code uses this header word to fill masked data points.</span>
        <span class="n">pp_field</span><span class="o">.</span><span class="n">bmdi</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e30</span>
        <span class="c1"># From UM doc F3: &quot;Set to -99 if LBEGIN not known&quot;</span>
        <span class="n">pp_field</span><span class="o">.</span><span class="n">lbuser</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>

        <span class="c1"># Set the data, keeping it lazy where possible.</span>
        <span class="n">pp_field</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">slice2D</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>

        <span class="c1"># Run the PP save rules on the slice2D, to fill the PPField,</span>
        <span class="c1"># recording the rules that were used</span>
        <span class="n">pp_field</span> <span class="o">=</span> <span class="n">verify</span><span class="p">(</span><span class="n">slice2D</span><span class="p">,</span> <span class="n">pp_field</span><span class="p">)</span>

        <span class="k">yield</span> <span class="p">(</span><span class="n">slice2D</span><span class="p">,</span> <span class="n">pp_field</span><span class="p">)</span></div>


<div class="viewcode-block" id="as_fields"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.as_fields">[docs]</a><span class="k">def</span> <span class="nf">as_fields</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">field_coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use the PP saving rules (and any user rules) to convert a cube to</span>
<span class="sd">    an iterable of PP fields.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube:</span>
<span class="sd">        A :class:`iris.cube.Cube`</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * field_coords:</span>
<span class="sd">        List of 2 coords or coord names which are to be used for</span>
<span class="sd">        reducing the given cube into 2d slices, which will ultimately</span>
<span class="sd">        determine the x and y coordinates of the resulting fields.</span>
<span class="sd">        If None, the final two  dimensions are chosen for slicing.</span>

<span class="sd">    * target:</span>
<span class="sd">        A filename or open file handle.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">field</span>
        <span class="k">for</span> <span class="n">cube</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">save_pairs_from_cube</span><span class="p">(</span>
            <span class="n">cube</span><span class="p">,</span> <span class="n">field_coords</span><span class="o">=</span><span class="n">field_coords</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="save_fields"><a class="viewcode-back" href="../../../generated/api/iris/fileformats/pp.html#iris.fileformats.pp.save_fields">[docs]</a><span class="k">def</span> <span class="nf">save_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save an iterable of PP fields to a PP file.</span>

<span class="sd">    Args:</span>

<span class="sd">    * fields:</span>
<span class="sd">        An iterable of PP fields.</span>
<span class="sd">    * target:</span>
<span class="sd">        A filename or open file handle.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * append:</span>
<span class="sd">        Whether to start a new file afresh or add the cube(s) to the end</span>
<span class="sd">        of the file.</span>
<span class="sd">        Only applicable when target is a filename, not a file handle.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    See also :func:`iris.io.save`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Open issues</span>

    <span class="c1"># Deal with:</span>
    <span class="c1">#   LBLREC - Length of data record in words (incl. extra data)</span>
    <span class="c1">#       Done on save(*)</span>
    <span class="c1">#   LBUSER[0] - Data type</span>
    <span class="c1">#       Done on save(*)</span>
    <span class="c1">#   LBUSER[1] - Start address in DATA (?! or just set to &quot;null&quot;?)</span>
    <span class="c1">#   BLEV - Level - the value of the coordinate for LBVC</span>

    <span class="c1"># *) With the current on-save way of handling LBLREC and LBUSER[0] we can&#39;t</span>
    <span class="c1"># check if they&#39;ve been set correctly without *actually* saving as a binary</span>
    <span class="c1"># PP file. That also means you can&#39;t use the same reference.txt file for</span>
    <span class="c1"># loaded vs saved fields (unless you re-load the saved field!).</span>

    <span class="c1"># Set to (or leave as) &quot;null&quot;:</span>
    <span class="c1">#   LBEGIN - Address of start of field in direct access dataset</span>
    <span class="c1">#   LBEXP - Experiment identification</span>
    <span class="c1">#   LBPROJ - Fields file projection number</span>
    <span class="c1">#   LBTYP - Fields file field type code</span>
    <span class="c1">#   LBLEV - Fields file level code / hybrid height model level</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">pp_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span> <span class="k">if</span> <span class="n">append</span> <span class="k">else</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;mode&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;b&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Target not binary&quot;</span><span class="p">)</span>
        <span class="n">pp_file</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only save pp to filename or writable&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Save each field</span>
        <span class="k">for</span> <span class="n">pp_field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="c1"># Write to file</span>
            <span class="n">pp_field</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">pp_file</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">pp_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        
        &copy; <a href="../../../copyright.html">Copyright</a> Iris Contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>