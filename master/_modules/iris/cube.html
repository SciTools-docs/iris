

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>iris.cube &mdash; Iris 3.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/theme_override.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/iris-logo-title.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installing.html">Installing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/gallery/index.html">Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/iris_cubes.html">Iris data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/loading_iris_cubes.html">Loading Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/saving_iris_cubes.html">Saving Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/navigating_a_cube.html">Navigating a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/subsetting_a_cube.html">Subsetting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/real_and_lazy_data.html">Real and lazy data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/plotting_a_cube.html">Plotting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/interpolation_and_regridding.html">Cube interpolation and regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/merge_and_concat.html">Merge and concatenate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_statistics.html">Cube statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_maths.html">Cube maths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/citation.html">Citing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/code_maintenance.html">Code maintenance</a></li>
</ul>
<p class="caption"><span class="caption-text">Further Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/lenient_metadata.html">Lenient metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/lenient_maths.html">Lenient cube maths</a></li>
</ul>
<p class="caption"><span class="caption-text">Developers Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_getting_involved.html">Getting involved</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/gitwash/index.html">Working with Iris source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_documentation.html">Contributing to the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_codebase_index.html">Contributing to the code base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_changes.html">Contributing your changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/release.html">Releases</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/iris.html">Iris API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../whatsnew/index.html">Whatâ€™s new in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../techpapers/index.html">Iris technical papers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Iris copyright, licensing and contributors</a></li>
</ul>

            
          

    
    
    
        <p class="caption">
            <span class="caption-text">
            
                Support
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SciTools/iris"><i class="fa fa-github fa-fw"></i> Source code</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris"><i class="fa fa-comments fa-fw"></i> Users Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris-dev"><i class="fa fa-comments fa-fw"></i> Developers Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://stackoverflow.com/questions/tagged/python-iris"><i class="fa fa-question fa-fw"></i> StackOverflow for "How do I?"</a></li>
            
                <li class="toctree-l1"><a href="https://scitools.org.uk/iris/docs/v2.4.0/index.html"><i class="fa fa-book fa-fw"></i> Legacy documentation</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Iris</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../iris.html">iris</a> &raquo;</li>
        
      <li>iris.cube</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for iris.cube</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Iris contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Iris and is released under the LGPL license.</span>
<span class="c1"># See COPYING and COPYING.LESSER in the root of the repository for full</span>
<span class="c1"># licensing details.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes for representing multi-dimensional data with metadata.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Container</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">MutableMapping</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">xml.dom.minidom</span> <span class="kn">import</span> <span class="n">Document</span>
<span class="kn">import</span> <span class="nn">zlib</span>

<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="kn">import</span> <span class="nn">iris._concatenate</span>
<span class="kn">import</span> <span class="nn">iris._constraints</span>
<span class="kn">from</span> <span class="nn">iris._data_manager</span> <span class="kn">import</span> <span class="n">DataManager</span>
<span class="kn">import</span> <span class="nn">iris._lazy_data</span> <span class="k">as</span> <span class="nn">_lazy</span>
<span class="kn">import</span> <span class="nn">iris._merge</span>
<span class="kn">import</span> <span class="nn">iris.analysis</span>
<span class="kn">from</span> <span class="nn">iris.analysis.cartography</span> <span class="kn">import</span> <span class="n">wrap_lons</span>
<span class="kn">import</span> <span class="nn">iris.analysis.maths</span>
<span class="kn">import</span> <span class="nn">iris.aux_factory</span>
<span class="kn">from</span> <span class="nn">iris.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CFVariableMixin</span><span class="p">,</span>
    <span class="n">CoordMetadata</span><span class="p">,</span>
    <span class="n">CubeMetadata</span><span class="p">,</span>
    <span class="n">DimCoordMetadata</span><span class="p">,</span>
    <span class="n">metadata_manager_factory</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">iris.coord_systems</span>
<span class="kn">import</span> <span class="nn">iris.coords</span>
<span class="kn">import</span> <span class="nn">iris.exceptions</span>
<span class="kn">import</span> <span class="nn">iris.util</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Cube&quot;</span><span class="p">,</span> <span class="s2">&quot;CubeList&quot;</span><span class="p">]</span>


<span class="c1"># The XML namespace to use for CubeML documents</span>
<span class="n">XML_NAMESPACE_URI</span> <span class="o">=</span> <span class="s2">&quot;urn:x-iris:cubeml-0.2&quot;</span>


<span class="k">class</span> <span class="nc">_CubeFilter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A constraint, paired with a list of cubes matching that constraint.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">cubes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="n">constraint</span>
        <span class="k">if</span> <span class="n">cubes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cubes</span> <span class="o">=</span> <span class="n">CubeList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cubes</span> <span class="o">=</span> <span class="n">cubes</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cubes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the appropriate (sub)cube to the list of cubes where it</span>
<span class="sd">        matches the constraint.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub_cube</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cubes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_cube</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new :class:`_CubeFilter` by merging the list of</span>
<span class="sd">        cubes.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * unique:</span>
<span class="sd">            If True, raises `iris.exceptions.DuplicateDataError` if</span>
<span class="sd">            duplicate cubes are detected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_CubeFilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cubes</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">unique</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_CubeFilterCollection</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A list of _CubeFilter instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_cubes</span><span class="p">(</span><span class="n">cubes</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new collection from an iterable of cubes, and some</span>
<span class="sd">        optional constraints.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_constraints</span><span class="o">.</span><span class="n">list_of_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_CubeFilter</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span> <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">]</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">_CubeFilterCollection</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">:</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">add_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairs</span> <span class="o">=</span> <span class="n">pairs</span>

    <span class="k">def</span> <span class="nf">add_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the given :class:`~iris.cube.Cube` to all of the relevant</span>
<span class="sd">        constraint pairs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">:</span>
            <span class="n">pair</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cubes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all the cubes in this collection concatenated into a</span>
<span class="sd">        single :class:`CubeList`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">CubeList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">cubes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">merged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new :class:`_CubeFilterCollection` by merging all the cube</span>
<span class="sd">        lists of this collection.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * unique:</span>
<span class="sd">            If True, raises `iris.exceptions.DuplicateDataError` if</span>
<span class="sd">            duplicate cubes are detected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_CubeFilterCollection</span><span class="p">(</span>
            <span class="p">[</span><span class="n">pair</span><span class="o">.</span><span class="n">merged</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairs</span><span class="p">]</span>
        <span class="p">)</span>


<div class="viewcode-block" id="CubeList"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList">[docs]</a><span class="k">class</span> <span class="nc">CubeList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    All the functionality of a standard :class:`list` with added &quot;Cube&quot;</span>
<span class="sd">    context.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CubeList.__new__"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.__new__">[docs]</a>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">list_of_cubes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a :class:`list` of cubes, return a CubeList instance.&quot;&quot;&quot;</span>
        <span class="n">cube_list</span> <span class="o">=</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">list_of_cubes</span><span class="p">)</span>

        <span class="c1"># Check that all items in the incoming list are cubes. Note that this</span>
        <span class="c1"># checking does not guarantee that a CubeList instance *always* has</span>
        <span class="c1"># just cubes in its list as the append &amp; __getitem__ methods have not</span>
        <span class="c1"># been overridden.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">Cube</span><span class="p">)</span> <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cube_list</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;All items in list_of_cubes must be Cube &quot;</span> <span class="s2">&quot;instances.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">cube_list</span></div>

<div class="viewcode-block" id="CubeList.__str__"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs short :meth:`Cube.summary` on every cube.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cube</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cube</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&lt; No cubes &gt;&quot;</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="CubeList.__repr__"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs repr on every cube.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span> <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">iris.experimental.representation</span> <span class="kn">import</span> <span class="n">CubeListRepresentation</span>

        <span class="n">representer</span> <span class="o">=</span> <span class="n">CubeListRepresentation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">representer</span><span class="o">.</span><span class="n">repr_html</span><span class="p">()</span>

    <span class="c1"># TODO #370 Which operators need overloads?</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CubeList</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

<div class="viewcode-block" id="CubeList.__getitem__"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x.__getitem__(y) &lt;==&gt; x[y]&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">CubeList</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="CubeList.__getslice__"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.__getslice__">[docs]</a>    <span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        x.__getslice__(i, j) &lt;==&gt; x[i:j]</span>

<span class="sd">        Use of negative indices is not supported.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__getslice__</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">CubeList</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="CubeList.xml"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.xml">[docs]</a>    <span class="k">def</span> <span class="nf">xml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string of the XML that this list of cubes represents.&quot;&quot;&quot;</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">Document</span><span class="p">()</span>
        <span class="n">cubes_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;cubes&quot;</span><span class="p">)</span>
        <span class="n">cubes_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;xmlns&quot;</span><span class="p">,</span> <span class="n">XML_NAMESPACE_URI</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cube_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">cubes_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span>
                <span class="n">cube_obj</span><span class="o">.</span><span class="n">_xml_element</span><span class="p">(</span>
                    <span class="n">doc</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">doc</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">cubes_xml_element</span><span class="p">)</span>

        <span class="c1"># return our newly created XML string</span>
        <span class="k">return</span> <span class="n">doc</span><span class="o">.</span><span class="n">toprettyxml</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="s2">&quot;  &quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CubeList.extract"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter each of the cubes which can be filtered by the given</span>
<span class="sd">        constraints.</span>

<span class="sd">        This method iterates over each constraint given, and subsets each of</span>
<span class="sd">        the cubes in this CubeList where possible. Thus, a CubeList of length</span>
<span class="sd">        **n** when filtered with **m** constraints can generate a maximum of</span>
<span class="sd">        **m * n** cubes.</span>

<span class="sd">        Args:</span>

<span class="sd">        * constraints (:class:`~iris.Constraint` or iterable of constraints):</span>
<span class="sd">            A single constraint or an iterable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_and_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="CubeList.extract_cube"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.extract_cube">[docs]</a>    <span class="k">def</span> <span class="nf">extract_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a single cube from a CubeList, and return it.</span>
<span class="sd">        Raise an error if the extract produces no cubes, or more than one.</span>

<span class="sd">        Args:</span>

<span class="sd">        * constraint (:class:`~iris.Constraint`):</span>
<span class="sd">            The constraint to extract with.</span>

<span class="sd">        .. see also::</span>
<span class="sd">            :meth:`~iris.cube.CubeList.extract`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Just validate this, so we can accept strings etc, but not multiples.</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_constraints</span><span class="o">.</span><span class="n">as_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_and_merge</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_single_cube</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CubeList.extract_cubes"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.extract_cubes">[docs]</a>    <span class="k">def</span> <span class="nf">extract_cubes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract specific cubes from a CubeList, one for each given constraint.</span>
<span class="sd">        Each constraint must produce exactly one cube, otherwise an error is</span>
<span class="sd">        raised.</span>

<span class="sd">        Args:</span>

<span class="sd">        * constraints (iterable of, or single, :class:`~iris.Constraint`):</span>
<span class="sd">            The constraints to extract with.</span>

<span class="sd">        .. see also::</span>
<span class="sd">            :meth:`~iris.cube.CubeList.extract`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_and_merge</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_single_cube</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_and_merge</span><span class="p">(</span>
        <span class="n">cubes</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_single_cube</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_constraints</span><span class="o">.</span><span class="n">list_of_constraints</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>

        <span class="c1"># group the resultant cubes by constraints in a dictionary</span>
        <span class="n">constraint_groups</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">CubeList</span><span class="p">())</span> <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">cube_list</span> <span class="ow">in</span> <span class="n">constraint_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">sub_cube</span> <span class="o">=</span> <span class="n">constraint</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sub_cube</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cube_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_cube</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">CubeList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="n">constraint_cubes</span> <span class="o">=</span> <span class="n">constraint_groups</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraint_cubes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Got </span><span class="si">%s</span><span class="s2"> cubes for constraint </span><span class="si">%r</span><span class="s2">, &quot;</span> <span class="s2">&quot;expecting 1.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">constraint_cubes</span><span class="p">),</span>
                    <span class="n">constraint</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConstraintMismatchError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">constraint_cubes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_single_cube</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Practically this should never occur, as we now *only* request</span>
                <span class="c1"># single cube result for &#39;extract_cube&#39;.</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Got </span><span class="si">{!s}</span><span class="s2"> cubes for constraints </span><span class="si">{!r}</span><span class="s2">, expecting 1.&quot;</span>
                <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConstraintMismatchError</span><span class="p">(</span>
                    <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="n">constraints</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="CubeList.extract_overlapping"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.extract_overlapping">[docs]</a>    <span class="k">def</span> <span class="nf">extract_overlapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :class:`CubeList` of cubes extracted over regions</span>
<span class="sd">        where the coordinates overlap, for the coordinates</span>
<span class="sd">        in coord_names.</span>

<span class="sd">        Args:</span>

<span class="sd">        * coord_names:</span>
<span class="sd">           A string or list of strings of the names of the coordinates</span>
<span class="sd">           over which to perform the extraction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">coord_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_names</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">make_overlap_fn</span><span class="p">(</span><span class="n">coord_name</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">overlap_fn</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">cell</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord_name</span><span class="p">)</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span> <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="bp">self</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">overlap_fn</span>

        <span class="n">coord_values</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">coord_name</span><span class="p">:</span> <span class="n">make_overlap_fn</span><span class="p">(</span><span class="n">coord_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coord_name</span> <span class="ow">in</span> <span class="n">coord_names</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">coord_values</span><span class="o">=</span><span class="n">coord_values</span><span class="p">))</span></div>

<div class="viewcode-block" id="CubeList.merge_cube"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.merge_cube">[docs]</a>    <span class="k">def</span> <span class="nf">merge_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the merged contents of the :class:`CubeList` as a single</span>
<span class="sd">        :class:`Cube`.</span>

<span class="sd">        If it is not possible to merge the `CubeList` into a single</span>
<span class="sd">        `Cube`, a :class:`~iris.exceptions.MergeError` will be raised</span>
<span class="sd">        describing the reason for the failure.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; cube_1 = iris.cube.Cube([1, 2])</span>
<span class="sd">            &gt;&gt;&gt; cube_1.add_aux_coord(iris.coords.AuxCoord(0, long_name=&#39;x&#39;))</span>
<span class="sd">            &gt;&gt;&gt; cube_2 = iris.cube.Cube([3, 4])</span>
<span class="sd">            &gt;&gt;&gt; cube_2.add_aux_coord(iris.coords.AuxCoord(1, long_name=&#39;x&#39;))</span>
<span class="sd">            &gt;&gt;&gt; cube_2.add_dim_coord(</span>
<span class="sd">            ...     iris.coords.DimCoord([0, 1], long_name=&#39;z&#39;), 0)</span>
<span class="sd">            &gt;&gt;&gt; single_cube = iris.cube.CubeList([cube_1, cube_2]).merge_cube()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            iris.exceptions.MergeError: failed to merge into a single cube.</span>
<span class="sd">              Coordinates in cube.dim_coords differ: z.</span>
<span class="sd">              Coordinate-to-dimension mapping differs for cube.dim_coords.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t merge an empty CubeList&quot;</span><span class="p">)</span>

        <span class="c1"># Register each of our cubes with a single ProtoCube.</span>
        <span class="n">proto_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_merge</span><span class="o">.</span><span class="n">ProtoCube</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">proto_cube</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">error_on_mismatch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Extract the merged cube from the ProtoCube.</span>
        <span class="p">(</span><span class="n">merged_cube</span><span class="p">,)</span> <span class="o">=</span> <span class="n">proto_cube</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">merged_cube</span></div>

<div class="viewcode-block" id="CubeList.merge"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :class:`CubeList` resulting from merging this</span>
<span class="sd">        :class:`CubeList`.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * unique:</span>
<span class="sd">            If True, raises `iris.exceptions.DuplicateDataError` if</span>
<span class="sd">            duplicate cubes are detected.</span>

<span class="sd">        This combines cubes with different values of an auxiliary scalar</span>
<span class="sd">        coordinate, by constructing a new dimension.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            import iris</span>
<span class="sd">            c1 = iris.cube.Cube([0,1,2], long_name=&#39;some_parameter&#39;)</span>
<span class="sd">            xco = iris.coords.DimCoord([11, 12, 13], long_name=&#39;x_vals&#39;)</span>
<span class="sd">            c1.add_dim_coord(xco, 0)</span>
<span class="sd">            c1.add_aux_coord(iris.coords.AuxCoord([100], long_name=&#39;y_vals&#39;))</span>
<span class="sd">            c2 = c1.copy()</span>
<span class="sd">            c2.coord(&#39;y_vals&#39;).points = [200]</span>

<span class="sd">        For example::</span>

<span class="sd">            &gt;&gt;&gt; print(c1)</span>
<span class="sd">            some_parameter / (unknown)          (x_vals: 3)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      x_vals                           x</span>
<span class="sd">                 Scalar coordinates:</span>
<span class="sd">                      y_vals: 100</span>
<span class="sd">            &gt;&gt;&gt; print(c2)</span>
<span class="sd">            some_parameter / (unknown)          (x_vals: 3)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      x_vals                           x</span>
<span class="sd">                 Scalar coordinates:</span>
<span class="sd">                      y_vals: 200</span>
<span class="sd">            &gt;&gt;&gt; cube_list = iris.cube.CubeList([c1, c2])</span>
<span class="sd">            &gt;&gt;&gt; new_cube = cube_list.merge()[0]</span>
<span class="sd">            &gt;&gt;&gt; print(new_cube)</span>
<span class="sd">            some_parameter / (unknown)          (y_vals: 2; x_vals: 3)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      y_vals                           x          -</span>
<span class="sd">                      x_vals                           -          x</span>
<span class="sd">            &gt;&gt;&gt; print(new_cube.coord(&#39;y_vals&#39;).points)</span>
<span class="sd">            [100 200]</span>
<span class="sd">            &gt;&gt;&gt;</span>

<span class="sd">        Contrast this with :meth:`iris.cube.CubeList.concatenate`, which joins</span>
<span class="sd">        cubes along an existing dimension.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Cubes may contain additional dimensional elements such as auxiliary</span>
<span class="sd">            coordinates, cell measures or ancillary variables.</span>
<span class="sd">            A group of similar cubes can only merge to a single result if all such</span>
<span class="sd">            elements are identical in every input cube : they are then present,</span>
<span class="sd">            unchanged, in the merged output cube.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If time coordinates in the list of cubes have differing epochs then</span>
<span class="sd">            the cubes will not be able to be merged. If this occurs, use</span>
<span class="sd">            :func:`iris.util.unify_time_units` to normalise the epochs of the</span>
<span class="sd">            time coordinates so that the cubes can be merged.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Register each of our cubes with its appropriate ProtoCube.</span>
        <span class="n">proto_cubes_by_name</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">standard_name</span>
            <span class="n">proto_cubes</span> <span class="o">=</span> <span class="n">proto_cubes_by_name</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">proto_cube</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">target_proto_cube</span> <span class="ow">in</span> <span class="n">proto_cubes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">target_proto_cube</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
                    <span class="n">proto_cube</span> <span class="o">=</span> <span class="n">target_proto_cube</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">proto_cube</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">proto_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_merge</span><span class="o">.</span><span class="n">ProtoCube</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
                <span class="n">proto_cubes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proto_cube</span><span class="p">)</span>

        <span class="c1"># Emulate Python 2 behaviour.</span>
        <span class="k">def</span> <span class="nf">_none_sort</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

        <span class="c1"># Extract all the merged cubes from the ProtoCubes.</span>
        <span class="n">merged_cubes</span> <span class="o">=</span> <span class="n">CubeList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">proto_cubes_by_name</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_none_sort</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">proto_cube</span> <span class="ow">in</span> <span class="n">proto_cubes_by_name</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                <span class="n">merged_cubes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">proto_cube</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">merged_cubes</span></div>

<div class="viewcode-block" id="CubeList.concatenate_cube"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.concatenate_cube">[docs]</a>    <span class="k">def</span> <span class="nf">concatenate_cube</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">check_aux_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">check_cell_measures</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">check_ancils</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the concatenated contents of the :class:`CubeList` as a single</span>
<span class="sd">        :class:`Cube`.</span>

<span class="sd">        If it is not possible to concatenate the `CubeList` into a single</span>
<span class="sd">        `Cube`, a :class:`~iris.exceptions.ConcatenateError` will be raised</span>
<span class="sd">        describing the reason for the failure.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * check_aux_coords</span>
<span class="sd">            Checks the auxiliary coordinates of the cubes match. This check</span>
<span class="sd">            is not applied to auxiliary coordinates that span the dimension</span>
<span class="sd">            the concatenation is occurring along. Defaults to True.</span>

<span class="sd">        * check_cell_measures</span>
<span class="sd">            Checks the cell measures of the cubes match. This check</span>
<span class="sd">            is not applied to cell measures that span the dimension</span>
<span class="sd">            the concatenation is occurring along. Defaults to True.</span>

<span class="sd">        * check_ancils</span>
<span class="sd">            Checks the ancillary variables of the cubes match. This check</span>
<span class="sd">            is not applied to ancillary variables that span the dimension</span>
<span class="sd">            the concatenation is occurring along. Defaults to True.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Concatenation cannot occur along an anonymous dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t concatenate an empty CubeList&quot;</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">cube</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">unique_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_concatenate</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">error_on_mismatch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">check_aux_coords</span><span class="o">=</span><span class="n">check_aux_coords</span><span class="p">,</span>
                <span class="n">check_cell_measures</span><span class="o">=</span><span class="n">check_cell_measures</span><span class="p">,</span>
                <span class="n">check_ancils</span><span class="o">=</span><span class="n">check_ancils</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">n_res_cubes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_res_cubes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msgs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;An unexpected problem prevented concatenation.&quot;</span><span class="p">)</span>
                <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;Expected only a single cube, &quot;</span>
                    <span class="s2">&quot;found </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_res_cubes</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConcatenateError</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;Cube names differ: </span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">names</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConcatenateError</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CubeList.concatenate"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.concatenate">[docs]</a>    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">check_aux_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">check_cell_measures</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">check_ancils</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate the cubes over their common dimensions.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * check_aux_coords</span>
<span class="sd">            Checks the auxiliary coordinates of the cubes match. This check</span>
<span class="sd">            is not applied to auxiliary coordinates that span the dimension</span>
<span class="sd">            the concatenation is occurring along. Defaults to True.</span>

<span class="sd">        * check_cell_measures</span>
<span class="sd">            Checks the cell measures of the cubes match. This check</span>
<span class="sd">            is not applied to cell measures that span the dimension</span>
<span class="sd">            the concatenation is occurring along. Defaults to True.</span>

<span class="sd">        * check_ancils</span>
<span class="sd">            Checks the ancillary variables of the cubes match. This check</span>
<span class="sd">            is not applied to ancillary variables that span the dimension</span>
<span class="sd">            the concatenation is occurring along. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new :class:`iris.cube.CubeList` of concatenated</span>
<span class="sd">            :class:`iris.cube.Cube` instances.</span>

<span class="sd">        This combines cubes with a common dimension coordinate, but occupying</span>
<span class="sd">        different regions of the coordinate value.  The cubes are joined across</span>
<span class="sd">        that dimension.</span>

<span class="sd">        .. testsetup::</span>

<span class="sd">            import iris</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            xco = iris.coords.DimCoord([11, 12, 13, 14], long_name=&#39;x_vals&#39;)</span>
<span class="sd">            yco1 = iris.coords.DimCoord([4, 5], long_name=&#39;y_vals&#39;)</span>
<span class="sd">            yco2 = iris.coords.DimCoord([7, 9, 10], long_name=&#39;y_vals&#39;)</span>
<span class="sd">            c1 = iris.cube.Cube(np.zeros((2,4)), long_name=&#39;some_parameter&#39;)</span>
<span class="sd">            c1.add_dim_coord(xco, 1)</span>
<span class="sd">            c1.add_dim_coord(yco1, 0)</span>
<span class="sd">            c2 = iris.cube.Cube(np.zeros((3,4)), long_name=&#39;some_parameter&#39;)</span>
<span class="sd">            c2.add_dim_coord(xco, 1)</span>
<span class="sd">            c2.add_dim_coord(yco2, 0)</span>

<span class="sd">        For example::</span>

<span class="sd">            &gt;&gt;&gt; print(c1)</span>
<span class="sd">            some_parameter / (unknown)          (y_vals: 2; x_vals: 4)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      y_vals                           x          -</span>
<span class="sd">                      x_vals                           -          x</span>
<span class="sd">            &gt;&gt;&gt; print(c1.coord(&#39;y_vals&#39;).points)</span>
<span class="sd">            [4 5]</span>
<span class="sd">            &gt;&gt;&gt; print(c2)</span>
<span class="sd">            some_parameter / (unknown)          (y_vals: 3; x_vals: 4)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      y_vals                           x          -</span>
<span class="sd">                      x_vals                           -          x</span>
<span class="sd">            &gt;&gt;&gt; print(c2.coord(&#39;y_vals&#39;).points)</span>
<span class="sd">            [ 7  9 10]</span>
<span class="sd">            &gt;&gt;&gt; cube_list = iris.cube.CubeList([c1, c2])</span>
<span class="sd">            &gt;&gt;&gt; new_cube = cube_list.concatenate()[0]</span>
<span class="sd">            &gt;&gt;&gt; print(new_cube)</span>
<span class="sd">            some_parameter / (unknown)          (y_vals: 5; x_vals: 4)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      y_vals                           x          -</span>
<span class="sd">                      x_vals                           -          x</span>
<span class="sd">            &gt;&gt;&gt; print(new_cube.coord(&#39;y_vals&#39;).points)</span>
<span class="sd">            [ 4  5  7  9 10]</span>
<span class="sd">            &gt;&gt;&gt;</span>

<span class="sd">        Contrast this with :meth:`iris.cube.CubeList.merge`, which makes a new</span>
<span class="sd">        dimension from values of an auxiliary scalar coordinate.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Cubes may contain &#39;extra&#39; dimensional elements such as auxiliary</span>
<span class="sd">            coordinates, cell measures or ancillary variables.</span>
<span class="sd">            For a group of similar cubes to concatenate together into one output, all</span>
<span class="sd">            such elements which do not map to the concatenation axis must be identical</span>
<span class="sd">            in every input cube : these then appear unchanged in the output.</span>
<span class="sd">            Similarly, those elements which *do* map to the concatenation axis must</span>
<span class="sd">            have matching properties, but may have different data values : these then</span>
<span class="sd">            appear, concatenated, in the output cube.</span>
<span class="sd">            If any cubes in a group have dimensional elements which do not match</span>
<span class="sd">            correctly, the group will not concatenate to a single output cube.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If time coordinates in the list of cubes have differing epochs then</span>
<span class="sd">            the cubes will not be able to be concatenated. If this occurs, use</span>
<span class="sd">            :func:`iris.util.unify_time_units` to normalise the epochs of the</span>
<span class="sd">            time coordinates so that the cubes can be concatenated.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Concatenation cannot occur along an anonymous dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">_concatenate</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">check_aux_coords</span><span class="o">=</span><span class="n">check_aux_coords</span><span class="p">,</span>
            <span class="n">check_cell_measures</span><span class="o">=</span><span class="n">check_cell_measures</span><span class="p">,</span>
            <span class="n">check_ancils</span><span class="o">=</span><span class="n">check_ancils</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CubeList.realise_data"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.CubeList.realise_data">[docs]</a>    <span class="k">def</span> <span class="nf">realise_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetch &#39;real&#39; data for all cubes, in a shared calculation.</span>

<span class="sd">        This computes any lazy data, equivalent to accessing each `cube.data`.</span>
<span class="sd">        However, lazy calculations and data fetches can be shared between the</span>
<span class="sd">        computations, improving performance.</span>

<span class="sd">        For example::</span>

<span class="sd">            # Form stats.</span>
<span class="sd">            a_std = cube_a.collapsed([&#39;x&#39;, &#39;y&#39;], iris.analysis.STD_DEV)</span>
<span class="sd">            b_std = cube_b.collapsed([&#39;x&#39;, &#39;y&#39;], iris.analysis.STD_DEV)</span>
<span class="sd">            ab_mean_diff = (cube_b - cube_a).collapsed([&#39;x&#39;, &#39;y&#39;],</span>
<span class="sd">                                                       iris.analysis.MEAN)</span>
<span class="sd">            std_err = (a_std * a_std + b_std * b_std) ** 0.5</span>

<span class="sd">            # Compute these stats together (avoiding multiple data passes).</span>
<span class="sd">            CubeList([a_std, b_std, ab_mean_diff, std_err]).realise_data()</span>

<span class="sd">        .. Note::</span>

<span class="sd">            Cubes with non-lazy data are not affected.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lazy</span><span class="o">.</span><span class="n">co_realise_cubes</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_is_single_item</span><span class="p">(</span><span class="n">testee</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether this is a single item, rather than an iterable.</span>

<span class="sd">    We count string types as &#39;single&#39;, also.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">testee</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">testee</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>


<div class="viewcode-block" id="Cube"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube">[docs]</a><span class="k">class</span> <span class="nc">Cube</span><span class="p">(</span><span class="n">CFVariableMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single Iris cube of data and metadata.</span>

<span class="sd">    Typically obtained from :func:`iris.load`, :func:`iris.load_cube`,</span>
<span class="sd">    :func:`iris.load_cubes`, or from the manipulation of existing cubes.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; cube = iris.load_cube(iris.sample_data_path(&#39;air_temp.pp&#39;))</span>
<span class="sd">        &gt;&gt;&gt; print(cube)</span>
<span class="sd">        air_temperature / (K)               (latitude: 73; longitude: 96)</span>
<span class="sd">             Dimension coordinates:</span>
<span class="sd">                  latitude                           x              -</span>
<span class="sd">                  longitude                          -              x</span>
<span class="sd">             Scalar coordinates:</span>
<span class="sd">                  forecast_period: 6477 hours, bound=(-28083.0, 6477.0) hours</span>
<span class="sd">                  forecast_reference_time: 1998-03-01 03:00:00</span>
<span class="sd">                  pressure: 1000.0 hPa</span>
<span class="sd">                  time: 1998-12-01 00:00:00, \</span>
<span class="sd">bound=(1994-12-01 00:00:00, 1998-12-01 00:00:00)</span>
<span class="sd">             Attributes:</span>
<span class="sd">                  STASH: m01s16i203</span>
<span class="sd">                  source: Data from Met Office Unified Model</span>
<span class="sd">             Cell methods:</span>
<span class="sd">                  mean within years: time</span>
<span class="sd">                  mean over years: time</span>


<span class="sd">    See the :doc:`user guide&lt;/userguide/index&gt;` for more information.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#: Indicates to client code that the object supports</span>
    <span class="c1">#: &quot;orthogonal indexing&quot;, which means that slices that are 1d arrays</span>
    <span class="c1">#: or lists slice along each dimension independently. This behavior</span>
    <span class="c1">#: is similar to Fortran or Matlab, but different than numpy.</span>
    <span class="n">__orthogonal_indexing__</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cell_methods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dim_coords_and_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aux_coords_and_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aux_factories</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cell_measures_and_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ancillary_variables_and_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a cube with data and optional metadata.</span>

<span class="sd">        Not typically used - normally cubes are obtained by loading data</span>
<span class="sd">        (e.g. :func:`iris.load`) or from manipulating existing cubes.</span>

<span class="sd">        Args:</span>

<span class="sd">        * data</span>
<span class="sd">            This object defines the shape of the cube and the phenomenon</span>
<span class="sd">            value in each cell.</span>

<span class="sd">            ``data`` can be a dask array, a NumPy array, a NumPy array</span>
<span class="sd">            subclass (such as :class:`numpy.ma.MaskedArray`), or</span>
<span class="sd">            array_like (as described in :func:`numpy.asarray`).</span>

<span class="sd">            See :attr:`Cube.data&lt;iris.cube.Cube.data&gt;`.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * standard_name</span>
<span class="sd">            The standard name for the Cube&#39;s data.</span>
<span class="sd">        * long_name</span>
<span class="sd">            An unconstrained description of the cube.</span>
<span class="sd">        * var_name</span>
<span class="sd">            The netCDF variable name for the cube.</span>
<span class="sd">        * units</span>
<span class="sd">            The unit of the cube, e.g. ``&quot;m s-1&quot;`` or ``&quot;kelvin&quot;``.</span>
<span class="sd">        * attributes</span>
<span class="sd">            A dictionary of cube attributes</span>
<span class="sd">        * cell_methods</span>
<span class="sd">            A tuple of CellMethod objects, generally set by Iris, e.g.</span>
<span class="sd">            ``(CellMethod(&quot;mean&quot;, coords=&#39;latitude&#39;), )``.</span>
<span class="sd">        * dim_coords_and_dims</span>
<span class="sd">            A list of coordinates with scalar dimension mappings, e.g</span>
<span class="sd">            ``[(lat_coord, 0), (lon_coord, 1)]``.</span>
<span class="sd">        * aux_coords_and_dims</span>
<span class="sd">            A list of coordinates with dimension mappings,</span>
<span class="sd">            e.g ``[(lat_coord, 0), (lon_coord, (0, 1))]``.</span>
<span class="sd">            See also :meth:`Cube.add_dim_coord()&lt;iris.cube.Cube.add_dim_coord&gt;`</span>
<span class="sd">            and :meth:`Cube.add_aux_coord()&lt;iris.cube.Cube.add_aux_coord&gt;`.</span>
<span class="sd">        * aux_factories</span>
<span class="sd">            A list of auxiliary coordinate factories. See</span>
<span class="sd">            :mod:`iris.aux_factory`.</span>
<span class="sd">        * cell_measures_and_dims</span>
<span class="sd">            A list of CellMeasures with dimension mappings.</span>
<span class="sd">        * ancillary_variables_and_dims</span>
<span class="sd">            A list of AncillaryVariables with dimension mappings.</span>

<span class="sd">        For example::</span>
<span class="sd">            &gt;&gt;&gt; from iris.coords import DimCoord</span>
<span class="sd">            &gt;&gt;&gt; from iris.cube import Cube</span>
<span class="sd">            &gt;&gt;&gt; latitude = DimCoord(np.linspace(-90, 90, 4),</span>
<span class="sd">            ...                     standard_name=&#39;latitude&#39;,</span>
<span class="sd">            ...                     units=&#39;degrees&#39;)</span>
<span class="sd">            &gt;&gt;&gt; longitude = DimCoord(np.linspace(45, 360, 8),</span>
<span class="sd">            ...                      standard_name=&#39;longitude&#39;,</span>
<span class="sd">            ...                      units=&#39;degrees&#39;)</span>
<span class="sd">            &gt;&gt;&gt; cube = Cube(np.zeros((4, 8), np.float32),</span>
<span class="sd">            ...             dim_coords_and_dims=[(latitude, 0),</span>
<span class="sd">            ...                                  (longitude, 1)])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Temporary error while we transition the API.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid data type: </span><span class="si">{!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="c1"># Configure the metadata manager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span> <span class="o">=</span> <span class="n">metadata_manager_factory</span><span class="p">(</span><span class="n">CubeMetadata</span><span class="p">)</span>

        <span class="c1"># Initialise the cube data manager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span> <span class="o">=</span> <span class="n">DataManager</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1">#: The &quot;standard name&quot; for the Cube&#39;s phenomenon.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="n">standard_name</span>

        <span class="c1">#: An instance of :class:`cf_units.Unit` describing the Cube&#39;s data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>

        <span class="c1">#: The &quot;long name&quot; for the Cube&#39;s phenomenon.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span>

        <span class="c1">#: The netCDF variable name for the Cube.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span> <span class="o">=</span> <span class="n">var_name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell_methods</span> <span class="o">=</span> <span class="n">cell_methods</span>

        <span class="c1">#: A dictionary, with a few restricted keys, for arbitrary</span>
        <span class="c1">#: Cube metadata.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="c1"># Coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aux_factories</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Cell Measures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Ancillary Variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">identities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dim_coords_and_dims</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dim_coords_and_dims</span><span class="p">:</span>
                <span class="n">identity</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">standard_name</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">long_name</span>
                <span class="k">if</span> <span class="n">identity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">identities</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_unique_dim_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
                <span class="n">identities</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">identity</span><span class="p">)</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">aux_coords_and_dims</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">aux_coords_and_dims</span><span class="p">:</span>
                <span class="n">identity</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">standard_name</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">long_name</span>
                <span class="k">if</span> <span class="n">identity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">identities</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_unique_aux_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
                <span class="n">identities</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">identity</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">aux_factories</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">aux_factories</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_aux_factory</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cell_measures_and_dims</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cell_measure</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">cell_measures_and_dims</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_cell_measure</span><span class="p">(</span><span class="n">cell_measure</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ancillary_variables_and_dims</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ancillary_variable</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">ancillary_variables_and_dims</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_ancillary_variable</span><span class="p">(</span><span class="n">ancillary_variable</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A tuple containing the value of each name participating in the identity</span>
<span class="sd">        of a :class:`iris.cube.Cube`. This includes the standard name,</span>
<span class="sd">        long name, NetCDF variable name, and the STASH from the attributes</span>
<span class="sd">        dictionary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">_names</span>

<div class="viewcode-block" id="Cube.is_compatible"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.is_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">is_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the cube is compatible with another.</span>

<span class="sd">        Compatibility is determined by comparing :meth:`iris.cube.Cube.name()`,</span>
<span class="sd">        :attr:`iris.cube.Cube.units`, :attr:`iris.cube.Cube.cell_methods` and</span>
<span class="sd">        :attr:`iris.cube.Cube.attributes` that are present in both objects.</span>

<span class="sd">        Args:</span>

<span class="sd">        * other:</span>
<span class="sd">            An instance of :class:`iris.cube.Cube` or</span>
<span class="sd">            :class:`iris.cube.CubeMetadata`.</span>
<span class="sd">        * ignore:</span>
<span class="sd">           A single attribute key or iterable of attribute keys to ignore when</span>
<span class="sd">           comparing the cubes. Default is None. To ignore all attributes set</span>
<span class="sd">           this to other.attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">           Boolean.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`iris.util.describe_diff()`</span>

<span class="sd">        .. note::</span>

<span class="sd">            This function does not indicate whether the two cubes can be</span>
<span class="sd">            merged, instead it checks only the four items quoted above for</span>
<span class="sd">            equality. Determining whether two cubes will merge requires</span>
<span class="sd">            additional logic that is beyond the scope of this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">units</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_methods</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">cell_methods</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">compatible</span><span class="p">:</span>
            <span class="n">common_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ignore</span> <span class="o">=</span> <span class="p">(</span><span class="n">ignore</span><span class="p">,)</span>
                <span class="n">common_keys</span> <span class="o">=</span> <span class="n">common_keys</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ignore</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">common_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                    <span class="n">compatible</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">compatible</span></div>

<div class="viewcode-block" id="Cube.convert_units"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.convert_units">[docs]</a>    <span class="k">def</span> <span class="nf">convert_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the cube&#39;s units, converting the values in the data array.</span>

<span class="sd">        For example, if a cube&#39;s :attr:`~iris.cube.Cube.units` are</span>
<span class="sd">        kelvin then::</span>

<span class="sd">            cube.convert_units(&#39;celsius&#39;)</span>

<span class="sd">        will change the cube&#39;s :attr:`~iris.cube.Cube.units` attribute to</span>
<span class="sd">        celsius and subtract 273.15 from each value in</span>
<span class="sd">        :attr:`~iris.cube.Cube.data`.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Calling this method will trigger any deferred loading, causing</span>
<span class="sd">            the cube&#39;s data array to be loaded into memory.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the cube has units convert the data.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot convert from unknown units. &quot;</span>
                <span class="s1">&#39;The &quot;cube.units&quot; attribute may be set directly.&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
            <span class="c1"># Make fixed copies of old + new units for a delayed conversion.</span>
            <span class="n">old_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
            <span class="n">new_unit</span> <span class="o">=</span> <span class="n">unit</span>

            <span class="c1"># Define a delayed conversion operation (i.e. a callback).</span>
            <span class="k">def</span> <span class="nf">pointwise_convert</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">old_unit</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">)</span>

            <span class="n">new_data</span> <span class="o">=</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">lazy_elementwise</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">(),</span> <span class="n">pointwise_convert</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">unit</span></div>

<div class="viewcode-block" id="Cube.add_cell_method"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.add_cell_method">[docs]</a>    <span class="k">def</span> <span class="nf">add_cell_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a :class:`~iris.coords.CellMethod` to the Cube.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_methods</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cell_method</span><span class="p">,)</span></div>

<div class="viewcode-block" id="Cube.add_aux_coord"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.add_aux_coord">[docs]</a>    <span class="k">def</span> <span class="nf">add_aux_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">data_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a CF auxiliary coordinate to the cube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * coord</span>
<span class="sd">            The :class:`iris.coords.DimCoord` or :class:`iris.coords.AuxCoord`</span>
<span class="sd">            instance to add to the cube.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * data_dims</span>
<span class="sd">            Integer or iterable of integers giving the data dimensions spanned</span>
<span class="sd">            by the coordinate.</span>

<span class="sd">        Raises a ValueError if a coordinate with identical metadata already</span>
<span class="sd">        exists on the cube.</span>

<span class="sd">        See also :meth:`Cube.remove_coord()&lt;iris.cube.Cube.remove_coord&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>  <span class="c1"># TODO: just fail on duplicate object</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate coordinates are not permitted.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_unique_aux_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_multi_dim_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">):</span>
        <span class="c1"># Convert to a tuple of integers</span>
        <span class="k">if</span> <span class="n">data_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_dims</span><span class="p">,</span> <span class="n">Container</span><span class="p">):</span>
            <span class="n">data_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data_dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_dims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data_dims</span><span class="p">),)</span>

        <span class="k">if</span> <span class="n">data_dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dims</span><span class="p">)</span> <span class="o">!=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Invalid data dimensions: </span><span class="si">{}</span><span class="s2"> given, </span><span class="si">{}</span><span class="s2"> expected for &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">data_dims</span><span class="p">),</span> <span class="n">metadata</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">metadata</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># Check compatibility with the shape of the data</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_dims</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">metadata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Unequal lengths. Cube dimension </span><span class="si">{}</span><span class="s2"> =&gt; </span><span class="si">{}</span><span class="s2">;&quot;</span>
                        <span class="s2">&quot; metadata </span><span class="si">{!r}</span><span class="s2"> dimension </span><span class="si">{}</span><span class="s2"> =&gt; </span><span class="si">{}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">dim</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span>
                            <span class="n">metadata</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span>
                            <span class="n">i</span><span class="p">,</span>
                            <span class="n">metadata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="n">metadata</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Missing data dimensions for multi-valued </span><span class="si">{}</span><span class="s2"> </span><span class="si">{!r}</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metadata</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">metadata</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_dims</span>

    <span class="k">def</span> <span class="nf">_add_unique_aux_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">):</span>
        <span class="n">data_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_multi_dim_metadata</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coord</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">))</span>

<div class="viewcode-block" id="Cube.add_aux_factory"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.add_aux_factory">[docs]</a>    <span class="k">def</span> <span class="nf">add_aux_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aux_factory</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an auxiliary coordinate factory to the cube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * aux_factory</span>
<span class="sd">            The :class:`iris.aux_factory.AuxCoordFactory` instance to add.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aux_factory</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">aux_factory</span><span class="o">.</span><span class="n">AuxCoordFactory</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Factory must be a subclass of &quot;</span>
                <span class="s2">&quot;iris.aux_factory.AuxCoordFactory.&quot;</span>
            <span class="p">)</span>
        <span class="n">cube_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dependency</span> <span class="ow">in</span> <span class="n">aux_factory</span><span class="o">.</span><span class="n">dependencies</span><span class="p">:</span>
            <span class="n">ref_coord</span> <span class="o">=</span> <span class="n">aux_factory</span><span class="o">.</span><span class="n">dependencies</span><span class="p">[</span><span class="n">dependency</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ref_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ref_coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cube_coords</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> coordinate for factory is not present on cube </span><span class="si">{}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_coord</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aux_factories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_factory</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cube.add_cell_measure"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.add_cell_measure">[docs]</a>    <span class="k">def</span> <span class="nf">add_cell_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_measure</span><span class="p">,</span> <span class="n">data_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a CF cell measure to the cube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * cell_measure</span>
<span class="sd">            The :class:`iris.coords.CellMeasure`</span>
<span class="sd">            instance to add to the cube.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * data_dims</span>
<span class="sd">            Integer or iterable of integers giving the data dimensions spanned</span>
<span class="sd">            by the coordinate.</span>

<span class="sd">        Raises a ValueError if a cell_measure with identical metadata already</span>
<span class="sd">        exists on the cube.</span>

<span class="sd">        See also</span>
<span class="sd">        :meth:`Cube.remove_cell_measure()&lt;iris.cube.Cube.remove_cell_measure&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measures</span><span class="p">(</span><span class="n">cell_measure</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate cell_measures are not permitted.&quot;</span><span class="p">)</span>
        <span class="n">data_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_multi_dim_metadata</span><span class="p">(</span><span class="n">cell_measure</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cell_measure</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cm_dims</span><span class="p">:</span> <span class="p">(</span><span class="n">cm_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">cm_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Cube.add_ancillary_variable"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.add_ancillary_variable">[docs]</a>    <span class="k">def</span> <span class="nf">add_ancillary_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancillary_variable</span><span class="p">,</span> <span class="n">data_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a CF ancillary variable to the cube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * ancillary_variable</span>
<span class="sd">            The :class:`iris.coords.AncillaryVariable` instance to be added to</span>
<span class="sd">            the cube</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * data_dims</span>
<span class="sd">            Integer or iterable of integers giving the data dimensions spanned</span>
<span class="sd">            by the ancillary variable.</span>

<span class="sd">        Raises a ValueError if an ancillary variable with identical metadata</span>
<span class="sd">        already exists on the cube.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variables</span><span class="p">(</span><span class="n">ancillary_variable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate ancillary variables not permitted&quot;</span><span class="p">)</span>

        <span class="n">data_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_multi_dim_metadata</span><span class="p">(</span>
            <span class="n">ancillary_variable</span><span class="p">,</span> <span class="n">data_dims</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">ancillary_variable</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">av_dims</span><span class="p">:</span> <span class="p">(</span><span class="n">av_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">av_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Cube.add_dim_coord"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.add_dim_coord">[docs]</a>    <span class="k">def</span> <span class="nf">add_dim_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_coord</span><span class="p">,</span> <span class="n">data_dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a CF coordinate to the cube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * dim_coord</span>
<span class="sd">            The :class:`iris.coords.DimCoord` instance to add to the cube.</span>
<span class="sd">        * data_dim</span>
<span class="sd">            Integer giving the data dimension spanned by the coordinate.</span>

<span class="sd">        Raises a ValueError if a coordinate with identical metadata already</span>
<span class="sd">        exists on the cube or if a coord already exists for the</span>
<span class="sd">        given dimension.</span>

<span class="sd">        See also :meth:`Cube.remove_coord()&lt;iris.cube.Cube.remove_coord&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The coordinate already exists on the cube. &quot;</span>
                <span class="s2">&quot;Duplicate coordinates are not permitted.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Check dimension is available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="n">data_dim</span><span class="p">,</span> <span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A dim_coord is already associated with &quot;</span>
                <span class="s2">&quot;dimension </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">data_dim</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_unique_dim_coord</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">,</span> <span class="n">data_dim</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_add_unique_dim_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_coord</span><span class="p">,</span> <span class="n">data_dim</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">AuxCoord</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The dim_coord may not be an AuxCoord instance.&quot;</span><span class="p">)</span>

        <span class="c1"># Convert data_dim to a single integer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_dim</span><span class="p">,</span> <span class="n">Container</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The supplied data dimension must be a&quot;</span> <span class="s2">&quot; single number.&quot;</span>
                <span class="p">)</span>
            <span class="n">data_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data_dim</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data_dim</span><span class="p">)</span>

        <span class="c1"># Check data_dim value is valid</span>
        <span class="k">if</span> <span class="n">data_dim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">data_dim</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The cube does not have the specified dimension &quot;</span>
                <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">data_dim</span>
            <span class="p">)</span>

        <span class="c1"># Check compatibility with the shape of the data</span>
        <span class="k">if</span> <span class="n">dim_coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">data_dim</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unequal lengths. Cube dimension </span><span class="si">{}</span><span class="s2"> =&gt; </span><span class="si">{}</span><span class="s2">; coord </span><span class="si">{!r}</span><span class="s2"> =&gt; </span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">data_dim</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">data_dim</span><span class="p">],</span>
                    <span class="n">dim_coord</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">dim_coord</span><span class="o">.</span><span class="n">points</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dim_coord</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">data_dim</span><span class="p">)))</span>

<div class="viewcode-block" id="Cube.remove_aux_factory"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.remove_aux_factory">[docs]</a>    <span class="k">def</span> <span class="nf">remove_aux_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aux_factory</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the given auxiliary coordinate factory from the cube.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aux_factories</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">aux_factory</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_remove_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">coord_</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coord_</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span>
            <span class="k">if</span> <span class="n">coord_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">coord</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">coord_</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coord_</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span>
            <span class="k">if</span> <span class="n">coord_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">coord</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">aux_factory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">aux_factory</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_aux_factory</span><span class="p">(</span><span class="n">aux_factory</span><span class="p">)</span>

<div class="viewcode-block" id="Cube.remove_coord"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.remove_coord">[docs]</a>    <span class="k">def</span> <span class="nf">remove_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a coordinate from the cube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * coord (string or coord)</span>
<span class="sd">            The (name of the) coordinate to remove from the cube.</span>

<span class="sd">        See also :meth:`Cube.add_dim_coord()&lt;iris.cube.Cube.add_dim_coord&gt;`</span>
<span class="sd">        and :meth:`Cube.add_aux_coord()&lt;iris.cube.Cube.add_aux_coord&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>
            <span class="n">factory</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cube.remove_cell_measure"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.remove_cell_measure">[docs]</a>    <span class="k">def</span> <span class="nf">remove_cell_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_measure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a cell measure from the cube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * cell_measure (string or cell_measure)</span>
<span class="sd">            The (name of the) cell measure to remove from the cube. As either</span>

<span class="sd">            (a) a :attr:`standard_name`, :attr:`long_name`, or</span>
<span class="sd">            :attr:`var_name`. Defaults to value of `default`</span>
<span class="sd">            (which itself defaults to `unknown`) as defined in</span>
<span class="sd">            :class:`iris.common.CFVariableMixin`.</span>

<span class="sd">            (b) a cell_measure instance with metadata equal to that of</span>
<span class="sd">            the desired cell_measures.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the argument given does not represent a valid cell_measure on</span>
<span class="sd">            the cube, an :class:`iris.exceptions.CellMeasureNotFoundError`</span>
<span class="sd">            is raised.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`Cube.add_cell_measure()&lt;iris.cube.Cube.add_cell_measure&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_measure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measure</span><span class="p">(</span><span class="n">cell_measure</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">cell_measure_</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cell_measure_</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span>
            <span class="k">if</span> <span class="n">cell_measure_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">cell_measure</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="Cube.remove_ancillary_variable"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.remove_ancillary_variable">[docs]</a>    <span class="k">def</span> <span class="nf">remove_ancillary_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancillary_variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes an ancillary variable from the cube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * ancillary_variable (string or AncillaryVariable)</span>
<span class="sd">            The (name of the) AncillaryVariable to remove from the cube.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ancillary_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variable</span><span class="p">(</span><span class="n">ancillary_variable</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">ancillary_variable_</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ancillary_variable_</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span>
            <span class="k">if</span> <span class="n">ancillary_variable_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ancillary_variable</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="Cube.replace_coord"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.replace_coord">[docs]</a>    <span class="k">def</span> <span class="nf">replace_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_coord</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the coordinate whose metadata matches the given coordinate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">old_coord</span><span class="p">)</span>
        <span class="n">was_dimensioned</span> <span class="o">=</span> <span class="n">old_coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_coord</span><span class="p">(</span><span class="n">old_coord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">was_dimensioned</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>
            <span class="n">factory</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">old_coord</span><span class="p">,</span> <span class="n">new_coord</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cube.coord_dims"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.coord_dims">[docs]</a>    <span class="k">def</span> <span class="nf">coord_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of the data dimensions relevant to the given</span>
<span class="sd">        coordinate.</span>

<span class="sd">        When searching for the given coordinate in the cube the comparison is</span>
<span class="sd">        made using coordinate metadata equality. Hence the given coordinate</span>
<span class="sd">        instance need not exist on the cube, and may contain different</span>
<span class="sd">        coordinate values.</span>

<span class="sd">        Args:</span>

<span class="sd">        * coord (string or coord)</span>
<span class="sd">            The (name of the) coord to look for.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="c1"># Search for existing coordinate (object) on the cube, faster lookup</span>
        <span class="c1"># than equality - makes no functional difference.</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">dim</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">coord_</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span>
            <span class="k">if</span> <span class="n">coord_</span> <span class="ow">is</span> <span class="n">coord</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">dims</span>
                <span class="k">for</span> <span class="n">coord_</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span>
                <span class="k">if</span> <span class="n">coord_</span> <span class="ow">is</span> <span class="n">coord</span>
            <span class="p">]</span>

        <span class="c1"># Search derived aux coords</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">target_metadata</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">metadata</span>

            <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">factory</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">factory</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">target_metadata</span>

            <span class="n">factories</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aux_factories</span><span class="p">)</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">factory</span><span class="o">.</span><span class="n">derived_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">)</span> <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">factories</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotFoundError</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cube.cell_measure_dims"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.cell_measure_dims">[docs]</a>    <span class="k">def</span> <span class="nf">cell_measure_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_measure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of the data dimensions relevant to the given</span>
<span class="sd">        CellMeasure.</span>

<span class="sd">        * cell_measure</span>
<span class="sd">            The CellMeasure to look for.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Search for existing cell measure (object) on the cube, faster lookup</span>
        <span class="c1"># than equality - makes no functional difference.</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dims</span>
            <span class="k">for</span> <span class="n">cm_</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span>
            <span class="k">if</span> <span class="n">cm_</span> <span class="ow">is</span> <span class="n">cell_measure</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CellMeasureNotFoundError</span><span class="p">(</span><span class="n">cell_measure</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cube.ancillary_variable_dims"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.ancillary_variable_dims">[docs]</a>    <span class="k">def</span> <span class="nf">ancillary_variable_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancillary_variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of the data dimensions relevant to the given</span>
<span class="sd">        AncillaryVariable.</span>

<span class="sd">        * ancillary_variable</span>
<span class="sd">            The AncillaryVariable to look for.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Search for existing ancillary variable (object) on the cube, faster</span>
        <span class="c1"># lookup than equality - makes no functional difference.</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dims</span>
            <span class="k">for</span> <span class="n">av</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span>
            <span class="k">if</span> <span class="n">av</span> <span class="ow">is</span> <span class="n">ancillary_variable</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">AncillaryVariableNotFoundError</span><span class="p">(</span>
                <span class="n">ancillary_variable</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cube.aux_factory"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.aux_factory">[docs]</a>    <span class="k">def</span> <span class="nf">aux_factory</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the single coordinate factory that matches the criteria,</span>
<span class="sd">        or raises an error if not found.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * name</span>
<span class="sd">            If not None, matches against factory.name().</span>
<span class="sd">        * standard_name</span>
<span class="sd">            The CF standard name of the desired coordinate factory.</span>
<span class="sd">            If None, does not check for standard name.</span>
<span class="sd">        * long_name</span>
<span class="sd">            An unconstrained description of the coordinate factory.</span>
<span class="sd">            If None, does not check for long_name.</span>
<span class="sd">        * var_name</span>
<span class="sd">            The netCDF variable name of the desired coordinate factory.</span>
<span class="sd">            If None, does not check for var_name.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the arguments given do not result in precisely 1 coordinate</span>
<span class="sd">            factory being matched, an</span>
<span class="sd">            :class:`iris.exceptions.CoordinateNotFoundError` is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">factories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">factory</span> <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">factories</span> <span class="k">if</span> <span class="n">factory</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">standard_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">factory</span>
                <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">factories</span>
                <span class="k">if</span> <span class="n">factory</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">==</span> <span class="n">standard_name</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">long_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">factory</span>
                <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">factories</span>
                <span class="k">if</span> <span class="n">factory</span><span class="o">.</span><span class="n">long_name</span> <span class="o">==</span> <span class="n">long_name</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">var_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">factory</span>
                <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">factories</span>
                <span class="k">if</span> <span class="n">factory</span><span class="o">.</span><span class="n">var_name</span> <span class="o">==</span> <span class="n">var_name</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factories</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">factory_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">factory</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">factories</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Expected to find exactly one coordinate factory, but &quot;</span>
                <span class="s2">&quot;found </span><span class="si">{}</span><span class="s2">. They were: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">factories</span><span class="p">),</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">factory_names</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">factories</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Expected to find exactly one coordinate factory, but &quot;</span>
                <span class="s2">&quot;found none.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">factories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cube.coords"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_or_coord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">contains_dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coord_system</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dim_coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of coordinates in this cube fitting the given criteria.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * name_or_coord</span>
<span class="sd">            Either</span>

<span class="sd">            (a) a :attr:`standard_name`, :attr:`long_name`, or</span>
<span class="sd">            :attr:`var_name`. Defaults to value of `default`</span>
<span class="sd">            (which itself defaults to `unknown`) as defined in</span>
<span class="sd">            :class:`iris.common.CFVariableMixin`.</span>

<span class="sd">            (b) a coordinate instance with metadata equal to that of</span>
<span class="sd">            the desired coordinates. Accepts either a</span>
<span class="sd">            :class:`iris.coords.DimCoord`, :class:`iris.coords.AuxCoord`,</span>
<span class="sd">            :class:`iris.aux_factory.AuxCoordFactory`,</span>
<span class="sd">            :class:`iris.common.CoordMetadata` or</span>
<span class="sd">            :class:`iris.common.DimCoordMetadata`.</span>
<span class="sd">        * standard_name</span>
<span class="sd">            The CF standard name of the desired coordinate. If None, does not</span>
<span class="sd">            check for standard name.</span>
<span class="sd">        * long_name</span>
<span class="sd">            An unconstrained description of the coordinate. If None, does not</span>
<span class="sd">            check for long_name.</span>
<span class="sd">        * var_name</span>
<span class="sd">            The netCDF variable name of the desired coordinate. If None, does</span>
<span class="sd">            not check for var_name.</span>
<span class="sd">        * attributes</span>
<span class="sd">            A dictionary of attributes desired on the coordinates. If None,</span>
<span class="sd">            does not check for attributes.</span>
<span class="sd">        * axis</span>
<span class="sd">            The desired coordinate axis, see</span>
<span class="sd">            :func:`iris.util.guess_coord_axis`. If None, does not check for</span>
<span class="sd">            axis. Accepts the values &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; and &#39;T&#39; (case-insensitive).</span>
<span class="sd">        * contains_dimension</span>
<span class="sd">            The desired coordinate contains the data dimension. If None, does</span>
<span class="sd">            not check for the dimension.</span>
<span class="sd">        * dimensions</span>
<span class="sd">            The exact data dimensions of the desired coordinate. Coordinates</span>
<span class="sd">            with no data dimension can be found with an empty tuple or list</span>
<span class="sd">            (i.e. ``()`` or ``[]``). If None, does not check for dimensions.</span>
<span class="sd">        * coord_system</span>
<span class="sd">            Whether the desired coordinates have coordinate systems equal to</span>
<span class="sd">            the given coordinate system. If None, no check is done.</span>
<span class="sd">        * dim_coords</span>
<span class="sd">            Set to True to only return coordinates that are the cube&#39;s</span>
<span class="sd">            dimension coordinates. Set to False to only return coordinates</span>
<span class="sd">            that are the cube&#39;s auxiliary and derived coordinates. If None,</span>
<span class="sd">            returns all coordinates.</span>

<span class="sd">        See also :meth:`Cube.coord()&lt;iris.cube.Cube.coord&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name_or_coord</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">name_or_coord</span>

        <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">dim_coords</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="n">coords_and_factories</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim_coords</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="n">coords_and_factories</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_coords</span><span class="p">)</span>
            <span class="n">coords_and_factories</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">coord_</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">standard_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">coord_</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">==</span> <span class="n">standard_name</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">long_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">coord_</span><span class="o">.</span><span class="n">long_name</span> <span class="o">==</span> <span class="n">long_name</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">var_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">coord_</span><span class="o">.</span><span class="n">var_name</span> <span class="o">==</span> <span class="n">var_name</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">guess_axis</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">guess_coord_axis</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">guess_axis</span><span class="p">(</span><span class="n">coord_</span><span class="p">)</span> <span class="o">==</span> <span class="n">axis</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;The attributes keyword was expecting a dictionary &quot;</span>
                    <span class="s2">&quot;type, but got a </span><span class="si">%s</span><span class="s2"> instead.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">attr_filter</span><span class="p">(</span><span class="n">coord_</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">k</span> <span class="ow">in</span> <span class="n">coord_</span><span class="o">.</span><span class="n">attributes</span> <span class="ow">and</span> <span class="n">coord_</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attributes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">attr_filter</span><span class="p">(</span><span class="n">coord_</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">coord_system</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">coord_</span><span class="o">.</span><span class="n">coord_system</span> <span class="o">==</span> <span class="n">coord_system</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="s2">&quot;__class__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">CoordMetadata</span><span class="p">,</span>
                <span class="n">DimCoordMetadata</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="n">target_metadata</span> <span class="o">=</span> <span class="n">coord</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_metadata</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">metadata</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">coord_</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">target_metadata</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">contains_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="n">contains_dimension</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord_</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">Container</span><span class="p">):</span>
                <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimensions</span><span class="p">]</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="n">coords_and_factories</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord_</span>
                <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord_</span><span class="p">)</span> <span class="o">==</span> <span class="n">dimensions</span>
            <span class="p">]</span>

        <span class="c1"># If any factories remain after the above filters we have to make the</span>
        <span class="c1"># coords so they can be returned</span>
        <span class="k">def</span> <span class="nf">extract_coord</span><span class="p">(</span><span class="n">coord_or_factory</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_or_factory</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">aux_factory</span><span class="o">.</span><span class="n">AuxCoordFactory</span><span class="p">):</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">coord_or_factory</span><span class="o">.</span><span class="n">make_coord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_or_factory</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">):</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">coord_or_factory</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Expected Coord or AuxCoordFactory, got &quot;</span> <span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">coord_or_factory</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coord</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">extract_coord</span><span class="p">(</span><span class="n">coord_or_factory</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coord_or_factory</span> <span class="ow">in</span> <span class="n">coords_and_factories</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="Cube.coord"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.coord">[docs]</a>    <span class="k">def</span> <span class="nf">coord</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_or_coord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">contains_dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coord_system</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dim_coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a single coord given the same arguments as :meth:`Cube.coords`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the arguments given do not result in precisely 1 coordinate</span>
<span class="sd">            being matched, an :class:`iris.exceptions.CoordinateNotFoundError`</span>
<span class="sd">            is raised.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`Cube.coords()&lt;iris.cube.Cube.coords&gt;` for full keyword</span>
<span class="sd">            documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span>
            <span class="n">name_or_coord</span><span class="o">=</span><span class="n">name_or_coord</span><span class="p">,</span>
            <span class="n">standard_name</span><span class="o">=</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="n">long_name</span><span class="o">=</span><span class="n">long_name</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">contains_dimension</span><span class="o">=</span><span class="n">contains_dimension</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span>
            <span class="n">coord_system</span><span class="o">=</span><span class="n">coord_system</span><span class="p">,</span>
            <span class="n">dim_coords</span><span class="o">=</span><span class="n">dim_coords</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Expected to find exactly 1 coordinate, but found </span><span class="si">%s</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;They were: </span><span class="si">%s</span><span class="s2">.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_name</span> <span class="o">=</span> <span class="n">name_or_coord</span>
            <span class="k">if</span> <span class="n">name_or_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">_name</span> <span class="o">=</span> <span class="n">name_or_coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="n">bad_name</span> <span class="o">=</span> <span class="n">_name</span> <span class="ow">or</span> <span class="n">standard_name</span> <span class="ow">or</span> <span class="n">long_name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Expected to find exactly 1 </span><span class="si">%s</span><span class="s2"> coordinate, but found &quot;</span>
                <span class="s2">&quot;none.&quot;</span> <span class="o">%</span> <span class="n">bad_name</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cube.coord_system"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.coord_system">[docs]</a>    <span class="k">def</span> <span class="nf">coord_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the coordinate system of the given type.</span>

<span class="sd">        If no target coordinate system is provided then find</span>
<span class="sd">        any available coordinate system.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * spec:</span>
<span class="sd">            The the name or type of a coordinate system subclass.</span>
<span class="sd">            E.g. ::</span>

<span class="sd">                cube.coord_system(&quot;GeogCS&quot;)</span>
<span class="sd">                cube.coord_system(iris.coord_systems.GeogCS)</span>

<span class="sd">            If spec is provided as a type it can be a superclass of</span>
<span class="sd">            any coordinate system found.</span>

<span class="sd">            If spec is None, then find any available coordinate</span>
<span class="sd">            systems within the :class:`iris.cube.Cube`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The :class:`iris.coord_systems.CoordSystem` or None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spec_name</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;type </span><span class="si">%s</span><span class="s2"> is not a subclass of CoordSystem&quot;</span> <span class="o">%</span> <span class="n">spec</span>
            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coord_systems</span><span class="o">.</span><span class="n">CoordSystem</span><span class="p">),</span> <span class="n">msg</span>
            <span class="n">spec_name</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Gather a temporary list of our unique CoordSystems.</span>
        <span class="n">coord_systems</span> <span class="o">=</span> <span class="n">ClassDict</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">coord_systems</span><span class="o">.</span><span class="n">CoordSystem</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">coord_system</span><span class="p">:</span>
                <span class="n">coord_systems</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">coord_system</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">spec_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">coord_systems</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">class_</span><span class="p">:</span> <span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">coord_systems</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">coord_systems</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spec_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Cube.cell_measures"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.cell_measures">[docs]</a>    <span class="k">def</span> <span class="nf">cell_measures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_cell_measure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of cell measures in this cube fitting the given criteria.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * name_or_cell_measure</span>
<span class="sd">            Either</span>

<span class="sd">            (a) a :attr:`standard_name`, :attr:`long_name`, or</span>
<span class="sd">            :attr:`var_name`. Defaults to value of `default`</span>
<span class="sd">            (which itself defaults to `unknown`) as defined in</span>
<span class="sd">            :class:`iris.common.CFVariableMixin`.</span>

<span class="sd">            (b) a cell_measure instance with metadata equal to that of</span>
<span class="sd">            the desired cell_measures.</span>

<span class="sd">        See also :meth:`Cube.cell_measure()&lt;iris.cube.Cube.cell_measure&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_cell_measure</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name_or_cell_measure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell_measure</span> <span class="o">=</span> <span class="n">name_or_cell_measure</span>
        <span class="n">cell_measures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cm</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">cell_measures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cell_measure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cm</span> <span class="o">==</span> <span class="n">cell_measure</span><span class="p">:</span>
                    <span class="n">cell_measures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_measures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cell_measures</span></div>

<div class="viewcode-block" id="Cube.cell_measure"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.cell_measure">[docs]</a>    <span class="k">def</span> <span class="nf">cell_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_cell_measure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a single cell_measure given the same arguments as</span>
<span class="sd">        :meth:`Cube.cell_measures`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the arguments given do not result in precisely 1 cell_measure</span>
<span class="sd">            being matched, an :class:`iris.exceptions.CellMeasureNotFoundError`</span>
<span class="sd">            is raised.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`Cube.cell_measures()&lt;iris.cube.Cube.cell_measures&gt;`</span>
<span class="sd">            for full keyword documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_measures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measures</span><span class="p">(</span><span class="n">name_or_cell_measure</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_measures</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Expected to find exactly 1 cell_measure, but found </span><span class="si">{}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;They were: </span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">cell_measures</span><span class="p">),</span>
                <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">cell_measures</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CellMeasureNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_measures</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_cell_measure</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">bad_name</span> <span class="o">=</span> <span class="n">name_or_cell_measure</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bad_name</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">name_or_cell_measure</span> <span class="ow">and</span> <span class="n">name_or_cell_measure</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                <span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Expected to find exactly 1 </span><span class="si">%s</span><span class="s2"> cell_measure, but found &quot;</span>
                <span class="s2">&quot;none.&quot;</span> <span class="o">%</span> <span class="n">bad_name</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CellMeasureNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cell_measures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cube.ancillary_variables"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.ancillary_variables">[docs]</a>    <span class="k">def</span> <span class="nf">ancillary_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_ancillary_variable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of ancillary variable in this cube fitting the given</span>
<span class="sd">        criteria.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * name_or_ancillary_variable</span>
<span class="sd">            Either</span>

<span class="sd">            (a) a :attr:`standard_name`, :attr:`long_name`, or</span>
<span class="sd">            :attr:`var_name`. Defaults to value of `default`</span>
<span class="sd">            (which itself defaults to `unknown`) as defined in</span>
<span class="sd">            :class:`iris.common.CFVariableMixin`.</span>

<span class="sd">            (b) a ancillary_variable instance with metadata equal to that of</span>
<span class="sd">            the desired ancillary_variables.</span>

<span class="sd">        See also</span>
<span class="sd">        :meth:`Cube.ancillary_variable()&lt;iris.cube.Cube.ancillary_variable&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_ancillary_variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name_or_ancillary_variable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ancillary_variable</span> <span class="o">=</span> <span class="n">name_or_ancillary_variable</span>
        <span class="n">ancillary_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">av</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">av</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">ancillary_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">av</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ancillary_variable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">av</span> <span class="o">==</span> <span class="n">ancillary_variable</span><span class="p">:</span>
                    <span class="n">ancillary_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">av</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ancillary_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">av</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ancillary_variables</span></div>

<div class="viewcode-block" id="Cube.ancillary_variable"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.ancillary_variable">[docs]</a>    <span class="k">def</span> <span class="nf">ancillary_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_ancillary_variable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a single ancillary_variable given the same arguments as</span>
<span class="sd">        :meth:`Cube.ancillary_variables`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the arguments given do not result in precisely 1</span>
<span class="sd">            ancillary_variable being matched, an</span>
<span class="sd">            :class:`iris.exceptions.AncillaryVariableNotFoundError` is raised.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`Cube.ancillary_variables()&lt;iris.cube.Cube.ancillary_variables&gt;`</span>
<span class="sd">            for full keyword documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ancillary_variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variables</span><span class="p">(</span>
            <span class="n">name_or_ancillary_variable</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillary_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Expected to find exactly 1 ancillary_variable, but found &quot;</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">. They were: </span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">ancillary_variables</span><span class="p">),</span>
                <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">anc_var</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">anc_var</span> <span class="ow">in</span> <span class="n">ancillary_variables</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">AncillaryVariableNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancillary_variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_ancillary_variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">bad_name</span> <span class="o">=</span> <span class="n">name_or_ancillary_variable</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bad_name</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">name_or_ancillary_variable</span>
                    <span class="ow">and</span> <span class="n">name_or_ancillary_variable</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                <span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Expected to find exactly 1 </span><span class="si">{!s}</span><span class="s2"> ancillary_variable, but &quot;</span>
                <span class="s2">&quot;found none.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bad_name</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">AncillaryVariableNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ancillary_variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tuple of :class:`iris.coords.CellMethod` representing the processing</span>
<span class="sd">        done on the phenomenon.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">cell_methods</span>

    <span class="nd">@cell_methods</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cell_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell_methods</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">cell_methods</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">cell_methods</span><span class="p">)</span> <span class="k">if</span> <span class="n">cell_methods</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Cube.core_data"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.core_data">[docs]</a>    <span class="k">def</span> <span class="nf">core_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the data array of this :class:`~iris.cube.Cube` in its</span>
<span class="sd">        current state, which will either be real or lazy.</span>

<span class="sd">        If this :class:`~iris.cube.Cube` has lazy data, accessing its data</span>
<span class="sd">        array via this method **will not** realise the data array. This means</span>
<span class="sd">        you can perform operations using this method that work equivalently</span>
<span class="sd">        on real or lazy data, and will maintain lazy data if present.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The shape of the data of this cube.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The data type of the values in the data array of this</span>
<span class="sd">        :class:`~iris.cube.Cube`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of dimensions in the data of this cube.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">ndim</span>

<div class="viewcode-block" id="Cube.lazy_data"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.lazy_data">[docs]</a>    <span class="k">def</span> <span class="nf">lazy_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a &quot;lazy array&quot; representing the Cube data. A lazy array</span>
<span class="sd">        describes an array whose data values have not been loaded into memory</span>
<span class="sd">        from disk.</span>

<span class="sd">        Accessing this method will never cause the Cube data to be loaded.</span>
<span class="sd">        Similarly, calling methods on, or indexing, the returned Array</span>
<span class="sd">        will not cause the Cube data to be loaded.</span>

<span class="sd">        If the Cube data have already been loaded (for example by calling</span>
<span class="sd">        :meth:`~iris.cube.Cube.data`), the returned Array will be a view of the</span>
<span class="sd">        loaded cube data represented as a lazy array object. Note that this</span>
<span class="sd">        does _not_ make the Cube data lazy again; the Cube data remains loaded</span>
<span class="sd">        in memory.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A lazy array, representing the Cube data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`numpy.ndarray` representing the multi-dimensional data of</span>
<span class="sd">        the cube.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Cubes obtained from netCDF, PP, and FieldsFile files will only</span>
<span class="sd">            populate this attribute on its first use.</span>

<span class="sd">            To obtain the shape of the data without causing it to be loaded,</span>
<span class="sd">            use the Cube.shape attribute.</span>

<span class="sd">        Example::</span>
<span class="sd">            &gt;&gt;&gt; fname = iris.sample_data_path(&#39;air_temp.pp&#39;)</span>
<span class="sd">            &gt;&gt;&gt; cube = iris.load_cube(fname, &#39;air_temperature&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # cube.data does not yet have a value.</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; print(cube.shape)</span>
<span class="sd">            (73, 96)</span>
<span class="sd">            &gt;&gt;&gt; # cube.data still does not have a value.</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; cube = cube[:10, :20]</span>
<span class="sd">            &gt;&gt;&gt; # cube.data still does not have a value.</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; data = cube.data</span>
<span class="sd">            &gt;&gt;&gt; # Only now is the data loaded.</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; print(data.shape)</span>
<span class="sd">            (10, 20)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

<div class="viewcode-block" id="Cube.has_lazy_data"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.has_lazy_data">[docs]</a>    <span class="k">def</span> <span class="nf">has_lazy_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Details whether this :class:`~iris.cube.Cube` has lazy data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of all the dimension coordinates, ordered by dimension.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The length of the returned tuple is not necessarily the same as</span>
<span class="sd">            :attr:`Cube.ndim` as there may be dimensions on the cube without</span>
<span class="sd">            dimension coordinates. It is therefore unreliable to use the</span>
<span class="sd">            resulting tuple to identify the dimension coordinates for a given</span>
<span class="sd">            dimension - instead use the :meth:`Cube.coord` method with the</span>
<span class="sd">            ``dimensions`` and ``dim_coords`` keyword arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">coord</span>
                <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">co_di</span><span class="p">:</span> <span class="p">(</span><span class="n">co_di</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">co_di</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">()),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aux_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of all the auxiliary coordinates, ordered by</span>
<span class="sd">        dimension(s).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">coord</span>
                <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">dims</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">co_di</span><span class="p">:</span> <span class="p">(</span><span class="n">co_di</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">co_di</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">()),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">derived_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of all the coordinates generated by the coordinate</span>
<span class="sd">        factories.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">factory</span><span class="o">.</span><span class="n">make_coord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">factory</span><span class="p">:</span> <span class="n">factory</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aux_factories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of all the coordinate factories.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aux_factories</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_summary_coord_extra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
        <span class="c1"># Returns the text needed to ensure this coordinate can be</span>
        <span class="c1"># distinguished from all others with the same name.</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">similar_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">similar_coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Find all the attribute keys</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">similar_coord</span> <span class="ow">in</span> <span class="n">similar_coords</span><span class="p">:</span>
                <span class="n">keys</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">similar_coord</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="c1"># Look for any attributes that vary</span>
            <span class="n">vary</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">similar_coord</span> <span class="ow">in</span> <span class="n">similar_coords</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">similar_coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
                        <span class="n">vary</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">similar_coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">attributes</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                        <span class="n">vary</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vary</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">=</span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">bits</span><span class="p">:</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">extra</span>

    <span class="k">def</span> <span class="nf">_summary_extra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">summary</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
        <span class="c1"># Where necessary, inserts extra lines into the summary to ensure</span>
        <span class="c1"># coordinates can be distinguished.</span>
        <span class="n">new_summary</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">summary</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">summary</span><span class="p">):</span>
            <span class="n">new_summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span>
            <span class="n">extra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary_coord_extra</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">extra</span><span class="p">:</span>
                <span class="n">new_summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_summary</span>

<div class="viewcode-block" id="Cube.summary"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shorten</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name_padding</span><span class="o">=</span><span class="mi">35</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unicode string summary of the Cube with name, a list of dim coord names</span>
<span class="sd">        versus length and optionally relevant coordinate information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a set to contain the axis names for each data dimension.</span>
        <span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>

        <span class="c1"># Add the dim_coord names that participate in the associated data</span>
        <span class="c1"># dimensions.</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
            <span class="n">dim_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">contains_dimension</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim_coords</span><span class="p">:</span>
                <span class="n">dim_names</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dim_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dim_names</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;-- &quot;</span><span class="p">)</span>

        <span class="c1"># Convert axes sets to lists and sort.</span>
        <span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sorted_axes</span><span class="p">)</span> <span class="k">for</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">dim_names</span><span class="p">]</span>

        <span class="c1"># Generate textual summary of the cube dimensionality.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="n">dimension_header</span> <span class="o">=</span> <span class="s2">&quot;scalar cube&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimension_header</span> <span class="o">=</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dim_names</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dim_shape</span>
                    <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim_shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="n">nameunit</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{name}</span><span class="s2"> / (</span><span class="si">{units}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span>
        <span class="p">)</span>
        <span class="n">cube_header</span> <span class="o">=</span> <span class="s2">&quot;{nameunit!s:</span><span class="si">{length}</span><span class="s2">} (</span><span class="si">{dimension}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">length</span><span class="o">=</span><span class="n">name_padding</span><span class="p">,</span> <span class="n">nameunit</span><span class="o">=</span><span class="n">nameunit</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension_header</span>
        <span class="p">)</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Generate full cube textual summary.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">shorten</span><span class="p">:</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">extra_indent</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">13</span>

            <span class="c1"># Cache the derived coords so we can rely on consistent</span>
            <span class="c1"># object IDs.</span>
            <span class="n">derived_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_coords</span>
            <span class="c1"># Determine the cube coordinates that are scalar (single-valued)</span>
            <span class="c1"># AND non-dimensioned.</span>
            <span class="n">dim_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_coords</span>
            <span class="n">aux_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_coords</span>
            <span class="n">all_coords</span> <span class="o">=</span> <span class="n">dim_coords</span> <span class="o">+</span> <span class="n">aux_coords</span> <span class="o">+</span> <span class="n">derived_coords</span>
            <span class="n">scalar_coords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">all_coords</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="p">]</span>
            <span class="c1"># Determine the cube coordinates that are not scalar BUT</span>
            <span class="c1"># dimensioned.</span>
            <span class="n">scalar_coord_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">scalar_coords</span><span class="p">))</span>
            <span class="n">vector_dim_coords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">dim_coords</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scalar_coord_ids</span>
            <span class="p">]</span>
            <span class="n">vector_aux_coords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">aux_coords</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scalar_coord_ids</span>
            <span class="p">]</span>
            <span class="n">vector_derived_coords</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">derived_coords</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scalar_coord_ids</span>
            <span class="p">]</span>

            <span class="c1"># cell measures</span>
            <span class="n">vector_cell_measures</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">cm</span> <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measures</span><span class="p">()</span> <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="p">]</span>

            <span class="c1"># Ancillary Variables</span>
            <span class="n">vector_ancillary_variables</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">av</span> <span class="k">for</span> <span class="n">av</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variables</span><span class="p">()</span>
            <span class="p">]</span>

            <span class="c1"># Sort scalar coordinates by name.</span>
            <span class="n">scalar_coords</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="c1"># Sort vector coordinates by data dimension and name.</span>
            <span class="n">vector_dim_coords</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">),</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">vector_aux_coords</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">),</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">vector_derived_coords</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">),</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Generate textual summary of cube vector coordinates.</span>
            <span class="c1">#</span>
            <span class="k">def</span> <span class="nf">vector_summary</span><span class="p">(</span>
                <span class="n">vector_coords</span><span class="p">,</span>
                <span class="n">cube_header</span><span class="p">,</span>
                <span class="n">max_line_offset</span><span class="p">,</span>
                <span class="n">cell_measures</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">ancillary_variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Generates a list of suitably aligned strings containing coord</span>
<span class="sd">                names and dimensions indicated by one or more &#39;x&#39; symbols.</span>

<span class="sd">                .. note::</span>

<span class="sd">                    The function may need to update the cube header so this is</span>
<span class="sd">                    returned with the list of strings.</span>

<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">cell_measures</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cell_measures</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">ancillary_variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ancillary_variables</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">vector_summary</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">vectors</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Identify offsets for each dimension text marker.</span>
                <span class="n">alignment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">index</span>
                        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cube_header</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;:&quot;</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="c1"># Generate basic textual summary for each vector coordinate</span>
                <span class="c1"># - WITHOUT dimension markers.</span>
                <span class="k">for</span> <span class="n">dim_meta</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="n">vector_coords</span> <span class="o">+</span> <span class="n">cell_measures</span> <span class="o">+</span> <span class="n">ancillary_variables</span>
                <span class="p">):</span>
                    <span class="n">vector_summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%*s%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">clip_string</span><span class="p">(</span><span class="n">dim_meta</span><span class="o">.</span><span class="n">name</span><span class="p">()))</span>
                    <span class="p">)</span>
                <span class="n">min_alignment</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>

                <span class="c1"># Determine whether the cube header requires realignment</span>
                <span class="c1"># due to one or more longer vector coordinate summaries.</span>
                <span class="k">if</span> <span class="n">max_line_offset</span> <span class="o">&gt;=</span> <span class="n">min_alignment</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">max_line_offset</span> <span class="o">-</span> <span class="n">min_alignment</span> <span class="o">+</span> <span class="mi">5</span>
                    <span class="n">cube_header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%-*s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">name_padding</span> <span class="o">+</span> <span class="n">delta</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="ow">or</span> <span class="s2">&quot;unknown&quot;</span><span class="p">,</span>
                        <span class="n">dimension_header</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">alignment</span> <span class="o">+=</span> <span class="n">delta</span>

                <span class="k">if</span> <span class="n">vector_coords</span><span class="p">:</span>
                    <span class="c1"># Generate full textual summary for each vector coordinate</span>
                    <span class="c1"># - WITH dimension markers.</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vector_coords</span><span class="p">):</span>
                        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                            <span class="n">width</span> <span class="o">=</span> <span class="n">alignment</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector_summary</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                            <span class="n">char</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">else</span> <span class="s2">&quot;-&quot;</span>
                            <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;{pad:</span><span class="si">{width}</span><span class="s2">}</span><span class="si">{char}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">pad</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">char</span><span class="o">=</span><span class="n">char</span>
                            <span class="p">)</span>
                            <span class="n">vector_summary</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">line</span>
                    <span class="n">vectors</span> <span class="o">=</span> <span class="n">vectors</span> <span class="o">+</span> <span class="n">vector_coords</span>
                <span class="k">if</span> <span class="n">cell_measures</span><span class="p">:</span>
                    <span class="c1"># Generate full textual summary for each vector cell</span>
                    <span class="c1"># measure - WITH dimension markers.</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">cell_measure</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cell_measures</span><span class="p">):</span>
                        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measure_dims</span><span class="p">(</span><span class="n">cell_measure</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                            <span class="n">width</span> <span class="o">=</span> <span class="n">alignment</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector_summary</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                            <span class="n">char</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">else</span> <span class="s2">&quot;-&quot;</span>
                            <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;{pad:</span><span class="si">{width}</span><span class="s2">}</span><span class="si">{char}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">pad</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">char</span><span class="o">=</span><span class="n">char</span>
                            <span class="p">)</span>
                            <span class="n">vector_summary</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">line</span>
                    <span class="n">vectors</span> <span class="o">=</span> <span class="n">vectors</span> <span class="o">+</span> <span class="n">cell_measures</span>
                <span class="k">if</span> <span class="n">ancillary_variables</span><span class="p">:</span>
                    <span class="c1"># Generate full textual summary for each vector ancillary</span>
                    <span class="c1"># variable - WITH dimension markers.</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">av</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ancillary_variables</span><span class="p">):</span>
                        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variable_dims</span><span class="p">(</span><span class="n">av</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                            <span class="n">width</span> <span class="o">=</span> <span class="n">alignment</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector_summary</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                            <span class="n">char</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">else</span> <span class="s2">&quot;-&quot;</span>
                            <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;{pad:</span><span class="si">{width}</span><span class="s2">}</span><span class="si">{char}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">pad</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">char</span><span class="o">=</span><span class="n">char</span>
                            <span class="p">)</span>
                            <span class="n">vector_summary</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">line</span>
                    <span class="n">vectors</span> <span class="o">=</span> <span class="n">vectors</span> <span class="o">+</span> <span class="n">ancillary_variables</span>
                <span class="c1"># Interleave any extra lines that are needed to distinguish</span>
                <span class="c1"># the coordinates.</span>
                <span class="n">vector_summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary_extra</span><span class="p">(</span>
                    <span class="n">vectors</span><span class="p">,</span> <span class="n">vector_summary</span><span class="p">,</span> <span class="n">extra_indent</span>
                <span class="p">)</span>

                <span class="k">return</span> <span class="n">vector_summary</span><span class="p">,</span> <span class="n">cube_header</span>

            <span class="c1"># Calculate the maximum line offset.</span>
            <span class="n">max_line_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">all_coords</span><span class="p">:</span>
                <span class="n">max_line_offset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="n">max_line_offset</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%*s%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span>
                            <span class="n">indent</span><span class="p">,</span>
                            <span class="s2">&quot; &quot;</span><span class="p">,</span>
                            <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">clip_string</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())),</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">vector_dim_coords</span><span class="p">:</span>
                <span class="n">dim_coord_summary</span><span class="p">,</span> <span class="n">cube_header</span> <span class="o">=</span> <span class="n">vector_summary</span><span class="p">(</span>
                    <span class="n">vector_dim_coords</span><span class="p">,</span> <span class="n">cube_header</span><span class="p">,</span> <span class="n">max_line_offset</span>
                <span class="p">)</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Dimension coordinates:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">dim_coord_summary</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">vector_aux_coords</span><span class="p">:</span>
                <span class="n">aux_coord_summary</span><span class="p">,</span> <span class="n">cube_header</span> <span class="o">=</span> <span class="n">vector_summary</span><span class="p">(</span>
                    <span class="n">vector_aux_coords</span><span class="p">,</span> <span class="n">cube_header</span><span class="p">,</span> <span class="n">max_line_offset</span>
                <span class="p">)</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Auxiliary coordinates:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">aux_coord_summary</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">vector_derived_coords</span><span class="p">:</span>
                <span class="n">derived_coord_summary</span><span class="p">,</span> <span class="n">cube_header</span> <span class="o">=</span> <span class="n">vector_summary</span><span class="p">(</span>
                    <span class="n">vector_derived_coords</span><span class="p">,</span> <span class="n">cube_header</span><span class="p">,</span> <span class="n">max_line_offset</span>
                <span class="p">)</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Derived coordinates:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">derived_coord_summary</span>
                <span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Generate summary of cube cell measures attribute</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="n">vector_cell_measures</span><span class="p">:</span>
                <span class="n">cell_measure_summary</span><span class="p">,</span> <span class="n">cube_header</span> <span class="o">=</span> <span class="n">vector_summary</span><span class="p">(</span>
                    <span class="p">[],</span>
                    <span class="n">cube_header</span><span class="p">,</span>
                    <span class="n">max_line_offset</span><span class="p">,</span>
                    <span class="n">cell_measures</span><span class="o">=</span><span class="n">vector_cell_measures</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Cell measures:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cell_measure_summary</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Generate summary of cube ancillary variables attribute</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="n">vector_ancillary_variables</span><span class="p">:</span>
                <span class="n">ancillary_variable_summary</span><span class="p">,</span> <span class="n">cube_header</span> <span class="o">=</span> <span class="n">vector_summary</span><span class="p">(</span>
                    <span class="p">[],</span>
                    <span class="n">cube_header</span><span class="p">,</span>
                    <span class="n">max_line_offset</span><span class="p">,</span>
                    <span class="n">ancillary_variables</span><span class="o">=</span><span class="n">vector_ancillary_variables</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Ancillary variables:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ancillary_variable_summary</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Generate textual summary of cube scalar coordinates.</span>
            <span class="c1">#</span>
            <span class="n">scalar_summary</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">scalar_coords</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">scalar_coords</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">coord</span><span class="o">.</span><span class="n">units</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;no_unit&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">]</span>
                        <span class="ow">or</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">()</span>
                    <span class="p">):</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="si">{!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

                    <span class="c1"># Format cell depending on type of point and whether it</span>
                    <span class="c1"># has a bound.</span>
                    <span class="n">coord_cell</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_cell</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="c1"># Indent string type coordinates</span>
                        <span class="n">coord_cell_split</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">clip_string</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">coord_cell</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="p">]</span>
                        <span class="n">line_sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">{pad:</span><span class="si">{width}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">pad</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">indent</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span> <span class="o">+</span> <span class="mi">2</span>
                        <span class="p">)</span>
                        <span class="n">coord_cell_str</span> <span class="o">=</span> <span class="n">line_sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">coord_cell_split</span><span class="p">)</span> <span class="o">+</span> <span class="n">unit</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">coord_cell_cpoint</span> <span class="o">=</span> <span class="n">coord_cell</span><span class="o">.</span><span class="n">point</span>
                        <span class="n">coord_cell_cbound</span> <span class="o">=</span> <span class="n">coord_cell</span><span class="o">.</span><span class="n">bound</span>

                        <span class="n">coord_cell_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{!s}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">coord_cell_cpoint</span><span class="p">,</span> <span class="n">unit</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">coord_cell_cbound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">bound</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">coord_cell_cbound</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">coord_cell_str</span> <span class="o">+=</span> <span class="s2">&quot;, bound=</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">bound</span><span class="p">,</span> <span class="n">unit</span>
                            <span class="p">)</span>

                    <span class="n">scalar_summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;{pad:</span><span class="si">{width}</span><span class="s2">}</span><span class="si">{name}</span><span class="s2">: </span><span class="si">{cell}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">pad</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span>
                            <span class="n">width</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span>
                            <span class="n">cell</span><span class="o">=</span><span class="n">coord_cell_str</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># Interleave any extra lines that are needed to distinguish</span>
                <span class="c1"># the coordinates.</span>
                <span class="n">scalar_summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_summary_extra</span><span class="p">(</span>
                    <span class="n">scalar_coords</span><span class="p">,</span> <span class="n">scalar_summary</span><span class="p">,</span> <span class="n">extra_indent</span>
                <span class="p">)</span>

                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Scalar coordinates:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">scalar_summary</span>
                <span class="p">)</span>

            <span class="c1"># cell measures</span>
            <span class="n">scalar_cell_measures</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">cm</span> <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measures</span><span class="p">()</span> <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">scalar_cell_measures</span><span class="p">:</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Scalar cell measures:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">scalar_cms</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;          </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">scalar_cell_measures</span>
                <span class="p">]</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scalar_cms</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Generate summary of cube attributes.</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
                <span class="n">attribute_lines</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">clip_string</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;{pad:</span><span class="si">{width}</span><span class="s2">}</span><span class="si">{name}</span><span class="s2">: </span><span class="si">{value}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">pad</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span>
                    <span class="p">)</span>
                    <span class="n">attribute_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Attributes:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attribute_lines</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Generate summary of cube cell methods</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_methods</span><span class="p">:</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">     Cell methods:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">cm_lines</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_methods</span><span class="p">:</span>
                    <span class="n">cm_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%*s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cm</span><span class="p">)))</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cm_lines</span><span class="p">)</span>

        <span class="c1"># Construct the final cube summary.</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="n">cube_header</span> <span class="o">+</span> <span class="n">summary</span>

        <span class="k">return</span> <span class="n">summary</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;iris &#39;Cube&#39; of </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span>
            <span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name_padding</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">iris.experimental.representation</span> <span class="kn">import</span> <span class="n">CubeRepresentation</span>

        <span class="n">representer</span> <span class="o">=</span> <span class="n">CubeRepresentation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">representer</span><span class="o">.</span><span class="n">repr_html</span><span class="p">()</span>

    <span class="c1"># Indicate that the iter option is not available. Python will raise</span>
    <span class="c1"># TypeError with a useful message if a Cube is iterated over.</span>
    <span class="fm">__iter__</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Cube.__getitem__"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cube indexing (through use of square bracket notation) has been</span>
<span class="sd">        implemented at the data level. That is, the indices provided to this</span>
<span class="sd">        method should be aligned to the data of the cube, and thus the indices</span>
<span class="sd">        requested must be applicable directly to the cube.data attribute. All</span>
<span class="sd">        metadata will be subsequently indexed appropriately.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># turn the keys into a full slice spec (all dims)</span>
        <span class="n">full_slice</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_build_full_slice_given_keys</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">new_coord_dims</span><span class="p">(</span><span class="n">coord_</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">dimension_mapping</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord_</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dimension_mapping</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>

        <span class="k">def</span> <span class="nf">new_cell_measure_dims</span><span class="p">(</span><span class="n">cm_</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">dimension_mapping</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measure_dims</span><span class="p">(</span><span class="n">cm_</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dimension_mapping</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>

        <span class="k">def</span> <span class="nf">new_ancillary_variable_dims</span><span class="p">(</span><span class="n">av_</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">dimension_mapping</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variable_dims</span><span class="p">(</span><span class="n">av_</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dimension_mapping</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>

        <span class="c1"># Fetch the data as a generic array-like object.</span>
        <span class="n">cube_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>

        <span class="c1"># Index with the keys, using orthogonal slicing.</span>
        <span class="n">dimension_mapping</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_slice_data_with_keys</span><span class="p">(</span>
            <span class="n">cube_data</span><span class="p">,</span> <span class="n">keys</span>
        <span class="p">)</span>

        <span class="c1"># We don&#39;t want a view of the data, so take a copy of it.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># XXX: Slicing a single item from a masked array that is masked,</span>
        <span class="c1">#      results in numpy (v1.11.1) *always* returning a MaskedConstant</span>
        <span class="c1">#      with a dtype of float64, regardless of the original masked</span>
        <span class="c1">#      array dtype!</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedConstant</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">cube_data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cube_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Make the new cube slice</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="n">Cube</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>

        <span class="c1"># Record a mapping from old coordinate IDs to new coordinates,</span>
        <span class="c1"># for subsequent use in creating updated aux_factories.</span>
        <span class="n">coord_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Slice the coords</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_coords</span><span class="p">:</span>
            <span class="n">coord_keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">full_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_coord</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="n">coord_keys</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># TODO make this except more specific to catch monotonic error</span>
                <span class="c1"># Attempt to slice it by converting to AuxCoord first</span>
                <span class="n">new_coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">AuxCoord</span><span class="o">.</span><span class="n">from_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)[</span><span class="n">coord_keys</span><span class="p">]</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">new_coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
            <span class="n">coord_mapping</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">coord</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_coord</span>

        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">:</span>
            <span class="n">coord_keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">full_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">new_dims</span> <span class="o">=</span> <span class="n">new_coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="c1"># Try/Catch to handle slicing that makes the points/bounds</span>
            <span class="c1"># non-monotonic</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_coord</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="n">coord_keys</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_dims</span><span class="p">:</span>
                    <span class="c1"># If the associated dimension has been sliced so the coord</span>
                    <span class="c1"># is a scalar move the coord to the aux_coords container</span>
                    <span class="n">cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">new_dims</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cube</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">new_dims</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># TODO make this except more specific to catch monotonic error</span>
                <span class="c1"># Attempt to slice it by converting to AuxCoord first</span>
                <span class="n">new_coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">AuxCoord</span><span class="o">.</span><span class="n">from_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)[</span><span class="n">coord_keys</span><span class="p">]</span>
                <span class="n">cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">new_dims</span><span class="p">)</span>
            <span class="n">coord_mapping</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">coord</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_coord</span>

        <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">add_aux_factory</span><span class="p">(</span><span class="n">factory</span><span class="o">.</span><span class="n">updated</span><span class="p">(</span><span class="n">coord_mapping</span><span class="p">))</span>

        <span class="c1"># slice the cell measures and add them to the cube</span>
        <span class="k">for</span> <span class="n">cellmeasure</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measures</span><span class="p">():</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measure_dims</span><span class="p">(</span><span class="n">cellmeasure</span><span class="p">)</span>
            <span class="n">cm_keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">full_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
            <span class="n">new_cm</span> <span class="o">=</span> <span class="n">cellmeasure</span><span class="p">[</span><span class="n">cm_keys</span><span class="p">]</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">add_cell_measure</span><span class="p">(</span><span class="n">new_cm</span><span class="p">,</span> <span class="n">new_cell_measure_dims</span><span class="p">(</span><span class="n">cellmeasure</span><span class="p">))</span>

        <span class="c1"># slice the ancillary variables and add them to the cube</span>
        <span class="k">for</span> <span class="n">ancvar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variables</span><span class="p">():</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variable_dims</span><span class="p">(</span><span class="n">ancvar</span><span class="p">)</span>
            <span class="n">av_keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">full_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])</span>
            <span class="n">new_av</span> <span class="o">=</span> <span class="n">ancvar</span><span class="p">[</span><span class="n">av_keys</span><span class="p">]</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">add_ancillary_variable</span><span class="p">(</span>
                <span class="n">new_av</span><span class="p">,</span> <span class="n">new_ancillary_variable_dims</span><span class="p">(</span><span class="n">ancvar</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">cube</span></div>

<div class="viewcode-block" id="Cube.subset"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.subset">[docs]</a>    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a subset of the cube by providing the desired resultant</span>
<span class="sd">        coordinate. If the coordinate provided applies to the whole cube; the</span>
<span class="sd">        whole cube is returned. As such, the operation is not strict.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;coord_to_extract must be a valid Coord.&quot;</span><span class="p">)</span>

        <span class="c1"># Get the coord to extract from the cube</span>
        <span class="n">coord_to_extract</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="c1"># If scalar, return the whole cube. Not possible to subset 1 point.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">coord_to_extract</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_coords</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_to_extract</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">):</span>

            <span class="c1"># Default to returning None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">coord_to_extract</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># If there is an intersect between the two scalar coordinates;</span>
            <span class="c1"># return the whole cube. Else, return None.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord_to_extract</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Currently, only 1D coords can be used to subset a cube&quot;</span>
                <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># Identify the dimension of the cube which this coordinate</span>
            <span class="c1"># references</span>
            <span class="n">coord_to_extract_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord_to_extract</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Identify the indices which intersect the requested coord and</span>
            <span class="c1"># coord_to_extract</span>
            <span class="n">coord_indices</span> <span class="o">=</span> <span class="n">coord_to_extract</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span>
                <span class="n">coord</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Build up a slice which spans the whole of the cube</span>
            <span class="n">full_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># Update the full slice to only extract specific indices which</span>
            <span class="c1"># were identified above</span>
            <span class="n">full_slice</span><span class="p">[</span><span class="n">coord_to_extract_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord_indices</span>
            <span class="n">full_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">full_slice</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">full_slice</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Cube.extract"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the cube by the given constraint using</span>
<span class="sd">        :meth:`iris.Constraint.extract` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cast the constraint into a proper constraint if it is not so already</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">_constraints</span><span class="o">.</span><span class="n">as_constraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constraint</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cube.intersection"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of the cube with specified coordinate</span>
<span class="sd">        ranges.</span>

<span class="sd">        Coordinate ranges can be specified as:</span>

<span class="sd">        (a) instances of :class:`iris.coords.CoordExtent`.</span>

<span class="sd">        (b) keyword arguments, where the keyword name specifies the name</span>
<span class="sd">            of the coordinate (as defined in :meth:`iris.cube.Cube.coords()`)</span>
<span class="sd">            and the value defines the corresponding range of coordinate</span>
<span class="sd">            values as a tuple. The tuple must contain two, three, or four</span>
<span class="sd">            items corresponding to: (minimum, maximum, min_inclusive,</span>
<span class="sd">            max_inclusive). Where the items are defined as:</span>

<span class="sd">            * minimum</span>
<span class="sd">                The minimum value of the range to select.</span>

<span class="sd">            * maximum</span>
<span class="sd">                The maximum value of the range to select.</span>

<span class="sd">            * min_inclusive</span>
<span class="sd">                If True, coordinate values equal to `minimum` will be included</span>
<span class="sd">                in the selection. Default is True.</span>

<span class="sd">            * max_inclusive</span>
<span class="sd">                If True, coordinate values equal to `maximum` will be included</span>
<span class="sd">                in the selection. Default is True.</span>

<span class="sd">        To perform an intersection that ignores any bounds on the coordinates,</span>
<span class="sd">        set the optional keyword argument *ignore_bounds* to True. Defaults to</span>
<span class="sd">        False.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For ranges defined over &quot;circular&quot; coordinates (i.e. those</span>
<span class="sd">            where the `units` attribute has a modulus defined) the cube</span>
<span class="sd">            will be &quot;rolled&quot; to fit where necessary.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            Currently this routine only works with &quot;circular&quot;</span>
<span class="sd">            coordinates (as defined in the previous note.)</span>

<span class="sd">        For example::</span>

<span class="sd">            &gt;&gt;&gt; import iris</span>
<span class="sd">            &gt;&gt;&gt; cube = iris.load_cube(iris.sample_data_path(&#39;air_temp.pp&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(cube.coord(&#39;longitude&#39;).points[::10])</span>
<span class="sd">            [   0.           37.49999237   74.99998474  112.49996948  \</span>
<span class="sd">149.99996948</span>
<span class="sd">              187.49995422  224.99993896  262.49993896  299.99993896  \</span>
<span class="sd">337.49990845]</span>
<span class="sd">            &gt;&gt;&gt; subset = cube.intersection(longitude=(30, 50))</span>
<span class="sd">            &gt;&gt;&gt; print(subset.coord(&#39;longitude&#39;).points)</span>
<span class="sd">            [ 33.74999237  37.49999237  41.24998856  44.99998856  48.74998856]</span>
<span class="sd">            &gt;&gt;&gt; subset = cube.intersection(longitude=(-10, 10))</span>
<span class="sd">            &gt;&gt;&gt; print(subset.coord(&#39;longitude&#39;).points)</span>
<span class="sd">            [-7.50012207 -3.75012207  0.          3.75        7.5       ]</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new :class:`~iris.cube.Cube` giving the subset of the cube</span>
<span class="sd">            which intersects with the requested coordinate intervals.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">ignore_bounds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ignore_bounds&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_intersect</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">ignore_bounds</span><span class="o">=</span><span class="n">ignore_bounds</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_intersect</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">ignore_bounds</span><span class="o">=</span><span class="n">ignore_bounds</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">_intersect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name_or_coord</span><span class="p">,</span>
        <span class="n">minimum</span><span class="p">,</span>
        <span class="n">maximum</span><span class="p">,</span>
        <span class="n">min_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">max_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ignore_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">nbounds</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expected 0 or 2 bound values per cell&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minimum</span> <span class="o">&gt;</span> <span class="n">maximum</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;minimum greater than maximum&quot;</span><span class="p">)</span>
        <span class="n">modulus</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span>
        <span class="k">if</span> <span class="n">modulus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;coordinate units with no modulus are not yet&quot;</span> <span class="s2">&quot; supported&quot;</span>
            <span class="p">)</span>
        <span class="n">subsets</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersect_modulus</span><span class="p">(</span>
            <span class="n">coord</span><span class="p">,</span>
            <span class="n">minimum</span><span class="p">,</span>
            <span class="n">maximum</span><span class="p">,</span>
            <span class="n">min_inclusive</span><span class="p">,</span>
            <span class="n">max_inclusive</span><span class="p">,</span>
            <span class="n">ignore_bounds</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># By this point we have either one or two subsets along the relevant</span>
        <span class="c1"># dimension. If it&#39;s just one subset (which might be a slice or an</span>
        <span class="c1"># unordered collection of indices) we can simply index the cube</span>
        <span class="c1"># and we&#39;re done. If it&#39;s two subsets we need to stitch the two</span>
        <span class="c1"># pieces together.</span>
        <span class="c1"># subsets provides a way of slicing the coordinates to ensure that</span>
        <span class="c1"># they remain contiguous.  In doing so, this can mean</span>
        <span class="c1"># transforming the data (this stitching together of two separate</span>
        <span class="c1"># pieces).</span>
        <span class="k">def</span> <span class="nf">make_chunk</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key_tuple_prefix</span> <span class="o">+</span> <span class="p">(</span><span class="n">key</span><span class="p">,)]</span>
            <span class="n">chunk_coord</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="n">chunk_coord</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[(</span><span class="n">key</span><span class="p">,)]</span>
            <span class="k">if</span> <span class="n">chunk_coord</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                <span class="n">chunk_coord</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[(</span><span class="n">key</span><span class="p">,)]</span>
            <span class="k">return</span> <span class="n">chunk</span>

        <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="n">key_tuple_prefix</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">dim</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">make_chunk</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunk_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">chunk</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">concatenate</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">module</span> <span class="o">=</span> <span class="n">ma</span> <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">concatenate</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">chunk_data</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>

            <span class="c1"># Record a mapping from old coordinate IDs to new coordinates,</span>
            <span class="c1"># for subsequent use in creating updated aux_factories.</span>
            <span class="n">coord_mapping</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">def</span> <span class="nf">create_coords</span><span class="p">(</span><span class="n">src_coords</span><span class="p">,</span> <span class="n">add_coord</span><span class="p">):</span>
                <span class="c1"># Add copies of the source coordinates, selecting</span>
                <span class="c1"># the appropriate subsets out of coordinates which</span>
                <span class="c1"># share the intersection dimension.</span>
                <span class="n">preserve_circular</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">min_inclusive</span>
                    <span class="ow">and</span> <span class="n">max_inclusive</span>
                    <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">maximum</span> <span class="o">-</span> <span class="n">minimum</span><span class="p">)</span> <span class="o">==</span> <span class="n">modulus</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">src_coord</span> <span class="ow">in</span> <span class="n">src_coords</span><span class="p">:</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">src_coord</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                        <span class="n">dim_within_coord</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">chunk</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">src_coord</span><span class="p">)</span><span class="o">.</span><span class="n">points</span>
                                <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span>
                            <span class="p">],</span>
                            <span class="n">dim_within_coord</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">src_coord</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">chunk</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">src_coord</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span>
                                    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span>
                                <span class="p">],</span>
                                <span class="n">dim_within_coord</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">result_coord</span> <span class="o">=</span> <span class="n">src_coord</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                            <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span>
                        <span class="p">)</span>

                        <span class="n">circular</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result_coord</span><span class="p">,</span> <span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">circular</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">preserve_circular</span><span class="p">:</span>
                            <span class="n">result_coord</span><span class="o">.</span><span class="n">circular</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result_coord</span> <span class="o">=</span> <span class="n">src_coord</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">add_coord</span><span class="p">(</span><span class="n">result_coord</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
                    <span class="n">coord_mapping</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">src_coord</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result_coord</span>

            <span class="n">create_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">)</span>
            <span class="n">create_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_coords</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add_aux_factory</span><span class="p">(</span><span class="n">factory</span><span class="o">.</span><span class="n">updated</span><span class="p">(</span><span class="n">coord_mapping</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_intersect_derive_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">inside_indices</span><span class="p">):</span>
        <span class="c1"># Return the subsets, i.e. the means to allow the slicing of</span>
        <span class="c1"># coordinates to ensure that they remain contiguous.</span>
        <span class="n">modulus</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">inside_indices</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">inside_indices</span><span class="p">]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">/</span> <span class="n">modulus</span><span class="p">)</span>
        <span class="n">non_zero_step_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">dim_coord_subset</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Derive the subset for dimension coordinates.</span>

<span class="sd">            Ensure that we do not wrap if blocks are at the very edge.  That</span>
<span class="sd">            is, if the very edge is wrapped and corresponds to base + period,</span>
<span class="sd">            stop this unnecessary wraparound.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># A contiguous block at the start and another at the end.</span>
            <span class="c1"># (NB. We can&#39;t have more than two blocks because we&#39;ve already</span>
            <span class="c1"># restricted the coordinate&#39;s range to its modulus).</span>
            <span class="n">end_of_first_chunk</span> <span class="o">=</span> <span class="n">non_zero_step_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">index_of_second_chunk</span> <span class="o">=</span> <span class="n">inside_indices</span><span class="p">[</span><span class="n">end_of_first_chunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">final_index</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Condition1: The two blocks don&#39;t themselves wrap</span>
            <span class="c1">#             (inside_indices is contiguous).</span>
            <span class="c1"># Condition2: Are we chunked at either extreme edge.</span>
            <span class="n">edge_wrap</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">index_of_second_chunk</span> <span class="o">==</span> <span class="n">inside_indices</span><span class="p">[</span><span class="n">end_of_first_chunk</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="n">index_of_second_chunk</span> <span class="ow">in</span> <span class="p">(</span><span class="n">final_index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">subsets</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">edge_wrap</span><span class="p">:</span>
                <span class="c1"># Increasing coord</span>
                <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">index_end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">index_start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Decreasing coord</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index_end</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">index_start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="c1"># Unwrap points and bounds (if present and equal base + period)</span>
                <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">edge_equal_base_period</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                        <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">index_end</span><span class="p">,</span> <span class="n">index_end</span><span class="p">],</span>
                        <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">index_start</span><span class="p">,</span> <span class="n">index_start</span><span class="p">]</span> <span class="o">+</span> <span class="n">modulus</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">edge_equal_base_period</span><span class="p">:</span>
                        <span class="n">bounds</span><span class="p">[</span><span class="n">index_end</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">index_end</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edge_equal_base_period</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                        <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index_end</span><span class="p">],</span>
                        <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index_start</span><span class="p">]</span> <span class="o">+</span> <span class="n">modulus</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">edge_equal_base_period</span><span class="p">:</span>
                    <span class="n">points</span><span class="p">[</span><span class="n">index_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index_end</span><span class="p">]</span>
                    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="nb">slice</span><span class="p">(</span><span class="n">inside_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inside_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">]</span>

            <span class="c1"># Either no edge wrap or edge wrap != base + period</span>
            <span class="c1"># i.e. derive subset without alteration</span>
            <span class="k">if</span> <span class="n">subsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="nb">slice</span><span class="p">(</span><span class="n">index_of_second_chunk</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">inside_indices</span><span class="p">[</span><span class="n">end_of_first_chunk</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">]</span>

            <span class="k">return</span> <span class="n">subsets</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">non_zero_step_indices</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">subsets</span> <span class="o">=</span> <span class="n">dim_coord_subset</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># A single, contiguous block.</span>
                <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">inside_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inside_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># An AuxCoord could have its values in an arbitrary</span>
            <span class="c1"># order, and hence a range of values can select an</span>
            <span class="c1"># arbitrary subset. Also, we want to preserve the order</span>
            <span class="c1"># from the original AuxCoord. So we just use the indices</span>
            <span class="c1"># directly.</span>
            <span class="n">subsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">inside_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">subsets</span>

    <span class="k">def</span> <span class="nf">_intersect_modulus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord</span><span class="p">,</span>
        <span class="n">minimum</span><span class="p">,</span>
        <span class="n">maximum</span><span class="p">,</span>
        <span class="n">min_inclusive</span><span class="p">,</span>
        <span class="n">max_inclusive</span><span class="p">,</span>
        <span class="n">ignore_bounds</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">modulus</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span>
        <span class="k">if</span> <span class="n">maximum</span> <span class="o">&gt;</span> <span class="n">minimum</span> <span class="o">+</span> <span class="n">modulus</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;requested range greater than coordinate&#39;s&quot;</span> <span class="s2">&quot; unit&#39;s modulus&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="n">modulus</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;coordinate&#39;s range greater than coordinate&#39;s&quot;</span>
                <span class="s2">&quot; unit&#39;s modulus&quot;</span>
            <span class="p">)</span>
        <span class="n">min_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span> <span class="k">if</span> <span class="n">min_inclusive</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span>
        <span class="n">max_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span> <span class="k">if</span> <span class="n">max_inclusive</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span>

        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">wrap_lons</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">modulus</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ignore_bounds</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">wrap_lons</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">modulus</span><span class="p">)</span>
                <span class="p">(</span><span class="n">inside_indices</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="n">min_comp</span><span class="p">(</span><span class="n">minimum</span><span class="p">,</span> <span class="n">points</span><span class="p">),</span> <span class="n">max_comp</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">min_comp</span><span class="p">(</span><span class="n">minimum</span><span class="p">,</span> <span class="n">bounds</span><span class="p">),</span> <span class="n">max_comp</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="p">(</span><span class="n">inside_indices</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">inside</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># To ensure that bounds (and points) of matching cells aren&#39;t</span>
            <span class="c1"># &quot;scrambled&quot; by the wrap operation we detect split cells that</span>
            <span class="c1"># straddle the wrap point and choose a new wrap point which avoids</span>
            <span class="c1"># split cells.</span>
            <span class="c1"># For example: the cell [349.875, 350.4375] wrapped at -10 would</span>
            <span class="c1"># become [349.875, -9.5625] which is no longer valid. The lower</span>
            <span class="c1"># cell bound value (and possibly associated point) are</span>
            <span class="c1"># recalculated so that they are consistent with the extended</span>
            <span class="c1"># wrapping scheme which moves the wrap point to the correct lower</span>
            <span class="c1"># bound value (-10.125) thus resulting in the cell no longer</span>
            <span class="c1"># being split. For bounds which may extend exactly the length of</span>
            <span class="c1"># the modulus, we simply preserve the point to bound difference,</span>
            <span class="c1"># and call the new bounds = the new points + the difference.</span>
            <span class="n">pre_wrap_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">inside_indices</span><span class="p">])</span>
            <span class="n">post_wrap_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">inside_indices</span><span class="p">])</span>
            <span class="n">close_enough</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">pre_wrap_delta</span><span class="p">,</span> <span class="n">post_wrap_delta</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">close_enough</span><span class="p">:</span>
                <span class="n">split_cell_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">pre_wrap_delta</span> <span class="o">!=</span> <span class="n">post_wrap_delta</span>
                <span class="p">)</span>

                <span class="c1"># Recalculate the extended minimum.</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">inside_indices</span><span class="p">[</span><span class="n">split_cell_indices</span><span class="p">]</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">cells_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>

                <span class="c1"># Watch out for ascending/descending bounds</span>
                <span class="k">if</span> <span class="n">cells_delta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cells</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cells_delta</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cells</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cells</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cells_delta</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cells</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">points</span> <span class="o">=</span> <span class="n">wrap_lons</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">modulus</span><span class="p">)</span>

            <span class="n">bound_diffs</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">bound_diffs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">wrap_lons</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">modulus</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="p">(</span><span class="n">inside_indices</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">min_comp</span><span class="p">(</span><span class="n">minimum</span><span class="p">,</span> <span class="n">points</span><span class="p">),</span> <span class="n">max_comp</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Determine the subsets</span>
        <span class="n">subsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersect_derive_subset</span><span class="p">(</span>
            <span class="n">coord</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">inside_indices</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">subsets</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">bounds</span>

    <span class="k">def</span> <span class="nf">_as_list_of_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names_or_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a name, coord, or list of names/coords to a list of coords.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If not iterable, convert to list of a single item</span>
        <span class="k">if</span> <span class="n">_is_single_item</span><span class="p">(</span><span class="n">names_or_coords</span><span class="p">):</span>
            <span class="n">names_or_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">names_or_coords</span><span class="p">]</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name_or_coord</span> <span class="ow">in</span> <span class="n">names_or_coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">name_or_coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span>
            <span class="p">):</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Don&#39;t know how to handle this type</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Don&#39;t know how to handle coordinate of type </span><span class="si">%s</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Ensure all coordinates are of type str &quot;</span>
                    <span class="s2">&quot;or iris.coords.Coord.&quot;</span>
                <span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">),)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coords</span>

<div class="viewcode-block" id="Cube.slices_over"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.slices_over">[docs]</a>    <span class="k">def</span> <span class="nf">slices_over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_to_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator of all subcubes along a given coordinate or</span>
<span class="sd">        dimension index, or multiple of these.</span>

<span class="sd">        Args:</span>

<span class="sd">        * ref_to_slice (string, coord, dimension index or a list of these):</span>
<span class="sd">            Determines which dimensions will be iterated along (i.e. the</span>
<span class="sd">            dimensions that are not returned in the subcubes).</span>
<span class="sd">            A mix of input types can also be provided.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An iterator of subcubes.</span>

<span class="sd">        For example, to get all subcubes along the time dimension::</span>

<span class="sd">            for sub_cube in cube.slices_over(&#39;time&#39;):</span>
<span class="sd">                print(sub_cube)</span>

<span class="sd">        .. seealso:: :meth:`iris.cube.Cube.slices`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The order of dimension references to slice along does not affect</span>
<span class="sd">            the order of returned items in the iterator; instead the ordering</span>
<span class="sd">            is based on the fastest-changing dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Required to handle a mix between types.</span>
        <span class="k">if</span> <span class="n">_is_single_item</span><span class="p">(</span><span class="n">ref_to_slice</span><span class="p">):</span>
            <span class="n">ref_to_slice</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_to_slice</span><span class="p">]</span>

        <span class="n">slice_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">ref_to_slice</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span><span class="n">coord</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_list_of_coords</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Requested an iterator over a dimension (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                        <span class="s2">&quot;which does not exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="c1"># Convert coord index to a single-element list to prevent a</span>
                <span class="c1"># TypeError when `slice_dims.update` is called with it.</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="n">slice_dims</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

        <span class="n">all_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">opposite_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_dims</span> <span class="o">-</span> <span class="n">slice_dims</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="p">(</span><span class="n">opposite_dims</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cube.slices"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.slices">[docs]</a>    <span class="k">def</span> <span class="nf">slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_to_slice</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator of all subcubes given the coordinates or dimension</span>
<span class="sd">        indices desired to be present in each subcube.</span>

<span class="sd">        Args:</span>

<span class="sd">        * ref_to_slice (string, coord, dimension index or a list of these):</span>
<span class="sd">            Determines which dimensions will be returned in the subcubes (i.e.</span>
<span class="sd">            the dimensions that are not iterated over).</span>
<span class="sd">            A mix of input types can also be provided. They must all be</span>
<span class="sd">            orthogonal (i.e. point to different dimensions).</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * ordered: if True, the order which the coords to slice or data_dims</span>
<span class="sd">            are given will be the order in which they represent the data in</span>
<span class="sd">            the resulting cube slices.  If False, the order will follow that of</span>
<span class="sd">            the source cube.  Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An iterator of subcubes.</span>

<span class="sd">        For example, to get all 2d longitude/latitude subcubes from a</span>
<span class="sd">        multi-dimensional cube::</span>

<span class="sd">            for sub_cube in cube.slices([&#39;longitude&#39;, &#39;latitude&#39;]):</span>
<span class="sd">                print(sub_cube)</span>

<span class="sd">        .. seealso:: :meth:`iris.cube.Cube.slices_over`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ordered</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;ordered&#39; argument to slices must be boolean.&quot;</span><span class="p">)</span>

        <span class="c1"># Required to handle a mix between types</span>
        <span class="k">if</span> <span class="n">_is_single_item</span><span class="p">(</span><span class="n">ref_to_slice</span><span class="p">):</span>
            <span class="n">ref_to_slice</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_to_slice</span><span class="p">]</span>

        <span class="n">dim_to_slice</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">ref_to_slice</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># attempt to handle as coordinate</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_list_of_coords</span><span class="p">(</span><span class="n">ref</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dims</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Requested an iterator over a coordinate (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                        <span class="s2">&quot;which does not describe a dimension.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">dim_to_slice</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># attempt to handle as dimension index</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> Incompatible type </span><span class="si">{}</span><span class="s2"> for &quot;</span>
                        <span class="s2">&quot;slicing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Requested an iterator over a dimension (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                        <span class="s2">&quot;which does not exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">dim_to_slice</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dim_to_slice</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_to_slice</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The requested coordinates are not orthogonal.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Create a list with of the shape of our data</span>
        <span class="n">dims_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Set the dimensions which have been requested to length 1</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim_to_slice</span><span class="p">:</span>
            <span class="n">dims_index</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">_SliceIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims_index</span><span class="p">,</span> <span class="n">dim_to_slice</span><span class="p">,</span> <span class="n">ordered</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cube.transpose"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-order the data dimensions of the cube in-place.</span>

<span class="sd">        new_order - list of ints, optional</span>
<span class="sd">                    By default, reverse the dimensions, otherwise permute the</span>
<span class="sd">                    axes according to the values given.</span>

<span class="sd">        .. note:: If defined, new_order must span all of the data dimensions.</span>

<span class="sd">        Example usage::</span>

<span class="sd">            # put the second dimension first, followed by the third dimension,</span>
<span class="sd">            and finally put the first dimension third::</span>

<span class="sd">                &gt;&gt;&gt; cube.transpose([1, 2, 0])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># `new_order` must be an iterable for checking with `self.ndim`.</span>
        <span class="c1"># Dask transpose only supports lists, so ensure `new_order` is</span>
        <span class="c1"># always a list.</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect number of dimensions.&quot;</span><span class="p">)</span>

        <span class="c1"># Transpose the data payload.</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span> <span class="o">=</span> <span class="n">DataManager</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">dim_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">src</span><span class="p">:</span> <span class="n">dest</span> <span class="k">for</span> <span class="n">dest</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_order</span><span class="p">)}</span>

        <span class="c1"># Remap all cube dimensional metadata (dim and aux coords and cell</span>
        <span class="c1"># measures).</span>
        <span class="k">def</span> <span class="nf">remap_cube_metadata</span><span class="p">(</span><span class="n">metadata_and_dims</span><span class="p">):</span>
            <span class="n">metadata</span><span class="p">,</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">metadata_and_dims</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim_mapping</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="n">dim_mapping</span><span class="p">[</span><span class="n">dims</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">dims</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="n">remap_cube_metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="n">remap_cube_metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="n">remap_cube_metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="n">remap_cube_metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Cube.xml"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.xml">[docs]</a>    <span class="k">def</span> <span class="nf">xml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a fully valid CubeML string representation of the Cube.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">Document</span><span class="p">()</span>

        <span class="n">cube_xml_element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xml_element</span><span class="p">(</span>
            <span class="n">doc</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span>
        <span class="p">)</span>
        <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;xmlns&quot;</span><span class="p">,</span> <span class="n">XML_NAMESPACE_URI</span><span class="p">)</span>
        <span class="n">doc</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">cube_xml_element</span><span class="p">)</span>

        <span class="c1"># Print our newly created XML</span>
        <span class="k">return</span> <span class="n">doc</span><span class="o">.</span><span class="n">toprettyxml</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="s2">&quot;  &quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_xml_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">cube_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;cube&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_name</span><span class="p">:</span>
            <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;standard_name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span><span class="p">:</span>
            <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;long_name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">:</span>
            <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;var_name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">)</span>
        <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;units&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">))</span>
        <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="n">attributes_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;attributes&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">attribute_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;attribute&quot;</span><span class="p">)</span>
                <span class="n">attribute_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1"># Strict check because we don&#39;t want namedtuples.</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">delimiter</span> <span class="o">=</span> <span class="s2">&quot;[]&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;()&quot;</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">item</span><span class="p">,)</span>
                        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span>
                    <span class="p">)</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">delimiter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="n">delimiter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="n">attribute_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">attributes_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">attribute_element</span><span class="p">)</span>

            <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">attributes_element</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dimmeta_xml_element</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">dimscall</span><span class="p">):</span>
            <span class="c1"># Make an inner xml element for a cube DimensionalMetadata element, with a</span>
            <span class="c1"># &#39;datadims&#39; property showing how it maps to the parent cube dims.</span>
            <span class="n">xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="n">typename</span><span class="p">)</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dimscall</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">dims</span><span class="p">:</span>
                <span class="n">xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;datadims&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
            <span class="n">xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">xml_element</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">xml_element</span>

        <span class="n">coords_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;coords&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()):</span>
            <span class="c1"># make a &quot;cube coordinate&quot; element which holds the dimensions (if</span>
            <span class="c1"># appropriate) which itself will have a sub-element of the</span>
            <span class="c1"># coordinate instance itself.</span>
            <span class="n">coords_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span>
                <span class="n">dimmeta_xml_element</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="s2">&quot;coord&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">coords_xml_element</span><span class="p">)</span>

        <span class="c1"># cell methods (no sorting!)</span>
        <span class="n">cell_methods_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;cellMethods&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_methods</span><span class="p">:</span>
            <span class="n">cell_method_xml_element</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">xml_element</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="n">cell_methods_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">cell_method_xml_element</span><span class="p">)</span>
        <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">cell_methods_xml_element</span><span class="p">)</span>

        <span class="c1"># cell measures</span>
        <span class="n">cell_measures</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_measures</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cm</span><span class="p">:</span> <span class="n">cm</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">cell_measures</span><span class="p">:</span>
            <span class="c1"># This one is an optional subelement.</span>
            <span class="n">cms_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;cellMeasures&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">cell_measures</span><span class="p">:</span>
                <span class="n">cms_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span>
                    <span class="n">dimmeta_xml_element</span><span class="p">(</span>
                        <span class="n">cm</span><span class="p">,</span> <span class="s2">&quot;cell-measure&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_measure_dims</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">cms_xml_element</span><span class="p">)</span>

        <span class="c1"># ancillary variables</span>
        <span class="n">ancils</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variables</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">anc</span><span class="p">:</span> <span class="n">anc</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">ancils</span><span class="p">:</span>
            <span class="c1"># This one is an optional subelement.</span>
            <span class="n">ancs_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;ancillaryVariables&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">anc</span> <span class="ow">in</span> <span class="n">ancils</span><span class="p">:</span>
                <span class="n">ancs_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span>
                    <span class="n">dimmeta_xml_element</span><span class="p">(</span>
                        <span class="n">anc</span><span class="p">,</span> <span class="s2">&quot;ancillary-var&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancillary_variable_dims</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">ancs_xml_element</span><span class="p">)</span>

        <span class="c1"># data</span>
        <span class="n">data_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>
        <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="c1"># NB. Getting a checksum triggers any deferred loading,</span>
        <span class="c1"># in which case it also has the side-effect of forcing the</span>
        <span class="c1"># byte order to be native.</span>
        <span class="k">if</span> <span class="n">checksum</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

            <span class="c1"># Ensure consistent memory layout for checksums.</span>
            <span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">data</span>

            <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># Fill in masked values to avoid the checksum being</span>
                <span class="c1"># sensitive to unused numbers. Use a fixed value so</span>
                <span class="c1"># a change in fill_value doesn&#39;t affect the</span>
                <span class="c1"># checksum.</span>
                <span class="n">crc</span> <span class="o">=</span> <span class="s2">&quot;0x</span><span class="si">%08x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">zlib</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">normalise</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;checksum&quot;</span><span class="p">,</span> <span class="n">crc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="n">crc</span> <span class="o">=</span> <span class="s2">&quot;0x</span><span class="si">%08x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">zlib</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">normalise</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">crc</span> <span class="o">=</span> <span class="s2">&quot;no-masked-elements&quot;</span>
                <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;mask_checksum&quot;</span><span class="p">,</span> <span class="n">crc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">crc</span> <span class="o">=</span> <span class="s2">&quot;0x</span><span class="si">%08x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">zlib</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">normalise</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">,)</span>
                <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;checksum&quot;</span><span class="p">,</span> <span class="n">crc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
            <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;state&quot;</span><span class="p">,</span> <span class="s2">&quot;deferred&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;state&quot;</span><span class="p">,</span> <span class="s2">&quot;loaded&quot;</span><span class="p">)</span>

        <span class="c1"># Add the dtype, and also the array and mask orders if the</span>
        <span class="c1"># data is loaded.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

            <span class="k">def</span> <span class="nf">_order</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
                <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">]:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span>
                <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;F_CONTIGUOUS&quot;</span><span class="p">]:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
                <span class="k">return</span> <span class="n">order</span>

            <span class="k">if</span> <span class="n">order</span><span class="p">:</span>
                <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">,</span> <span class="n">_order</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

            <span class="c1"># NB. dtype.byteorder can return &#39;=&#39;, which is bad for</span>
            <span class="c1"># cross-platform consistency - so we use dtype.str</span>
            <span class="c1"># instead.</span>
            <span class="k">if</span> <span class="n">byteorder</span><span class="p">:</span>
                <span class="n">array_byteorder</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&gt;&quot;</span><span class="p">:</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span> <span class="s2">&quot;little&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">array_byteorder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;byteorder&quot;</span><span class="p">,</span> <span class="n">array_byteorder</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">order</span> <span class="ow">and</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;mask_order&quot;</span><span class="p">,</span> <span class="n">_order</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">()</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">data_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">cube_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">data_xml_element</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cube_xml_element</span>

<div class="viewcode-block" id="Cube.copy"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of this cube.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * data:</span>
<span class="sd">            Replace the data of the cube copy with provided data payload.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy instance of the :class:`Cube`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deepcopy</span><span class="p">(</span><span class="n">memo</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cube</span></div>

<div class="viewcode-block" id="Cube.__copy__"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.__copy__">[docs]</a>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shallow copying is disallowed for Cubes.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">copy</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span>
            <span class="s2">&quot;Cube shallow-copy not allowed. Use deepcopy() or &quot;</span> <span class="s2">&quot;Cube.copy()&quot;</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deepcopy</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_manager</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

        <span class="n">new_dim_coords_and_dims</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">new_aux_coords_and_dims</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">new_cell_measures_and_dims</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cell_measures_and_dims</span><span class="p">,</span> <span class="n">memo</span>
        <span class="p">)</span>
        <span class="n">new_ancillary_variables_and_dims</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ancillary_variables_and_dims</span><span class="p">,</span> <span class="n">memo</span>
        <span class="p">)</span>

        <span class="c1"># Record a mapping from old coordinate IDs to new coordinates,</span>
        <span class="c1"># for subsequent use in creating updated aux_factories.</span>
        <span class="n">coord_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">old_pair</span><span class="p">,</span> <span class="n">new_pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim_coords_and_dims</span><span class="p">,</span> <span class="n">new_dim_coords_and_dims</span>
        <span class="p">):</span>
            <span class="n">coord_mapping</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">old_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">new_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">old_pair</span><span class="p">,</span> <span class="n">new_pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_aux_coords_and_dims</span><span class="p">,</span> <span class="n">new_aux_coords_and_dims</span>
        <span class="p">):</span>
            <span class="n">coord_mapping</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">old_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">new_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">new_cube</span> <span class="o">=</span> <span class="n">Cube</span><span class="p">(</span>
            <span class="n">dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">(),</span>
            <span class="n">dim_coords_and_dims</span><span class="o">=</span><span class="n">new_dim_coords_and_dims</span><span class="p">,</span>
            <span class="n">aux_coords_and_dims</span><span class="o">=</span><span class="n">new_aux_coords_and_dims</span><span class="p">,</span>
            <span class="n">cell_measures_and_dims</span><span class="o">=</span><span class="n">new_cell_measures_and_dims</span><span class="p">,</span>
            <span class="n">ancillary_variables_and_dims</span><span class="o">=</span><span class="n">new_ancillary_variables_and_dims</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">new_cube</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>
            <span class="n">new_cube</span><span class="o">.</span><span class="n">add_aux_factory</span><span class="p">(</span><span class="n">factory</span><span class="o">.</span><span class="n">updated</span><span class="p">(</span><span class="n">coord_mapping</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">new_cube</span>

    <span class="c1"># START OPERATOR OVERLOADS</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Cube</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span>

            <span class="c1"># having checked the metadata, now check the coordinates</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">coord_compares</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">_dimensional_metadata_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># if there are any coordinates which are not equal</span>
                <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">coord_compares</span><span class="p">[</span><span class="s2">&quot;not_equal&quot;</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">coord_compares</span><span class="p">[</span><span class="s2">&quot;non_equal_data_dimension&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">cm_compares</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">_dimensional_metadata_comparison</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">object_get</span><span class="o">=</span><span class="n">Cube</span><span class="o">.</span><span class="n">cell_measures</span>
                <span class="p">)</span>
                <span class="c1"># if there are any cell measures which are not equal</span>
                <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">cm_compares</span><span class="p">[</span><span class="s2">&quot;not_equal&quot;</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">cm_compares</span><span class="p">[</span><span class="s2">&quot;non_equal_data_dimension&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">av_compares</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">_dimensional_metadata_comparison</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">object_get</span><span class="o">=</span><span class="n">Cube</span><span class="o">.</span><span class="n">ancillary_variables</span>
                <span class="p">)</span>
                <span class="c1"># if there are any ancillary variables which are not equal</span>
                <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">av_compares</span><span class="p">[</span><span class="s2">&quot;not_equal&quot;</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">av_compares</span><span class="p">[</span><span class="s2">&quot;non_equal_data_dimension&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="c1"># Having checked everything else, check approximate data equality.</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>
                <span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># Must supply __ne__, Python does not defer to __eq__ for negative equality</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># Must supply __hash__ as Python 3 does not enable it if __eq__ is defined.</span>
    <span class="c1"># NOTE: Violates &quot;objects which compare equal must have the same hash&quot;.</span>
    <span class="c1"># We ought to remove this, as equality of two cube can *change*, so they</span>
    <span class="c1"># really should not be hashable.</span>
    <span class="c1"># However, current code needs it, e.g. so we can put them in sets.</span>
    <span class="c1"># Fixing it will require changing those uses.  See #962 and #1772.</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="fm">__radd__</span> <span class="o">=</span> <span class="fm">__add__</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">multiply</span>
    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">multiply</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">__div__</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">divide</span>

    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">divide</span>

    <span class="k">def</span> <span class="fm">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="fm">__pow__</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">maths</span><span class="o">.</span><span class="n">exponentiate</span>
    <span class="c1"># END OPERATOR OVERLOADS</span>

<div class="viewcode-block" id="Cube.collapsed"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.collapsed">[docs]</a>    <span class="k">def</span> <span class="nf">collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">aggregator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collapse one or more dimensions over the cube given the coordinate/s</span>
<span class="sd">        and an aggregation.</span>

<span class="sd">        Examples of aggregations that may be used include</span>
<span class="sd">        :data:`~iris.analysis.COUNT` and :data:`~iris.analysis.MAX`.</span>

<span class="sd">        Weighted aggregations (:class:`iris.analysis.WeightedAggregator`) may</span>
<span class="sd">        also be supplied. These include :data:`~iris.analysis.MEAN` and</span>
<span class="sd">        sum :data:`~iris.analysis.SUM`.</span>

<span class="sd">        Weighted aggregations support an optional *weights* keyword argument.</span>
<span class="sd">        If set, this should be supplied as an array of weights whose shape</span>
<span class="sd">        matches the cube. Values for latitude-longitude area weights may be</span>
<span class="sd">        calculated using :func:`iris.analysis.cartography.area_weights`.</span>

<span class="sd">        Some Iris aggregators support &quot;lazy&quot; evaluation, meaning that</span>
<span class="sd">        cubes resulting from this method may represent data arrays which are</span>
<span class="sd">        not computed until the data is requested (e.g. via ``cube.data`` or</span>
<span class="sd">        ``iris.save``). If lazy evaluation exists for the given aggregator</span>
<span class="sd">        it will be used wherever possible when this cube&#39;s data is itself</span>
<span class="sd">        a deferred array.</span>

<span class="sd">        Args:</span>

<span class="sd">        * coords (string, coord or a list of strings/coords):</span>
<span class="sd">            Coordinate names/coordinates over which the cube should be</span>
<span class="sd">            collapsed.</span>

<span class="sd">        * aggregator (:class:`iris.analysis.Aggregator`):</span>
<span class="sd">            Aggregator to be applied for collapse operation.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * kwargs:</span>
<span class="sd">            Aggregation function keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Collapsed cube.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import iris</span>
<span class="sd">            &gt;&gt;&gt; import iris.analysis</span>
<span class="sd">            &gt;&gt;&gt; path = iris.sample_data_path(&#39;ostia_monthly.nc&#39;)</span>
<span class="sd">            &gt;&gt;&gt; cube = iris.load_cube(path)</span>
<span class="sd">            &gt;&gt;&gt; new_cube = cube.collapsed(&#39;longitude&#39;, iris.analysis.MEAN)</span>
<span class="sd">            &gt;&gt;&gt; print(new_cube)</span>
<span class="sd">            surface_temperature / (K)           (time: 54; latitude: 18)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      time                           x             -</span>
<span class="sd">                      latitude                       -             x</span>
<span class="sd">                 Auxiliary coordinates:</span>
<span class="sd">                      forecast_reference_time        x             -</span>
<span class="sd">                 Scalar coordinates:</span>
<span class="sd">                      forecast_period: 0 hours</span>
<span class="sd">                      longitude: 180.0 degrees, bound=(0.0, 360.0) degrees</span>
<span class="sd">                 Attributes:</span>
<span class="sd">                      Conventions: CF-1.5</span>
<span class="sd">                      STASH: m01s00i024</span>
<span class="sd">                 Cell methods:</span>
<span class="sd">                      mean: month, year</span>
<span class="sd">                      mean: longitude</span>


<span class="sd">        .. note::</span>

<span class="sd">            Some aggregations are not commutative and hence the order of</span>
<span class="sd">            processing is important i.e.::</span>

<span class="sd">                tmp = cube.collapsed(&#39;realization&#39;, iris.analysis.VARIANCE)</span>
<span class="sd">                result = tmp.collapsed(&#39;height&#39;, iris.analysis.VARIANCE)</span>

<span class="sd">            is not necessarily the same result as::</span>

<span class="sd">                tmp = cube.collapsed(&#39;height&#39;, iris.analysis.VARIANCE)</span>
<span class="sd">                result2 = tmp.collapsed(&#39;realization&#39;, iris.analysis.VARIANCE)</span>

<span class="sd">            Conversely operations which operate on more than one coordinate</span>
<span class="sd">            at the same time are commutative as they are combined internally</span>
<span class="sd">            into a single operation. Hence the order of the coordinates</span>
<span class="sd">            supplied in the list does not matter::</span>

<span class="sd">                cube.collapsed([&#39;longitude&#39;, &#39;latitude&#39;],</span>
<span class="sd">                               iris.analysis.VARIANCE)</span>

<span class="sd">            is the same (apart from the logically equivalent cell methods that</span>
<span class="sd">            may be created etc.) as::</span>

<span class="sd">                cube.collapsed([&#39;latitude&#39;, &#39;longitude&#39;],</span>
<span class="sd">                               iris.analysis.VARIANCE)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert any coordinate names to coordinates</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_list_of_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">aggregator</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">WeightedAggregator</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">uses_weighting</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Collapsing spatial coordinate </span><span class="si">{!r}</span><span class="s2"> without weighting&quot;</span>
            <span class="n">lat_match</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coord</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span> <span class="k">if</span> <span class="s2">&quot;latitude&quot;</span> <span class="ow">in</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">lat_match</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">lat_match</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()))</span>

        <span class="c1"># Determine the dimensions we need to collapse (and those we don&#39;t)</span>
        <span class="k">if</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">cell_method</span> <span class="o">==</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span>
            <span class="n">dims_to_collapse</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span>
            <span class="p">]</span>

            <span class="c1"># Remove duplicate dimensions.</span>
            <span class="n">new_dims</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span>
                <span class="n">d</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims_to_collapse</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim</span>
            <span class="p">)</span>
            <span class="c1"># Reverse the dimensions so the order can be maintained when</span>
            <span class="c1"># reshaping the data.</span>
            <span class="n">dims_to_collapse</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_dims</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims_to_collapse</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                <span class="n">dims_to_collapse</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dims_to_collapse</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot collapse a dimension which does not describe any &quot;</span>
                <span class="s2">&quot;data.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateCollapseError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">untouched_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims_to_collapse</span><span class="p">)</span>

        <span class="n">collapsed_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_strip_metadata_from_dims</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dims_to_collapse</span>
        <span class="p">)</span>

        <span class="c1"># Remove the collapsed dimension(s) from the metadata</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims_to_collapse</span><span class="p">:</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">collapsed_cube</span> <span class="o">=</span> <span class="n">collapsed_cube</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span>

        <span class="c1"># Collapse any coords that span the dimension(s) being collapsed</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_coords</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_coords</span><span class="p">:</span>
            <span class="n">coord_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims_to_collapse</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">coord_dims</span><span class="p">):</span>
                <span class="n">local_dims</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">coord_dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims_to_collapse</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">coord_dims</span>
                <span class="p">]</span>
                <span class="n">collapsed_cube</span><span class="o">.</span><span class="n">replace_coord</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">local_dims</span><span class="p">))</span>

        <span class="n">untouched_dims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">untouched_dims</span><span class="p">)</span>

        <span class="c1"># Record the axis(s) argument passed to &#39;aggregation&#39;, so the same is</span>
        <span class="c1"># passed to the &#39;update_metadata&#39; function.</span>
        <span class="n">collapse_axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">data_result</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Perform the actual aggregation.</span>
        <span class="k">if</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">cell_method</span> <span class="o">==</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span>
            <span class="c1"># The PEAK aggregator must collapse each coordinate separately.</span>
            <span class="n">untouched_shape</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">untouched_dims</span><span class="p">]</span>
            <span class="n">collapsed_shape</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims_to_collapse</span><span class="p">]</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="n">untouched_shape</span> <span class="o">+</span> <span class="n">collapsed_shape</span>

            <span class="n">array_dims</span> <span class="o">=</span> <span class="n">untouched_dims</span> <span class="o">+</span> <span class="n">dims_to_collapse</span>
            <span class="n">unrolled_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">array_dims</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">new_shape</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims_to_collapse</span><span class="p">:</span>
                <span class="n">unrolled_data</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
                    <span class="n">unrolled_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="n">data_result</span> <span class="o">=</span> <span class="n">unrolled_data</span>

        <span class="c1"># Perform the aggregation in lazy form if possible.</span>
        <span class="k">elif</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">lazy_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
            <span class="c1"># Use a lazy operation separately defined by the aggregator, based</span>
            <span class="c1"># on the cube lazy array.</span>
            <span class="c1"># NOTE: do not reform the data in this case, as &#39;lazy_aggregate&#39;</span>
            <span class="c1"># accepts multiple axes (unlike &#39;aggregate&#39;).</span>
            <span class="n">collapse_axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dims_to_collapse</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data_result</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">lazy_aggregate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="n">collapse_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># TypeError - when unexpected keywords passed through (such as</span>
                <span class="c1"># weights to mean)</span>
                <span class="k">pass</span>

        <span class="c1"># If we weren&#39;t able to complete a lazy aggregation, compute it</span>
        <span class="c1"># directly now.</span>
        <span class="k">if</span> <span class="n">data_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Perform the (non-lazy) aggregation over the cube data</span>
            <span class="c1"># First reshape the data so that the dimensions being aggregated</span>
            <span class="c1"># over are grouped &#39;at the end&#39; (i.e. axis=-1).</span>
            <span class="n">dims_to_collapse</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dims_to_collapse</span><span class="p">)</span>

            <span class="n">end_size</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims_to_collapse</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">untouched_shape</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">untouched_dims</span><span class="p">]</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="n">untouched_shape</span> <span class="o">+</span> <span class="p">[</span><span class="n">end_size</span><span class="p">]</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">untouched_dims</span> <span class="o">+</span> <span class="n">dims_to_collapse</span>
            <span class="n">unrolled_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>

            <span class="c1"># Perform the same operation on the weights if applicable</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="n">new_shape</span>
                <span class="p">)</span>

            <span class="n">data_result</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
                <span class="n">unrolled_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="n">aggregator</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span>
            <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">collapse_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span>
            <span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Cube.aggregated_by"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.aggregated_by">[docs]</a>    <span class="k">def</span> <span class="nf">aggregated_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">aggregator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform aggregation over the cube given one or more &quot;group</span>
<span class="sd">        coordinates&quot;.</span>

<span class="sd">        A &quot;group coordinate&quot; is a coordinate where repeating values represent a</span>
<span class="sd">        single group, such as a month coordinate on a daily time slice.</span>
<span class="sd">        Repeated values will form a group even if they are not consecutive.</span>

<span class="sd">        The group coordinates must all be over the same cube dimension. Each</span>
<span class="sd">        common value group identified over all the group-by coordinates is</span>
<span class="sd">        collapsed using the provided aggregator.</span>

<span class="sd">        Args:</span>

<span class="sd">        * coords (list of coord names or :class:`iris.coords.Coord` instances):</span>
<span class="sd">            One or more coordinates over which group aggregation is to be</span>
<span class="sd">            performed.</span>
<span class="sd">        * aggregator (:class:`iris.analysis.Aggregator`):</span>
<span class="sd">            Aggregator to be applied to each group.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * kwargs:</span>
<span class="sd">            Aggregator and aggregation function keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`iris.cube.Cube`.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import iris</span>
<span class="sd">            &gt;&gt;&gt; import iris.analysis</span>
<span class="sd">            &gt;&gt;&gt; import iris.coord_categorisation as cat</span>
<span class="sd">            &gt;&gt;&gt; fname = iris.sample_data_path(&#39;ostia_monthly.nc&#39;)</span>
<span class="sd">            &gt;&gt;&gt; cube = iris.load_cube(fname, &#39;surface_temperature&#39;)</span>
<span class="sd">            &gt;&gt;&gt; cat.add_year(cube, &#39;time&#39;, name=&#39;year&#39;)</span>
<span class="sd">            &gt;&gt;&gt; new_cube = cube.aggregated_by(&#39;year&#39;, iris.analysis.MEAN)</span>
<span class="sd">            &gt;&gt;&gt; print(new_cube)</span>
<span class="sd">            surface_temperature / (K)           \</span>
<span class="sd">(time: 5; latitude: 18; longitude: 432)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      time                      \</span>
<span class="sd">     x            -              -</span>
<span class="sd">                      latitude                  \</span>
<span class="sd">     -            x              -</span>
<span class="sd">                      longitude                 \</span>
<span class="sd">     -            -              x</span>
<span class="sd">                 Auxiliary coordinates:</span>
<span class="sd">                      forecast_reference_time   \</span>
<span class="sd">     x            -              -</span>
<span class="sd">                      year                      \</span>
<span class="sd">     x            -              -</span>
<span class="sd">                 Scalar coordinates:</span>
<span class="sd">                      forecast_period: 0 hours</span>
<span class="sd">                 Attributes:</span>
<span class="sd">                      Conventions: CF-1.5</span>
<span class="sd">                      STASH: m01s00i024</span>
<span class="sd">                 Cell methods:</span>
<span class="sd">                      mean: month, year</span>
<span class="sd">                      mean: year</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">groupby_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dimension_to_groupby</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># We can&#39;t handle weights</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">aggregator</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">WeightedAggregator</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">uses_weighting</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid Aggregation, aggregated_by() cannot use&quot;</span> <span class="s2">&quot; weights.&quot;</span>
            <span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_list_of_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">metadata</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Cannot aggregate_by coord </span><span class="si">%s</span><span class="s2"> as it is &quot;</span>
                    <span class="s2">&quot;multidimensional.&quot;</span> <span class="o">%</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dimension</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s1">&#39;Cannot group-by the coordinate &quot;</span><span class="si">%s</span><span class="s1">&quot;, as its &#39;</span>
                    <span class="s2">&quot;dimension does not describe any data.&quot;</span> <span class="o">%</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateCollapseError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dimension_to_groupby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dimension_to_groupby</span> <span class="o">=</span> <span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dimension_to_groupby</span> <span class="o">!=</span> <span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot group-by coordinates over different dimensions.&quot;</span>
                <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateCollapseError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">groupby_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="c1"># Determine the other coordinates that share the same group-by</span>
        <span class="c1"># coordinate dimension.</span>
        <span class="n">shared_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">coord_</span><span class="p">:</span> <span class="n">coord_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groupby_coords</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">contains_dimension</span><span class="o">=</span><span class="n">dimension_to_groupby</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Determine which of each shared coord&#39;s dimensions will be aggregated.</span>
        <span class="n">shared_coords_and_dims</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">coord_</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="n">shared_coords</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord_</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="n">dimension_to_groupby</span>
        <span class="p">]</span>

        <span class="c1"># Create the aggregation group-by instance.</span>
        <span class="n">groupby</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">_Groupby</span><span class="p">(</span>
            <span class="n">groupby_coords</span><span class="p">,</span> <span class="n">shared_coords_and_dims</span>
        <span class="p">)</span>

        <span class="c1"># Create the resulting aggregate-by cube and remove the original</span>
        <span class="c1"># coordinates that are going to be groupedby.</span>
        <span class="n">aggregateby_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_strip_metadata_from_dims</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">dimension_to_groupby</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="c1"># Generate unique index tuple key to maintain monotonicity.</span>
        <span class="n">key</span><span class="p">[</span><span class="n">dimension_to_groupby</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groupby</span><span class="p">)))</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">aggregateby_cube</span> <span class="o">=</span> <span class="n">aggregateby_cube</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">groupby_coords</span> <span class="o">+</span> <span class="n">shared_coords</span><span class="p">:</span>
            <span class="n">aggregateby_cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="c1"># Determine the group-by cube data shape.</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">aggregate_shape</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="n">data_shape</span><span class="p">[</span><span class="n">dimension_to_groupby</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">groupby</span><span class="p">)</span>

        <span class="c1"># Aggregate the group-by data.</span>
        <span class="k">if</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">lazy_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
            <span class="n">front_slice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">dimension_to_groupby</span>
            <span class="n">back_slice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">data_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">dimension_to_groupby</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">groupby_subcubes</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">groupby_slice</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span>
                    <span class="n">front_slice</span> <span class="o">+</span> <span class="p">(</span><span class="n">groupby_slice</span><span class="p">,)</span> <span class="o">+</span> <span class="n">back_slice</span>
                <span class="p">]</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">(),</span>
                <span class="n">groupby</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="n">agg</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">aggregator</span><span class="o">.</span><span class="n">lazy_aggregate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dimension_to_groupby</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="n">groupby_subcubes</span><span class="p">))</span>
            <span class="n">aggregateby_data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dimension_to_groupby</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cube_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">groupby_slice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groupby</span><span class="o">.</span><span class="n">group</span><span class="p">()):</span>
                <span class="c1"># Slice the cube with the group-by slice to create a group-by</span>
                <span class="c1"># sub-cube.</span>
                <span class="n">cube_slice</span><span class="p">[</span><span class="n">dimension_to_groupby</span><span class="p">]</span> <span class="o">=</span> <span class="n">groupby_slice</span>
                <span class="n">groupby_sub_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cube_slice</span><span class="p">)]</span>
                <span class="c1"># Perform the aggregation over the group-by sub-cube and</span>
                <span class="c1"># repatriate the aggregated data into the aggregate-by</span>
                <span class="c1"># cube data.</span>
                <span class="n">cube_slice</span><span class="p">[</span><span class="n">dimension_to_groupby</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
                    <span class="n">groupby_sub_cube</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dimension_to_groupby</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>

                <span class="c1"># Determine aggregation result data type for the aggregate-by</span>
                <span class="c1"># cube data on first pass.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                        <span class="n">aggregateby_data</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                            <span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">aggregateby_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                            <span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span>
                        <span class="p">)</span>
                <span class="n">aggregateby_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cube_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>

        <span class="c1"># Add the aggregation meta data to the aggregate-by cube.</span>
        <span class="n">aggregator</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span>
            <span class="n">aggregateby_cube</span><span class="p">,</span> <span class="n">groupby_coords</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="c1"># Replace the appropriate coordinates within the aggregate-by cube.</span>
        <span class="p">(</span><span class="n">dim_coord</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimension_to_groupby</span><span class="p">,</span> <span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">dim_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">dim_coord</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">coord</span><span class="o">.</span><span class="n">metadata</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">aggregateby_cube</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">(</span>
                    <span class="n">coord</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">dimension_to_groupby</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aggregateby_cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span>
                    <span class="n">coord</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># Attach the aggregate-by data into the aggregate-by cube.</span>
        <span class="n">aggregateby_cube</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span>
            <span class="n">aggregateby_cube</span><span class="p">,</span> <span class="n">aggregateby_data</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">aggregateby_cube</span></div>

<div class="viewcode-block" id="Cube.rolling_window"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.rolling_window">[docs]</a>    <span class="k">def</span> <span class="nf">rolling_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">aggregator</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform rolling window aggregation on a cube given a coordinate, an</span>
<span class="sd">        aggregation method and a window size.</span>

<span class="sd">        Args:</span>

<span class="sd">        * coord (string/:class:`iris.coords.Coord`):</span>
<span class="sd">            The coordinate over which to perform the rolling window</span>
<span class="sd">            aggregation.</span>
<span class="sd">        * aggregator (:class:`iris.analysis.Aggregator`):</span>
<span class="sd">            Aggregator to be applied to the data.</span>
<span class="sd">        * window (int):</span>
<span class="sd">            Size of window to use.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * kwargs:</span>
<span class="sd">            Aggregator and aggregation function keyword arguments. The weights</span>
<span class="sd">            argument to the aggregator, if any, should be a 1d array with the</span>
<span class="sd">            same length as the chosen window.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`iris.cube.Cube`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation does not yet have support for lazy evaluation.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import iris, iris.analysis</span>
<span class="sd">            &gt;&gt;&gt; fname = iris.sample_data_path(&#39;GloSea4&#39;, &#39;ensemble_010.pp&#39;)</span>
<span class="sd">            &gt;&gt;&gt; air_press = iris.load_cube(fname, &#39;surface_temperature&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(air_press)</span>
<span class="sd">            surface_temperature / (K)           \</span>
<span class="sd">(time: 6; latitude: 145; longitude: 192)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      time                      \</span>
<span class="sd">     x            -               -</span>
<span class="sd">                      latitude                  \</span>
<span class="sd">     -            x               -</span>
<span class="sd">                      longitude                 \</span>
<span class="sd">     -            -               x</span>
<span class="sd">                 Auxiliary coordinates:</span>
<span class="sd">                      forecast_period           \</span>
<span class="sd">     x            -               -</span>
<span class="sd">                 Scalar coordinates:</span>
<span class="sd">                      forecast_reference_time: 2011-07-23 00:00:00</span>
<span class="sd">                      realization: 10</span>
<span class="sd">                 Attributes:</span>
<span class="sd">                      STASH: m01s00i024</span>
<span class="sd">                      source: Data from Met Office Unified Model</span>
<span class="sd">                      um_version: 7.6</span>
<span class="sd">                 Cell methods:</span>
<span class="sd">                      mean: time (1 hour)</span>


<span class="sd">            &gt;&gt;&gt; print(air_press.rolling_window(&#39;time&#39;, iris.analysis.MEAN, 3))</span>
<span class="sd">            surface_temperature / (K)           \</span>
<span class="sd">(time: 4; latitude: 145; longitude: 192)</span>
<span class="sd">                 Dimension coordinates:</span>
<span class="sd">                      time                      \</span>
<span class="sd">     x            -               -</span>
<span class="sd">                      latitude                  \</span>
<span class="sd">     -            x               -</span>
<span class="sd">                      longitude                 \</span>
<span class="sd">     -            -               x</span>
<span class="sd">                 Auxiliary coordinates:</span>
<span class="sd">                      forecast_period           \</span>
<span class="sd">     x            -               -</span>
<span class="sd">                 Scalar coordinates:</span>
<span class="sd">                      forecast_reference_time: 2011-07-23 00:00:00</span>
<span class="sd">                      realization: 10</span>
<span class="sd">                 Attributes:</span>
<span class="sd">                      STASH: m01s00i024</span>
<span class="sd">                      source: Data from Met Office Unified Model</span>
<span class="sd">                      um_version: 7.6</span>
<span class="sd">                 Cell methods:</span>
<span class="sd">                      mean: time (1 hour)</span>
<span class="sd">                      mean: time</span>


<span class="sd">            Notice that the forecast_period dimension now represents the 4</span>
<span class="sd">            possible windows of size 3 from the original cube.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_list_of_coords</span><span class="p">(</span><span class="n">coord</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">NotYetImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Rolling window over a circular coordinate.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">window</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot perform rolling window &quot;</span>
                <span class="s2">&quot;with a window size less than 2.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateCollapseError</span><span class="p">(</span>
                <span class="s1">&#39;Cannot perform rolling window with coordinate &quot;</span><span class="si">%s</span><span class="s1">&quot;, &#39;</span>
                <span class="s2">&quot;must map to one data dimension.&quot;</span> <span class="o">%</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Use indexing to get a result-cube of the correct shape.</span>
        <span class="c1"># NB. This indexes the data array which is wasted work.</span>
        <span class="c1"># As index-to-get-shape-then-fiddle is a common pattern, perhaps</span>
        <span class="c1"># some sort of `cube.prepare()` method would be handy to allow</span>
        <span class="c1"># re-shaping with given data, and returning a mapping of</span>
        <span class="c1"># old-to-new-coords (to avoid having to use metadata identity)?</span>
        <span class="n">new_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_strip_metadata_from_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">dimension</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">key</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">-</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">new_cube</span> <span class="o">=</span> <span class="n">new_cube</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>

        <span class="c1"># take a view of the original data using the rolling_window function</span>
        <span class="c1"># this will add an extra dimension to the data at dimension + 1 which</span>
        <span class="c1"># represents the rolled window (i.e. will have a length of window)</span>
        <span class="n">rolling_window_data</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dimension</span>
        <span class="p">)</span>

        <span class="c1"># now update all of the coordinates to reflect the aggregation</span>
        <span class="k">for</span> <span class="n">coord_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="n">dimension</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coord_</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The bounds of coordinate </span><span class="si">%r</span><span class="s2"> were ignored in &quot;</span>
                    <span class="s2">&quot;the rolling window operation.&quot;</span> <span class="o">%</span> <span class="n">coord_</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">coord_</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot calculate the rolling &quot;</span>
                    <span class="s2">&quot;window of </span><span class="si">%s</span><span class="s2"> as it is a multidimensional &quot;</span>
                    <span class="s2">&quot;coordinate.&quot;</span> <span class="o">%</span> <span class="n">coord_</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="n">new_bounds</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">coord_</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">new_bounds</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">):</span>
                <span class="c1"># Handle case where the AuxCoord contains string. The points</span>
                <span class="c1"># are the serialized form of the points contributing to each</span>
                <span class="c1"># window and the bounds are the first and last points in the</span>
                <span class="c1"># window as with numeric coordinates.</span>
                <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_bounds</span>
                <span class="p">)</span>
                <span class="n">new_bounds</span> <span class="o">=</span> <span class="n">new_bounds</span><span class="p">[:,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Take the first and last element of the rolled window (i.e.</span>
                <span class="c1"># the bounds) and the new points are the midpoints of these</span>
                <span class="c1"># bounds.</span>
                <span class="n">new_bounds</span> <span class="o">=</span> <span class="n">new_bounds</span><span class="p">[:,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">new_bounds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># wipe the coords points and set the bounds</span>
            <span class="n">new_coord</span> <span class="o">=</span> <span class="n">new_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">coord_</span><span class="p">)</span>
            <span class="n">new_coord</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">new_points</span>
            <span class="n">new_coord</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">new_bounds</span>

        <span class="c1"># update the metadata of the cube itself</span>
        <span class="n">aggregator</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span>
            <span class="n">new_cube</span><span class="p">,</span>
            <span class="p">[</span><span class="n">coord</span><span class="p">],</span>
            <span class="n">action</span><span class="o">=</span><span class="s2">&quot;with a rolling window of length </span><span class="si">%s</span><span class="s2"> over&quot;</span> <span class="o">%</span> <span class="n">window</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># and perform the data transformation, generating weights first if</span>
        <span class="c1"># needed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">aggregator</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">WeightedAggregator</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">uses_weighting</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;weights&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">window</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Weights for rolling window aggregation &quot;</span>
                        <span class="s2">&quot;must be a 1d array with the same length &quot;</span>
                        <span class="s2">&quot;as the window.&quot;</span>
                    <span class="p">)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">broadcast_to_shape</span><span class="p">(</span>
                    <span class="n">weights</span><span class="p">,</span> <span class="n">rolling_window_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span>
                <span class="p">)</span>
        <span class="n">data_result</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">rolling_window_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">aggregator</span><span class="o">.</span><span class="n">post_process</span><span class="p">(</span>
            <span class="n">new_cube</span><span class="p">,</span> <span class="n">data_result</span><span class="p">,</span> <span class="p">[</span><span class="n">coord</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Cube.interpolate"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">collapse_scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate from this :class:`~iris.cube.Cube` to the given</span>
<span class="sd">        sample points using the given interpolation scheme.</span>

<span class="sd">        Args:</span>

<span class="sd">        * sample_points:</span>
<span class="sd">            A sequence of (coordinate, points) pairs over which to</span>
<span class="sd">            interpolate. The values for coordinates that correspond to</span>
<span class="sd">            dates or times may optionally be supplied as datetime.datetime or</span>
<span class="sd">            cftime.datetime instances.</span>
<span class="sd">        * scheme:</span>
<span class="sd">            The type of interpolation to use to interpolate from this</span>
<span class="sd">            :class:`~iris.cube.Cube` to the given sample points. The</span>
<span class="sd">            interpolation schemes currently available in Iris are:</span>

<span class="sd">                * :class:`iris.analysis.Linear`, and</span>
<span class="sd">                * :class:`iris.analysis.Nearest`.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * collapse_scalar:</span>
<span class="sd">            Whether to collapse the dimension of scalar sample points</span>
<span class="sd">            in the resulting cube. Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A cube interpolated at the given sample points.</span>
<span class="sd">            If `collapse_scalar` is True then the dimensionality of the cube</span>
<span class="sd">            will be the number of original cube dimensions minus</span>
<span class="sd">            the number of scalar coordinates.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import datetime</span>
<span class="sd">            &gt;&gt;&gt; import iris</span>
<span class="sd">            &gt;&gt;&gt; path = iris.sample_data_path(&#39;uk_hires.pp&#39;)</span>
<span class="sd">            &gt;&gt;&gt; cube = iris.load_cube(path, &#39;air_potential_temperature&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(cube.summary(shorten=True))</span>
<span class="sd">            air_potential_temperature / (K)     \</span>
<span class="sd">(time: 3; model_level_number: 7; grid_latitude: 204; grid_longitude: 187)</span>
<span class="sd">            &gt;&gt;&gt; print(cube.coord(&#39;time&#39;))</span>
<span class="sd">            DimCoord([2009-11-19 10:00:00, 2009-11-19 11:00:00, \</span>
<span class="sd">2009-11-19 12:00:00], standard_name=&#39;time&#39;, calendar=&#39;gregorian&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(cube.coord(&#39;time&#39;).points)</span>
<span class="sd">            [349618. 349619. 349620.]</span>
<span class="sd">            &gt;&gt;&gt; samples = [(&#39;time&#39;, 349618.5)]</span>
<span class="sd">            &gt;&gt;&gt; result = cube.interpolate(samples, iris.analysis.Linear())</span>
<span class="sd">            &gt;&gt;&gt; print(result.summary(shorten=True))</span>
<span class="sd">            air_potential_temperature / (K)     \</span>
<span class="sd">(model_level_number: 7; grid_latitude: 204; grid_longitude: 187)</span>
<span class="sd">            &gt;&gt;&gt; print(result.coord(&#39;time&#39;))</span>
<span class="sd">            DimCoord([2009-11-19 10:30:00], standard_name=&#39;time&#39;, \</span>
<span class="sd">calendar=&#39;gregorian&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(result.coord(&#39;time&#39;).points)</span>
<span class="sd">            [349618.5]</span>
<span class="sd">            &gt;&gt;&gt; # For datetime-like coordinates, we can also use</span>
<span class="sd">            &gt;&gt;&gt; # datetime-like objects.</span>
<span class="sd">            &gt;&gt;&gt; samples = [(&#39;time&#39;, datetime.datetime(2009, 11, 19, 10, 30))]</span>
<span class="sd">            &gt;&gt;&gt; result2 = cube.interpolate(samples, iris.analysis.Linear())</span>
<span class="sd">            &gt;&gt;&gt; print(result2.summary(shorten=True))</span>
<span class="sd">            air_potential_temperature / (K)     \</span>
<span class="sd">(model_level_number: 7; grid_latitude: 204; grid_longitude: 187)</span>
<span class="sd">            &gt;&gt;&gt; print(result2.coord(&#39;time&#39;))</span>
<span class="sd">            DimCoord([2009-11-19 10:30:00], standard_name=&#39;time&#39;, \</span>
<span class="sd">calendar=&#39;gregorian&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(result2.coord(&#39;time&#39;).points)</span>
<span class="sd">            [349618.5]</span>
<span class="sd">            &gt;&gt;&gt; print(result == result2)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sample_points</span><span class="p">)</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">scheme</span><span class="o">.</span><span class="n">interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">collapse_scalar</span><span class="o">=</span><span class="n">collapse_scalar</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cube.regrid"><a class="viewcode-back" href="../../generated/api/iris/cube.html#iris.cube.Cube.regrid">[docs]</a>    <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">scheme</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Regrid this :class:`~iris.cube.Cube` on to the given target `grid`</span>
<span class="sd">        using the given regridding `scheme`.</span>

<span class="sd">        Args:</span>

<span class="sd">        * grid:</span>
<span class="sd">            A :class:`~iris.cube.Cube` that defines the target grid.</span>
<span class="sd">        * scheme:</span>
<span class="sd">            The type of regridding to use to regrid this cube onto the</span>
<span class="sd">            target grid. The regridding schemes in Iris currently include:</span>

<span class="sd">                * :class:`iris.analysis.Linear`\*,</span>
<span class="sd">                * :class:`iris.analysis.Nearest`\*,</span>
<span class="sd">                * :class:`iris.analysis.AreaWeighted`\*,</span>
<span class="sd">                * :class:`iris.analysis.UnstructuredNearest`,</span>
<span class="sd">                * :class:`iris.analysis.PointInCell`,</span>

<span class="sd">            \* Supports lazy regridding.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A cube defined with the horizontal dimensions of the target grid</span>
<span class="sd">            and the other dimensions from this cube. The data values of</span>
<span class="sd">            this cube will be converted to values on the new grid</span>
<span class="sd">            according to the given regridding scheme.</span>

<span class="sd">            The returned cube will have lazy data if the original cube has</span>
<span class="sd">            lazy data and the regridding scheme supports lazy regridding.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Both the source and target cubes must have a CoordSystem, otherwise</span>
<span class="sd">            this function is not applicable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regridder</span> <span class="o">=</span> <span class="n">scheme</span><span class="o">.</span><span class="n">regridder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">regridder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">ClassDict</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mapping that stores objects keyed on their superclasses and their names.</span>

<span class="sd">    The mapping has a root class, all stored objects must be a subclass of the</span>
<span class="sd">    root class. The superclasses used for an object include the class of the</span>
<span class="sd">    object, but do not include the root class. Only one object is allowed for</span>
<span class="sd">    any key.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">superclass</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">superclass</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The superclass must be a Python type or new &quot;</span> <span class="s2">&quot;style class.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_superclass</span> <span class="o">=</span> <span class="n">superclass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basic_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_retrieval_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">object_</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an object to the dictionary.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">object_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_superclass</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Only subclasses of </span><span class="si">{!r}</span><span class="s2"> are allowed as values.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_superclass</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Find all the superclasses of the given object, starting with the</span>
        <span class="c1"># object&#39;s class.</span>
        <span class="n">superclasses</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">mro</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">object_</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replace</span><span class="p">:</span>
            <span class="c1"># Ensure nothing else is already registered against those</span>
            <span class="c1"># superclasses.</span>
            <span class="c1"># NB. This implies the _basic_map will also be empty for this</span>
            <span class="c1"># object.</span>
            <span class="k">for</span> <span class="n">key_class</span> <span class="ow">in</span> <span class="n">superclasses</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key_class</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieval_map</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Cannot add instance of &#39;</span><span class="si">%s</span><span class="s2">&#39; because instance of &quot;</span>
                        <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; already added.&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">object_</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">key_class</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Register the given object against those superclasses.</span>
        <span class="k">for</span> <span class="n">key_class</span> <span class="ow">in</span> <span class="n">superclasses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_retrieval_map</span><span class="p">[</span><span class="n">key_class</span><span class="p">]</span> <span class="o">=</span> <span class="n">object_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_retrieval_map</span><span class="p">[</span><span class="n">key_class</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">object_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basic_map</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">object_</span><span class="p">)]</span> <span class="o">=</span> <span class="n">object_</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieval_map</span><span class="p">[</span><span class="n">class_</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Coordinate system </span><span class="si">%r</span><span class="s2"> does not exist.&quot;</span> <span class="o">%</span> <span class="n">class_</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You must call the add method instead.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">class_</span><span class="p">]</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieval_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">cs</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieval_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_map</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">cs</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">cs</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basic_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_map</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the keys of the dictionary mapping.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">sorted_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the axis names sorted alphabetically, with the exception that</span>
<span class="sd">    &#39;t&#39;, &#39;z&#39;, &#39;y&#39;, and, &#39;x&#39; are sorted to the end.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="n">axes</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="p">({</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">name</span><span class="p">),</span>
    <span class="p">)</span>


<span class="c1"># See Cube.slice() for the definition/context.</span>
<span class="k">class</span> <span class="nc">_SliceIterator</span><span class="p">(</span><span class="n">Iterator</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">dims_index</span><span class="p">,</span> <span class="n">requested_dims</span><span class="p">,</span> <span class="n">ordered</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cube</span> <span class="o">=</span> <span class="n">cube</span>

        <span class="c1"># Let Numpy do some work in providing all of the permutations of our</span>
        <span class="c1"># data shape. This functionality is something like:</span>
        <span class="c1"># ndindex(2, 1, 3) -&gt; [(0, 0, 0), (0, 0, 1), (0, 0, 2),</span>
        <span class="c1">#                      (1, 0, 0), (1, 0, 1), (1, 0, 2)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ndindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">dims_index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_requested_dims</span> <span class="o">=</span> <span class="n">requested_dims</span>
        <span class="c1"># indexing relating to sliced cube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mod_requested_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">requested_dims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered</span> <span class="o">=</span> <span class="n">ordered</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># NB. When self._ndindex runs out it will raise StopIteration for us.</span>
        <span class="n">index_tuple</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ndindex</span><span class="p">)</span>

        <span class="c1"># Turn the given tuple into a list so that we can do something with it</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index_tuple</span><span class="p">)</span>

        <span class="c1"># For each of the spanning dimensions requested, replace the 0 with a</span>
        <span class="c1"># spanning slice</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_requested_dims</span><span class="p">:</span>
            <span class="n">index_list</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Request the slice</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cube</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index_list</span><span class="p">)]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mod_requested_dims</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">)))):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mod_requested_dims</span><span class="p">)</span>
                <span class="n">sliced_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">sliced_dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mod_requested_dims</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">cube</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">sliced_dims</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cube</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        
        &copy; <a href="../../copyright.html">Copyright</a> Iris Contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>