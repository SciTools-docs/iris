

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>iris.util &mdash; Iris 3.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/theme_override.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/iris-logo-title.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installing.html">Installing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/gallery/index.html">Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/iris_cubes.html">Iris data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/loading_iris_cubes.html">Loading Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/saving_iris_cubes.html">Saving Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/navigating_a_cube.html">Navigating a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/subsetting_a_cube.html">Subsetting a Cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/real_and_lazy_data.html">Real and Lazy Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/plotting_a_cube.html">Plotting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/interpolation_and_regridding.html">Cube interpolation and regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/merge_and_concat.html">Merge and concatenate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_statistics.html">Cube statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_maths.html">Basic cube mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/citation.html">Citing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/code_maintenance.html">Code maintenance</a></li>
</ul>
<p class="caption"><span class="caption-text">Developers Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_documentation.html">Contributing to the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/documenting/index.html">Documentation in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/gitwash/index.html">Working with <em>iris</em> source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/code_format.html">Code formatting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/pulls.html">Pull request check List</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/tests.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/deprecations.html">Deprecations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/release.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/iris.html">Iris API</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../whatsnew/index.html">Whatâ€™s new in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../techpapers/index.html">Iris Technical Papers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Iris copyright, licensing and contributors</a></li>
</ul>

            
          

    
    
    
        <p class="caption">
            <span class="caption-text">
            
                Support
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SciTools/iris"><i class="fa fa-github fa-fw"></i> Source Code</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris"><i class="fa fa-comments fa-fw"></i> Users Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris-dev"><i class="fa fa-comments fa-fw"></i> Developers Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://stackoverflow.com/questions/tagged/python-iris"><i class="fa fa-question fa-fw"></i> StackOverflow For "How do I?"</a></li>
            
                <li class="toctree-l1"><a href="https://scitools.org.uk/iris/docs/v2.4.0/index.html"><i class="fa fa-book fa-fw"></i> Legacy documentation</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Iris</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../iris.html">iris</a> &raquo;</li>
        
      <li>iris.util</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for iris.util</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Iris contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Iris and is released under the LGPL license.</span>
<span class="c1"># See COPYING and COPYING.LESSER in the root of the repository for full</span>
<span class="c1"># licensing details.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Miscellaneous utility functions.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Hashable</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="kn">import</span> <span class="nn">cf_units</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="kn">import</span> <span class="nn">iris</span>
<span class="kn">import</span> <span class="nn">iris.coords</span>
<span class="kn">import</span> <span class="nn">iris.exceptions</span>
<span class="kn">import</span> <span class="nn">iris.cube</span>


<div class="viewcode-block" id="broadcast_to_shape"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.broadcast_to_shape">[docs]</a><span class="k">def</span> <span class="nf">broadcast_to_shape</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dim_map</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Broadcast an array to a given shape.</span>

<span class="sd">    Each dimension of the array must correspond to a dimension in the</span>
<span class="sd">    given shape. Striding is used to repeat the array until it matches</span>
<span class="sd">    the desired shape, returning repeated views on the original array.</span>
<span class="sd">    If you need to write to the resulting array, make a copy first.</span>

<span class="sd">    Args:</span>

<span class="sd">    * array (:class:`numpy.ndarray`-like)</span>
<span class="sd">        An array to broadcast.</span>

<span class="sd">    * shape (:class:`list`, :class:`tuple` etc.):</span>
<span class="sd">        The shape the array should be broadcast to.</span>

<span class="sd">    * dim_map (:class:`list`, :class:`tuple` etc.):</span>
<span class="sd">        A mapping of the dimensions of *array* to their corresponding</span>
<span class="sd">        element in *shape*. *dim_map* must be the same length as the</span>
<span class="sd">        number of dimensions in *array*. Each element of *dim_map*</span>
<span class="sd">        corresponds to a dimension of *array* and its value provides</span>
<span class="sd">        the index in *shape* which the dimension of *array* corresponds</span>
<span class="sd">        to, so the first element of *dim_map* gives the index of *shape*</span>
<span class="sd">        that corresponds to the first dimension of *array* etc.</span>

<span class="sd">    Examples:</span>

<span class="sd">    Broadcasting an array of shape (2, 3) to the shape (5, 2, 6, 3)</span>
<span class="sd">    where the first dimension of the array corresponds to the second</span>
<span class="sd">    element of the desired shape and the second dimension of the array</span>
<span class="sd">    corresponds to the fourth element of the desired shape::</span>

<span class="sd">        a = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">        b = broadcast_to_shape(a, (5, 2, 6, 3), (1, 3))</span>

<span class="sd">    Broadcasting an array of shape (48, 96) to the shape (96, 48, 12)::</span>

<span class="sd">        # a is an array of shape (48, 96)</span>
<span class="sd">        result = broadcast_to_shape(a, (96, 48, 12), (1, 0))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_map</span><span class="p">)</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="c1"># We must check for this condition here because we cannot rely on</span>
        <span class="c1"># getting an error from numpy if the dim_map argument is not the</span>
        <span class="c1"># correct length, we might just get a segfault.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;dim_map must have an entry for every &quot;</span>
            <span class="s2">&quot;dimension of the input array&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_broadcast_helper</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idim</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dim_map</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idim</span><span class="p">]:</span>
                <span class="c1"># We&#39;ll get garbage values if the dimensions of array are not</span>
                <span class="c1"># those indicated by shape.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape and array are not compatible&quot;</span><span class="p">)</span>
            <span class="n">strides</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span>

    <span class="n">array_view</span> <span class="o">=</span> <span class="n">_broadcast_helper</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># Degenerate masks can be applied as-is.</span>
            <span class="n">mask_view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mask arrays need to be handled in the same way as the data array.</span>
            <span class="n">mask_view</span> <span class="o">=</span> <span class="n">_broadcast_helper</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">array_view</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array_view</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_view</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array_view</span></div>


<div class="viewcode-block" id="delta"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.delta">[docs]</a><span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">circular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the difference between values along a given dimension.</span>

<span class="sd">    Args:</span>

<span class="sd">    * ndarray:</span>
<span class="sd">        The array over which to do the difference.</span>

<span class="sd">    * dimension:</span>
<span class="sd">        The dimension over which to do the difference on ndarray.</span>

<span class="sd">    * circular:</span>
<span class="sd">        If not False then return n results in the requested dimension</span>
<span class="sd">        with the delta between the last and first element included in</span>
<span class="sd">        the result otherwise the result will be of length n-1 (where n</span>
<span class="sd">        is the length of ndarray in the given dimension&#39;s direction)</span>

<span class="sd">        If circular is numeric then the value of circular will be added</span>
<span class="sd">        to the last element of the given dimension if the last element</span>
<span class="sd">        is negative, otherwise the value of circular will be subtracted</span>
<span class="sd">        from the last element.</span>

<span class="sd">        The example below illustrates the process::</span>

<span class="sd">            original array              -180, -90,  0,    90</span>
<span class="sd">            delta (with circular=360):    90,  90, 90, -270+360</span>

<span class="sd">    .. note::</span>

<span class="sd">        The difference algorithm implemented is forward difference:</span>

<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; import iris.util</span>
<span class="sd">            &gt;&gt;&gt; original = np.array([-180, -90, 0, 90])</span>
<span class="sd">            &gt;&gt;&gt; iris.util.delta(original, 0)</span>
<span class="sd">            array([90, 90, 90])</span>
<span class="sd">            &gt;&gt;&gt; iris.util.delta(original, 0, circular=360)</span>
<span class="sd">            array([90, 90, 90, 90])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">circular</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span>
        <span class="n">last_element</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">last_element</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">last_element</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">last_element</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circular</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ndarray</span><span class="p">[</span><span class="n">last_element</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">_delta</span><span class="p">[</span><span class="n">last_element</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_delta</span><span class="p">[</span><span class="n">last_element</span><span class="p">]</span> <span class="o">-=</span> <span class="n">circular</span>
            <span class="n">_delta</span><span class="p">[</span><span class="n">last_element</span><span class="p">][</span><span class="n">result</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">circular</span>

        <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">_delta</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">_delta</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_delta</span></div>


<div class="viewcode-block" id="describe_diff"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.describe_diff">[docs]</a><span class="k">def</span> <span class="nf">describe_diff</span><span class="p">(</span><span class="n">cube_a</span><span class="p">,</span> <span class="n">cube_b</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prints the differences that prevent compatibility between two cubes, as</span>
<span class="sd">    defined by :meth:`iris.cube.Cube.is_compatible()`.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube_a:</span>
<span class="sd">        An instance of :class:`iris.cube.Cube` or</span>
<span class="sd">        :class:`iris.cube.CubeMetadata`.</span>

<span class="sd">    * cube_b:</span>
<span class="sd">        An instance of :class:`iris.cube.Cube` or</span>
<span class="sd">        :class:`iris.cube.CubeMetadata`.</span>

<span class="sd">    * output_file:</span>
<span class="sd">        A :class:`file` or file-like object to receive output. Defaults to</span>
<span class="sd">        sys.stdout.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`iris.cube.Cube.is_compatible()`</span>

<span class="sd">    .. note::</span>

<span class="sd">        Compatibility does not guarantee that two cubes can be merged.</span>
<span class="sd">        Instead, this function is designed to provide a verbose description</span>
<span class="sd">        of the differences in metadata between two cubes. Determining whether</span>
<span class="sd">        two cubes will merge requires additional logic that is beyond the</span>
<span class="sd">        scope of this function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

    <span class="k">if</span> <span class="n">cube_a</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">cube_b</span><span class="p">):</span>
        <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Cubes are compatible</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">common_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cube_a</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cube_b</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">common_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cube_a</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cube_b</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot; cube_a attribute value &quot;</span><span class="si">%s</span><span class="s1">&quot; is not &#39;</span>
                    <span class="s2">&quot;compatible with cube_b &quot;</span>
                    <span class="s1">&#39;attribute value &quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">cube_a</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">cube_b</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">cube_a</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">!=</span> <span class="n">cube_b</span><span class="o">.</span><span class="n">name</span><span class="p">():</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s1">&#39;cube_a name &quot;</span><span class="si">%s</span><span class="s1">&quot; is not compatible &#39;</span>
                <span class="s1">&#39;with cube_b name &quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cube_a</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">cube_b</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">cube_a</span><span class="o">.</span><span class="n">units</span> <span class="o">!=</span> <span class="n">cube_b</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s1">&#39;cube_a units &quot;</span><span class="si">%s</span><span class="s1">&quot; are not compatible with cube_b units &quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">cube_a</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">cube_b</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">cube_a</span><span class="o">.</span><span class="n">cell_methods</span> <span class="o">!=</span> <span class="n">cube_b</span><span class="o">.</span><span class="n">cell_methods</span><span class="p">:</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;Cell methods</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">and</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">are not compatible</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">cube_a</span><span class="o">.</span><span class="n">cell_methods</span><span class="p">,</span> <span class="n">cube_b</span><span class="o">.</span><span class="n">cell_methods</span><span class="p">)</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="guess_coord_axis"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.guess_coord_axis">[docs]</a><span class="k">def</span> <span class="nf">guess_coord_axis</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a &quot;best guess&quot; axis name of the coordinate.</span>

<span class="sd">    Heuristic categorisation of the coordinate into either label</span>
<span class="sd">    &#39;T&#39;, &#39;Z&#39;, &#39;Y&#39;, &#39;X&#39; or None.</span>

<span class="sd">    Args:</span>

<span class="sd">    * coord:</span>
<span class="sd">        The :class:`iris.coords.Coord`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        &#39;T&#39;, &#39;Z&#39;, &#39;Y&#39;, &#39;X&#39;, or None.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">standard_name</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;grid_longitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;projection_x_coordinate&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="s2">&quot;X&quot;</span>
    <span class="k">elif</span> <span class="n">coord</span><span class="o">.</span><span class="n">standard_name</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;grid_latitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;projection_y_coordinate&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="s2">&quot;Y&quot;</span>
    <span class="k">elif</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_convertible</span><span class="p">(</span><span class="s2">&quot;hPa&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;positive&quot;</span>
    <span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span>
    <span class="k">elif</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">():</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span>

    <span class="k">return</span> <span class="n">axis</span></div>


<div class="viewcode-block" id="rolling_window"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.rolling_window">[docs]</a><span class="k">def</span> <span class="nf">rolling_window</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make an ndarray with a rolling window of the last dimension</span>

<span class="sd">    Args:</span>

<span class="sd">    * a : array_like</span>
<span class="sd">        Array to add rolling window to</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * window : int</span>
<span class="sd">        Size of rolling window</span>
<span class="sd">    * step : int</span>
<span class="sd">        Size of step between rolling windows</span>
<span class="sd">    * axis : int</span>
<span class="sd">        Axis to take the rolling window over</span>

<span class="sd">    Returns:</span>

<span class="sd">        Array that is a view of the original array with an added dimension</span>
<span class="sd">        of the size of the given window at axis + 1.</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; x = np.arange(10).reshape((2, 5))</span>
<span class="sd">        &gt;&gt;&gt; rolling_window(x, 3)</span>
<span class="sd">        array([[[0, 1, 2], [1, 2, 3], [2, 3, 4]],</span>
<span class="sd">               [[5, 6, 7], [6, 7, 8], [7, 8, 9]]])</span>

<span class="sd">    Calculate rolling mean of last dimension::</span>

<span class="sd">        &gt;&gt;&gt; np.mean(rolling_window(x, 3), -1)</span>
<span class="sd">        array([[ 1.,  2.,  3.],</span>
<span class="sd">               [ 6.,  7.,  8.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: The implementation of this function originates from</span>
    <span class="c1"># https://github.com/numpy/numpy/pull/31#issuecomment-1304851 04/08/2011</span>
    <span class="k">if</span> <span class="n">window</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`window` must be at least 1.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`window` is too long.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`step` must be at least 1.&quot;</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">num_windows</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">window</span> <span class="o">+</span> <span class="n">step</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_windows</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
        <span class="o">+</span> <span class="p">(</span><span class="n">step</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
    <span class="p">)</span>
    <span class="n">rw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">strides</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">step</span> <span class="o">*</span> <span class="n">mask</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">mask</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
            <span class="o">+</span> <span class="n">mask</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="p">)</span>
        <span class="n">rw</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">rw</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">rw</span></div>


<div class="viewcode-block" id="array_equal"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.array_equal">[docs]</a><span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">,</span> <span class="n">withnans</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns whether two arrays have the same shape and elements.</span>

<span class="sd">    Args:</span>

<span class="sd">    * array1, array2 (arraylike):</span>
<span class="sd">        args to be compared, after normalising with :func:`np.asarray`.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * withnans (bool):</span>
<span class="sd">        When unset (default), the result is False if either input contains NaN</span>
<span class="sd">        points.  This is the normal floating-point arithmetic result.</span>
<span class="sd">        When set, return True if inputs contain the same value in all elements,</span>
<span class="sd">        _including_ any NaN values.</span>

<span class="sd">    This provides much the same functionality as :func:`numpy.array_equal`, but</span>
<span class="sd">    with additional support for arrays of strings and NaN-tolerant operation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array1</span><span class="p">,</span> <span class="n">array2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array2</span><span class="p">)</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="n">array1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">array2</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">eq</span><span class="p">:</span>
        <span class="n">eqs</span> <span class="o">=</span> <span class="n">array1</span> <span class="o">==</span> <span class="n">array2</span>

        <span class="k">if</span> <span class="n">withnans</span> <span class="ow">and</span> <span class="p">(</span><span class="n">array1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span> <span class="ow">or</span> <span class="n">array2</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">):</span>
            <span class="n">nans1</span><span class="p">,</span> <span class="n">nans2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nans1</span> <span class="o">==</span> <span class="n">nans2</span><span class="p">):</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># simply fail</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eqs</span><span class="p">[</span><span class="n">nans1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># fix NaNs; check all the others</span>

        <span class="k">if</span> <span class="n">eq</span><span class="p">:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>  <span class="c1"># check equal at all points</span>

    <span class="k">return</span> <span class="n">eq</span></div>


<div class="viewcode-block" id="approx_equal"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.approx_equal">[docs]</a><span class="k">def</span> <span class="nf">approx_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">max_absolute_error</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">max_relative_error</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns whether two numbers are almost equal, allowing for the</span>
<span class="sd">    finite precision of floating point numbers.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Deal with numbers close to zero</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_absolute_error</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="c1"># Ensure we get consistent results if &quot;a&quot; and &quot;b&quot; are supplied in the</span>
    <span class="c1"># opposite order.</span>
    <span class="n">max_ab</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">abs</span><span class="p">)</span>
    <span class="n">relative_error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">max_ab</span>
    <span class="k">return</span> <span class="n">relative_error</span> <span class="o">&lt;</span> <span class="n">max_relative_error</span></div>


<div class="viewcode-block" id="between"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.between">[docs]</a><span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="n">lh</span><span class="p">,</span> <span class="n">rh</span><span class="p">,</span> <span class="n">lh_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rh_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides a convenient way of defining a 3 element inequality such as</span>
<span class="sd">    ``a &lt; number &lt; b``.</span>

<span class="sd">    Arguments:</span>

<span class="sd">    * lh</span>
<span class="sd">        The left hand element of the inequality</span>
<span class="sd">    * rh</span>
<span class="sd">        The right hand element of the inequality</span>

<span class="sd">    Keywords:</span>

<span class="sd">    * lh_inclusive - boolean</span>
<span class="sd">        Affects the left hand comparison operator to use in the inequality.</span>
<span class="sd">        True for ``&lt;=`` false for ``&lt;``. Defaults to True.</span>
<span class="sd">    * rh_inclusive - boolean</span>
<span class="sd">        Same as lh_inclusive but for right hand operator.</span>


<span class="sd">    For example::</span>

<span class="sd">        between_3_and_6 = between(3, 6)</span>
<span class="sd">        for i in range(10):</span>
<span class="sd">           print(i, between_3_and_6(i))</span>


<span class="sd">        between_3_and_6 = between(3, 6, rh_inclusive=False)</span>
<span class="sd">        for i in range(10):</span>
<span class="sd">           print(i, between_3_and_6(i))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lh_inclusive</span> <span class="ow">and</span> <span class="n">rh_inclusive</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">lh</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">rh</span>
    <span class="k">elif</span> <span class="n">lh_inclusive</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rh_inclusive</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">lh</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">rh</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">lh_inclusive</span> <span class="ow">and</span> <span class="n">rh_inclusive</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">lh</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">rh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">lh</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">rh</span></div>


<div class="viewcode-block" id="reverse"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.reverse">[docs]</a><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">cube_or_array</span><span class="p">,</span> <span class="n">coords_or_dims</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse the cube or array along the given dimensions.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube_or_array: :class:`iris.cube.Cube` or :class:`numpy.ndarray`</span>
<span class="sd">        The cube or array to reverse.</span>
<span class="sd">    * coords_or_dims: int, str, :class:`iris.coords.Coord` or sequence of these</span>
<span class="sd">        Identify one or more dimensions to reverse.  If cube_or_array is a</span>
<span class="sd">        numpy array, use int or a sequence of ints, as in the examples below.</span>
<span class="sd">        If cube_or_array is a Cube, a Coord or coordinate name (or sequence of</span>
<span class="sd">        these) may be specified instead.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.arange(24).reshape(2, 3, 4)</span>
<span class="sd">        &gt;&gt;&gt; print(a)</span>
<span class="sd">        [[[ 0  1  2  3]</span>
<span class="sd">          [ 4  5  6  7]</span>
<span class="sd">          [ 8  9 10 11]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">         [[12 13 14 15]</span>
<span class="sd">          [16 17 18 19]</span>
<span class="sd">          [20 21 22 23]]]</span>
<span class="sd">        &gt;&gt;&gt; print(reverse(a, 1))</span>
<span class="sd">        [[[ 8  9 10 11]</span>
<span class="sd">          [ 4  5  6  7]</span>
<span class="sd">          [ 0  1  2  3]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">         [[20 21 22 23]</span>
<span class="sd">          [16 17 18 19]</span>
<span class="sd">          [12 13 14 15]]]</span>
<span class="sd">        &gt;&gt;&gt; print(reverse(a, [1, 2]))</span>
<span class="sd">        [[[11 10  9  8]</span>
<span class="sd">          [ 7  6  5  4]</span>
<span class="sd">          [ 3  2  1  0]]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">         [[23 22 21 20]</span>
<span class="sd">          [19 18 17 16]</span>
<span class="sd">          [15 14 13 12]]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">cube_or_array</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords_or_dims</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;coords_or_dims must be int, str, coordinate or &quot;</span>
            <span class="s2">&quot;sequence of these.  Got cube.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">_is_single_item</span><span class="p">(</span><span class="n">coords_or_dims</span><span class="p">):</span>
        <span class="n">coords_or_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords_or_dims</span><span class="p">]</span>

    <span class="n">axes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">coord_or_dim</span> <span class="ow">in</span> <span class="n">coords_or_dims</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_or_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord_or_dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cube_or_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;To reverse an array, provide an int or sequence of ints.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cube_or_array</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord_or_dim</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;coords_or_dims must be int, str, coordinate &quot;</span>
                    <span class="s2">&quot;or sequence of these.&quot;</span>
                <span class="p">)</span>

    <span class="n">axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axes</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">axes</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Reverse was expecting a single axis or a 1d array &quot;</span>
            <span class="s2">&quot;of axes, got </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">axes</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cube_or_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;An axis value out of range for the number of &quot;</span>
            <span class="s2">&quot;dimensions from the given array (</span><span class="si">%s</span><span class="s2">) was received. &quot;</span>
            <span class="s2">&quot;Got: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cube_or_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
        <span class="n">index</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cube_or_array</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span></div>


<div class="viewcode-block" id="monotonic"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.monotonic">[docs]</a><span class="k">def</span> <span class="nf">monotonic</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_direction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether the given 1d array is monotonic.</span>

<span class="sd">    Note that, the array must not contain missing data.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * strict (boolean)</span>
<span class="sd">        Flag to enable strict monotonic checking</span>
<span class="sd">    * return_direction (boolean)</span>
<span class="sd">        Flag to change return behaviour to return</span>
<span class="sd">        (monotonic_status, direction). Direction will be 1 for positive</span>
<span class="sd">        or -1 for negative. The direction is meaningless if the array is</span>
<span class="sd">        not monotonic.</span>

<span class="sd">    Returns:</span>

<span class="sd">    * monotonic_status (boolean)</span>
<span class="sd">        Whether the array was monotonic.</span>

<span class="sd">        If the return_direction flag was given then the returned value</span>
<span class="sd">        will be:</span>

<span class="sd">            ``(monotonic_status, direction)``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The array to check must be 1 dimensional and have &quot;</span>
            <span class="s2">&quot;more than 1 element.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ma</span><span class="o">.</span><span class="n">count_masked</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The array to check contains missing data.&quot;</span><span class="p">)</span>

    <span class="c1"># Identify the directions of the largest/most-positive and</span>
    <span class="c1"># smallest/most-negative steps.</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="n">sign_max_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
    <span class="n">sign_min_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">monotonic</span> <span class="o">=</span> <span class="n">sign_max_d</span> <span class="o">==</span> <span class="n">sign_min_d</span> <span class="ow">and</span> <span class="n">sign_max_d</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">monotonic</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">sign_min_d</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sign_max_d</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">sign_max_d</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sign_min_d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">sign_min_d</span> <span class="o">==</span> <span class="n">sign_max_d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_direction</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sign_max_d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">sign_min_d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">sign_max_d</span>

        <span class="k">return</span> <span class="n">monotonic</span><span class="p">,</span> <span class="n">direction</span>

    <span class="k">return</span> <span class="n">monotonic</span></div>


<div class="viewcode-block" id="column_slices_generator"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.column_slices_generator">[docs]</a><span class="k">def</span> <span class="nf">column_slices_generator</span><span class="p">(</span><span class="n">full_slice</span><span class="p">,</span> <span class="n">ndims</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a full slice full of tuples, return a dictionary mapping old</span>
<span class="sd">    data dimensions to new and a generator which gives the successive</span>
<span class="sd">    slices needed to index correctly (across columns).</span>

<span class="sd">    This routine deals with the special functionality for tuple based</span>
<span class="sd">    indexing e.g. [0, (3, 5), :, (1, 6, 8)] by first providing a slice</span>
<span class="sd">    which takes the non tuple slices out first i.e. [0, :, :, :] then</span>
<span class="sd">    subsequently iterates through each of the tuples taking out the</span>
<span class="sd">    appropriate slices i.e. [(3, 5), :, :] followed by [:, :, (1, 6, 8)]</span>

<span class="sd">    This method was developed as numpy does not support the direct</span>
<span class="sd">    approach of [(3, 5), : , (1, 6, 8)] for column based indexing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">list_of_slices</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Map current dimensions to new dimensions, or None</span>
    <span class="n">dimension_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
    <span class="n">_count_current_dim</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">full_slice</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i_key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">dimension_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimension_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_count_current_dim</span>
            <span class="n">_count_current_dim</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Get all of the dimensions for which a tuple of indices were provided</span>
    <span class="c1"># (numpy.ndarrays are treated in the same way tuples in this case)</span>
    <span class="k">def</span> <span class="nf">is_tuple_style_index</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">)</span>

    <span class="n">tuple_indices</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">full_slice</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_tuple_style_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># stg1: Take a copy of the full_slice specification, turning all tuples</span>
    <span class="c1"># into a full slice</span>
    <span class="k">if</span> <span class="n">tuple_indices</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">full_slice</span><span class="p">))):</span>
        <span class="n">first_slice</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">full_slice</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tuple_index</span> <span class="ow">in</span> <span class="n">tuple_indices</span><span class="p">:</span>
            <span class="n">first_slice</span><span class="p">[</span><span class="n">tuple_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># turn first_slice back into a tuple ready for indexing</span>
        <span class="n">first_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">first_slice</span><span class="p">)</span>

        <span class="n">list_of_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_slice</span><span class="p">)</span>

    <span class="c1"># stg2 iterate over each of the tuples</span>
    <span class="k">for</span> <span class="n">tuple_index</span> <span class="ow">in</span> <span class="n">tuple_indices</span><span class="p">:</span>
        <span class="c1"># Create a list with the indices to span the whole data array that we</span>
        <span class="c1"># currently have</span>
        <span class="n">spanning_slice_with_tuple</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">_count_current_dim</span>
        <span class="c1"># Replace the slice(None, None) with our current tuple</span>
        <span class="n">spanning_slice_with_tuple</span><span class="p">[</span><span class="n">dimension_mapping</span><span class="p">[</span><span class="n">tuple_index</span><span class="p">]]</span> <span class="o">=</span> <span class="n">full_slice</span><span class="p">[</span>
            <span class="n">tuple_index</span>
        <span class="p">]</span>

        <span class="c1"># if we just have [(0, 1)] turn it into [(0, 1), ...] as this is</span>
        <span class="c1"># Numpy&#39;s syntax.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spanning_slice_with_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">spanning_slice_with_tuple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">Ellipsis</span><span class="p">)</span>

        <span class="n">spanning_slice_with_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spanning_slice_with_tuple</span><span class="p">)</span>

        <span class="n">list_of_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spanning_slice_with_tuple</span><span class="p">)</span>

    <span class="c1"># return the dimension mapping and a generator of slices</span>
    <span class="k">return</span> <span class="n">dimension_mapping</span><span class="p">,</span> <span class="nb">iter</span><span class="p">(</span><span class="n">list_of_slices</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_build_full_slice_given_keys</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">ndim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the keys passed to a __getitem__ call, build an equivalent</span>
<span class="sd">    tuple of keys which span ndims.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure that we always have a tuple of keys</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">keys</span><span class="p">])</span>

    <span class="c1"># catch the case where an extra Ellipsis has been provided which can be</span>
    <span class="c1"># discarded iff len(keys)-1 == ndim</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">ndim</span> <span class="ow">and</span> <span class="bp">Ellipsis</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">keys</span>
    <span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">is_ellipsis</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">is_ellipsis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

    <span class="c1"># for ndim &gt;= 1 appending a &quot;:&quot; to the slice specification is allowable,</span>
    <span class="c1"># remove this now</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ndim</span> <span class="ow">and</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
            <span class="s2">&quot;More slices requested than dimensions. Requested &quot;</span>
            <span class="s2">&quot;</span><span class="si">%r</span><span class="s2">, but there were only </span><span class="si">%s</span><span class="s2"> dimensions.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># For each dimension get the slice which has been requested.</span>
    <span class="c1"># If no slice provided, then default to the whole dimension</span>
    <span class="n">full_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>

            <span class="c1"># replace any subsequent Ellipsis objects in keys with</span>
            <span class="c1"># slice(None, None) as per Numpy</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="k">else</span> <span class="n">key</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># iterate over the remaining keys in reverse to fill in</span>
            <span class="c1"># the gaps from the right hand side</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">[:</span><span class="n">i</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">full_slice</span><span class="p">[</span><span class="o">-</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

            <span class="c1"># we&#39;ve finished with i now so stop the iteration</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">full_slice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

    <span class="c1"># remove any tuples on dimensions, turning them into numpy array&#39;s for</span>
    <span class="c1"># consistent behaviour</span>
    <span class="n">full_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">key</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">full_slice</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">full_slice</span>


<span class="k">def</span> <span class="nf">_slice_data_with_keys</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Index an array-like object as &quot;data[keys]&quot;, with orthogonal indexing.</span>

<span class="sd">    Args:</span>

<span class="sd">    * data (array-like):</span>
<span class="sd">        array to index.</span>

<span class="sd">    * keys (list):</span>
<span class="sd">        list of indexes, as received from a __getitem__ call.</span>

<span class="sd">    This enforces an orthogonal interpretation of indexing, which means that</span>
<span class="sd">    both &#39;real&#39; (numpy) arrays and other array-likes index in the same way,</span>
<span class="sd">    instead of numpy arrays doing &#39;fancy indexing&#39;.</span>

<span class="sd">    Returns (dim_map, data_region), where :</span>

<span class="sd">    * dim_map (dict) :</span>
<span class="sd">        A dimension map, as returned by :func:`column_slices_generator`.</span>
<span class="sd">        i.e. &quot;dim_map[old_dim_index]&quot; --&gt; &quot;new_dim_index&quot; or None.</span>

<span class="sd">    * data_region (array-like) :</span>
<span class="sd">        The sub-array.</span>

<span class="sd">    .. Note::</span>

<span class="sd">        Avoids copying the data, where possible.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Combines the use of _build_full_slice_given_keys and</span>
    <span class="c1"># column_slices_generator.</span>
    <span class="c1"># By slicing on only one index at a time, this also mostly avoids copying</span>
    <span class="c1"># the data, except some cases when a key contains a list of indices.</span>
    <span class="n">n_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">full_slice</span> <span class="o">=</span> <span class="n">_build_full_slice_given_keys</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">)</span>
    <span class="n">dims_mapping</span><span class="p">,</span> <span class="n">slices_iter</span> <span class="o">=</span> <span class="n">column_slices_generator</span><span class="p">(</span><span class="n">full_slice</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">this_slice</span> <span class="ow">in</span> <span class="n">slices_iter</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">this_slice</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Disallow slicings where a dimension has no points, like &quot;[5:5]&quot;.</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Cannot index with zero length slice.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dims_mapping</span><span class="p">,</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_wrap_function_for_method</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">docstring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a wrapper function modified to be suitable for use as a</span>
<span class="sd">    method.</span>

<span class="sd">    The wrapper function renames the first argument as &quot;self&quot; and allows</span>
<span class="sd">    an alternative docstring, thus allowing the built-in help(...)</span>
<span class="sd">    routine to display appropriate output.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate the Python source for the wrapper function.</span>
    <span class="c1"># NB. The first argument is replaced with &quot;self&quot;.</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">varargs</span><span class="p">,</span> <span class="n">varkw</span><span class="p">,</span> <span class="n">defaults</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">defaults</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">basic_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;self&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">default_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">simple_default_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
        <span class="n">basic_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;self&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">cutoff</span><span class="p">]</span>
        <span class="n">default_args</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">cutoff</span><span class="p">:],</span> <span class="n">defaults</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">simple_default_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">cutoff</span><span class="p">:]</span>
    <span class="n">var_arg</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">varargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;*&quot;</span> <span class="o">+</span> <span class="n">varargs</span><span class="p">]</span>
    <span class="n">var_kw</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">varkw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;**&quot;</span> <span class="o">+</span> <span class="n">varkw</span><span class="p">]</span>
    <span class="n">arg_source</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">basic_args</span> <span class="o">+</span> <span class="n">default_args</span> <span class="o">+</span> <span class="n">var_arg</span> <span class="o">+</span> <span class="n">var_kw</span><span class="p">)</span>
    <span class="n">simple_arg_source</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">basic_args</span> <span class="o">+</span> <span class="n">simple_default_args</span> <span class="o">+</span> <span class="n">var_arg</span> <span class="o">+</span> <span class="n">var_kw</span>
    <span class="p">)</span>
    <span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;def </span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">):</span><span class="se">\n</span><span class="s2">    return function(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="n">arg_source</span><span class="p">,</span>
        <span class="n">simple_arg_source</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compile the wrapper function</span>
    <span class="c1"># NB. There&#39;s an outstanding bug with &quot;exec&quot; where the locals and globals</span>
    <span class="c1"># dictionaries must be the same if we&#39;re to get closure behaviour.</span>
    <span class="n">my_locals</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">function</span><span class="p">}</span>
    <span class="n">exec</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">my_locals</span><span class="p">,</span> <span class="n">my_locals</span><span class="p">)</span>

    <span class="c1"># Update the docstring if required, and return the modified function</span>
    <span class="n">wrapper</span> <span class="o">=</span> <span class="n">my_locals</span><span class="p">[</span><span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">docstring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">docstring</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">_MetaOrderedHashable</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A metaclass that ensures that non-abstract subclasses of _OrderedHashable</span>
<span class="sd">    without an explicit __init__ method are given a default __init__ method</span>
<span class="sd">    with the appropriate method signature.</span>

<span class="sd">    Also, an _init method is provided to allow subclasses with their own</span>
<span class="sd">    __init__ constructors to initialise their values via an explicit method</span>
<span class="sd">    signature.</span>

<span class="sd">    NB. This metaclass is used to construct the _OrderedHashable class as well</span>
<span class="sd">    as all its subclasses.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="c1"># We only want to modify concrete classes that have defined the</span>
        <span class="c1"># &quot;_names&quot; property.</span>
        <span class="k">if</span> <span class="s2">&quot;_names&quot;</span> <span class="ow">in</span> <span class="n">namespace</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="n">namespace</span><span class="p">[</span><span class="s2">&quot;_names&quot;</span><span class="p">],</span> <span class="s2">&quot;__isabstractmethod__&quot;</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">namespace</span><span class="p">[</span><span class="s2">&quot;_names&quot;</span><span class="p">])</span>

            <span class="c1"># Ensure the class has a constructor with explicit arguments.</span>
            <span class="k">if</span> <span class="s2">&quot;__init__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">:</span>
                <span class="c1"># Create a default __init__ method for the class</span>
                <span class="n">method_source</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;def __init__(self, </span><span class="si">%s</span><span class="s2">):</span><span class="se">\n</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;self._init_from_tuple((</span><span class="si">%s</span><span class="s2">,))&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">exec</span><span class="p">(</span><span class="n">method_source</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

            <span class="c1"># Ensure the class has a &quot;helper constructor&quot; with explicit</span>
            <span class="c1"># arguments.</span>
            <span class="k">if</span> <span class="s2">&quot;_init&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">:</span>
                <span class="c1"># Create a default _init method for the class</span>
                <span class="n">method_source</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;def _init(self, </span><span class="si">%s</span><span class="s2">):</span><span class="se">\n</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;self._init_from_tuple((</span><span class="si">%s</span><span class="s2">,))&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">exec</span><span class="p">(</span><span class="n">method_source</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">total_ordering</span>
<span class="k">class</span> <span class="nc">_OrderedHashable</span><span class="p">(</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_MetaOrderedHashable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience class for creating &quot;immutable&quot;, hashable, and ordered classes.</span>

<span class="sd">    Instance identity is defined by the specific list of attribute names</span>
<span class="sd">    declared in the abstract attribute &quot;_names&quot;. Subclasses must declare the</span>
<span class="sd">    attribute &quot;_names&quot; as an iterable containing the names of all the</span>
<span class="sd">    attributes relevant to equality/hash-value/ordering.</span>

<span class="sd">    Initial values should be set by using ::</span>
<span class="sd">        self._init(self, value1, value2, ..)</span>

<span class="sd">    .. note::</span>

<span class="sd">        It&#39;s the responsibility of the subclass to ensure that the values of</span>
<span class="sd">        its attributes are themselves hashable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override this attribute to declare the names of all the attributes</span>
<span class="sd">        relevant to the hash/comparison semantics.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_init_from_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_tuple</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">attributes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_as_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span>

    <span class="c1"># Prevent attribute updates</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;Instances of </span><span class="si">%s</span><span class="s2"> are immutable&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;Instances of </span><span class="si">%s</span><span class="s2"> are immutable&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="p">)</span>

    <span class="c1"># Provide hash semantics</span>

    <span class="k">def</span> <span class="nf">_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_identity</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_identity</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Since we&#39;ve defined __eq__ we should also define __ne__.</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="c1"># Provide default ordering semantics</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_OrderedHashable</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_identity</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>


<span class="k">def</span> <span class="nf">_array_slice_ifempty</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detect cases where an array slice will contain no data, as it contains a</span>
<span class="sd">    zero-length dimension, and produce an equivalent result for those cases.</span>

<span class="sd">    The function indicates &#39;empty&#39; slicing cases, by returning an array equal</span>
<span class="sd">    to the slice result in those cases.</span>

<span class="sd">    Args:</span>

<span class="sd">    * keys (indexing key, or tuple of keys):</span>
<span class="sd">        The argument from an array __getitem__ call.</span>
<span class="sd">        Only tuples of integers and slices are supported, in particular no</span>
<span class="sd">        newaxis, ellipsis or array keys.</span>
<span class="sd">        These are the types of array access usage we expect from Dask.</span>
<span class="sd">    * shape (tuple of int):</span>
<span class="sd">        The shape of the array being indexed.</span>
<span class="sd">    * dtype (numpy.dtype):</span>
<span class="sd">        The dtype of the array being indexed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        result (np.ndarray or None):</span>
<span class="sd">            If &#39;keys&#39; contains a slice(0, 0), this is an ndarray of the correct</span>
<span class="sd">            resulting shape and provided dtype.</span>
<span class="sd">            Otherwise it is None.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This is used to prevent DataProxy arraylike objects from fetching their</span>
<span class="sd">        file data when wrapped as Dask arrays.</span>
<span class="sd">        This is because, for Dask &gt;= 2.0, the &quot;dask.array.from_array&quot; call</span>
<span class="sd">        performs a fetch like [0:0, 0:0, ...], to &#39;snapshot&#39; array metadata.</span>
<span class="sd">        This function enables us to avoid triggering a file data fetch in those</span>
<span class="sd">        cases :  This is consistent because the result will not contain any</span>
<span class="sd">        actual data content.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert a single key into a 1-tuple, so we always have a tuple of keys.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">keys_tuple</span> <span class="o">=</span> <span class="n">keys</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keys_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">keys</span><span class="p">,)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_tuple</span><span class="p">):</span>
        <span class="c1"># An &#39;empty&#39; slice is present :  Return a &#39;fake&#39; array instead.</span>
        <span class="n">target_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i_dim</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys_tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># Reduce dims with empty slicing to length 0.</span>
                <span class="n">target_shape</span><span class="p">[</span><span class="n">i_dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Create a prototype result : no memory usage, as some dims are 0.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">target_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Index with original keys to produce the desired result shape.</span>
        <span class="c1"># Note : also ok in 0-length dims, as the slice is always &#39;0:0&#39;.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="create_temp_filename"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.create_temp_filename">[docs]</a><span class="k">def</span> <span class="nf">create_temp_filename</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a temporary file name.</span>

<span class="sd">    Args:</span>

<span class="sd">        * suffix  -  Optional filename extension.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">temp_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">temp_file</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="clip_string"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.clip_string">[docs]</a><span class="k">def</span> <span class="nf">clip_string</span><span class="p">(</span><span class="n">the_str</span><span class="p">,</span> <span class="n">clip_length</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">rider</span><span class="o">=</span><span class="s2">&quot;...&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a clipped version of the string based on the specified clip</span>
<span class="sd">    length and whether or not any graceful clip points can be found.</span>

<span class="sd">    If the string to be clipped is shorter than the specified clip</span>
<span class="sd">    length, the original string is returned.</span>

<span class="sd">    If the string is longer than the clip length, a graceful point (a</span>
<span class="sd">    space character) after the clip length is searched for. If a</span>
<span class="sd">    graceful point is found the string is clipped at this point and the</span>
<span class="sd">    rider is added. If no graceful point can be found, then the string</span>
<span class="sd">    is clipped exactly where the user requested and the rider is added.</span>

<span class="sd">    Args:</span>

<span class="sd">    * the_str</span>
<span class="sd">        The string to be clipped</span>
<span class="sd">    * clip_length</span>
<span class="sd">        The length in characters that the input string should be clipped</span>
<span class="sd">        to. Defaults to a preconfigured value if not specified.</span>
<span class="sd">    * rider</span>
<span class="sd">        A series of characters appended at the end of the returned</span>
<span class="sd">        string to show it has been clipped. Defaults to a preconfigured</span>
<span class="sd">        value if not specified.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The string clipped to the required length with a rider appended.</span>
<span class="sd">        If the clip length was greater than the orignal string, the</span>
<span class="sd">        original string is returned unaltered.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">clip_length</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">clip_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">the_str</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">the_str</span><span class="p">[</span><span class="n">clip_length</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">the_str</span><span class="p">[:</span><span class="n">clip_length</span><span class="p">]</span> <span class="o">+</span> <span class="n">rider</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_part</span> <span class="o">=</span> <span class="n">the_str</span><span class="p">[:</span><span class="n">clip_length</span><span class="p">]</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">the_str</span><span class="p">[</span><span class="n">clip_length</span><span class="p">:]</span>

            <span class="c1"># Try to find a graceful point at which to trim i.e. a space</span>
            <span class="c1"># If no graceful point can be found, then just trim where the user</span>
            <span class="c1"># specified by adding an empty slice of the remainder ( [:0] )</span>
            <span class="n">termination_point</span> <span class="o">=</span> <span class="n">remainder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">termination_point</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">termination_point</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">return</span> <span class="n">first_part</span> <span class="o">+</span> <span class="n">remainder</span><span class="p">[:</span><span class="n">termination_point</span><span class="p">]</span> <span class="o">+</span> <span class="n">rider</span></div>


<div class="viewcode-block" id="format_array"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.format_array">[docs]</a><span class="k">def</span> <span class="nf">format_array</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the given array as a string, using the python builtin str</span>
<span class="sd">    function on a piecewise basis.</span>

<span class="sd">    Useful for xml representation of arrays.</span>

<span class="sd">    For customisations, use the :mod:`numpy.core.arrayprint` directly.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">summary_insert</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">summary_threshold</span> <span class="o">=</span> <span class="mi">85</span>
    <span class="n">edge_items</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">ffunc</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">formatArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">arrayprint</span><span class="o">.</span><span class="n">_formatArray</span>
    <span class="n">max_line_len</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">legacy</span> <span class="o">=</span> <span class="s2">&quot;1.13&quot;</span>
    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">summary_threshold</span><span class="p">:</span>
        <span class="n">summary_insert</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
    <span class="n">options</span><span class="p">[</span><span class="s2">&quot;legacy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">legacy</span>
    <span class="k">with</span> <span class="n">_printopts_context</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">formatArray</span><span class="p">(</span>
            <span class="n">arr</span><span class="p">,</span>
            <span class="n">ffunc</span><span class="p">,</span>
            <span class="n">max_line_len</span><span class="p">,</span>
            <span class="n">next_line_prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="p">,</span>
            <span class="n">edge_items</span><span class="o">=</span><span class="n">edge_items</span><span class="p">,</span>
            <span class="n">summary_insert</span><span class="o">=</span><span class="n">summary_insert</span><span class="p">,</span>
            <span class="n">legacy</span><span class="o">=</span><span class="n">legacy</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">_printopts_context</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update the numpy printoptions for the life of this context manager.</span>

<span class="sd">    Note: this function can be removed with numpy&gt;=1.15 thanks to</span>
<span class="sd">          https://github.com/numpy/numpy/pull/10406</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_opts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">**</span><span class="n">original_opts</span><span class="p">)</span>


<div class="viewcode-block" id="new_axis"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.new_axis">[docs]</a><span class="k">def</span> <span class="nf">new_axis</span><span class="p">(</span><span class="n">src_cube</span><span class="p">,</span> <span class="n">scalar_coord</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new axis as the leading dimension of the cube, promoting a scalar</span>
<span class="sd">    coordinate if specified.</span>

<span class="sd">    Args:</span>

<span class="sd">    * src_cube (:class:`iris.cube.Cube`)</span>
<span class="sd">        Source cube on which to generate a new axis.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * scalar_coord (:class:`iris.coord.Coord` or &#39;string&#39;)</span>
<span class="sd">        Scalar coordinate to promote to a dimension coordinate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new :class:`iris.cube.Cube` instance with one extra leading dimension</span>
<span class="sd">        (length 1).</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; cube.shape</span>
<span class="sd">        (360, 360)</span>
<span class="sd">        &gt;&gt;&gt; ncube = iris.util.new_axis(cube, &#39;time&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ncube.shape</span>
<span class="sd">        (1, 360, 360)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">scalar_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scalar_coord</span> <span class="o">=</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">scalar_coord</span><span class="p">)</span>

    <span class="c1"># Indexing numpy arrays requires loading deferred data here returning a</span>
    <span class="c1"># copy of the data with a new leading dimension.</span>
    <span class="c1"># If the source cube is a Masked Constant, it is changed here to a Masked</span>
    <span class="c1"># Array to allow the mask to gain an extra dimension with the data.</span>
    <span class="k">if</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">():</span>
        <span class="n">new_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span><span class="n">src_cube</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">()[</span><span class="kc">None</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src_cube</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedConstant</span><span class="p">):</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">new_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="n">new_cube</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">metadata</span>

    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">aux_coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scalar_coord</span> <span class="ow">and</span> <span class="n">scalar_coord</span> <span class="o">==</span> <span class="n">coord</span><span class="p">:</span>
            <span class="n">dim_coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="o">.</span><span class="n">from_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="n">new_cube</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">src_cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">new_cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">dims</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">:</span>
        <span class="n">coord_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">src_cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">new_cube</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">coord_dims</span><span class="p">)</span>

    <span class="n">nonderived_coords</span> <span class="o">=</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">dim_coords</span> <span class="o">+</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">aux_coords</span>
    <span class="n">coord_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nb">id</span><span class="p">(</span><span class="n">old_co</span><span class="p">):</span> <span class="n">new_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">old_co</span><span class="p">)</span> <span class="k">for</span> <span class="n">old_co</span> <span class="ow">in</span> <span class="n">nonderived_coords</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>
        <span class="n">new_factory</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">updated</span><span class="p">(</span><span class="n">coord_mapping</span><span class="p">)</span>
        <span class="n">new_cube</span><span class="o">.</span><span class="n">add_aux_factory</span><span class="p">(</span><span class="n">new_factory</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_cube</span></div>


<div class="viewcode-block" id="as_compatible_shape"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.as_compatible_shape">[docs]</a><span class="k">def</span> <span class="nf">as_compatible_shape</span><span class="p">(</span><span class="n">src_cube</span><span class="p">,</span> <span class="n">target_cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a cube with added length one dimensions to match the dimensionality</span>
<span class="sd">    and dimension ordering of `target_cube`.</span>

<span class="sd">    This function can be used to add the dimensions that have been collapsed,</span>
<span class="sd">    aggregated or sliced out, promoting scalar coordinates to length one</span>
<span class="sd">    dimension coordinates where necessary. It operates by matching coordinate</span>
<span class="sd">    metadata to infer the dimensions that need modifying, so the provided</span>
<span class="sd">    cubes must have coordinates with the same metadata</span>
<span class="sd">    (see :class:`iris.coords.CoordDefn`).</span>

<span class="sd">    .. note:: This function will load and copy the data payload of `src_cube`.</span>

<span class="sd">    Args:</span>

<span class="sd">    * src_cube:</span>
<span class="sd">        An instance of :class:`iris.cube.Cube` with missing dimensions.</span>

<span class="sd">    * target_cube:</span>
<span class="sd">        An instance of :class:`iris.cube.Cube` with the desired dimensionality.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A instance of :class:`iris.cube.Cube` with the same dimensionality as</span>
<span class="sd">        `target_cube` but with the data and coordinates from `src_cube`</span>
<span class="sd">        suitably reshaped to fit.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim_mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">target_cube</span><span class="o">.</span><span class="n">aux_coords</span> <span class="o">+</span> <span class="n">target_cube</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">target_cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">collapsed_dims</span> <span class="o">=</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotFoundError</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">collapsed_dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">collapsed_dims</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">dim_from</span><span class="p">,</span> <span class="n">dim_to</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">collapsed_dims</span><span class="p">):</span>
                    <span class="n">dim_mapping</span><span class="p">[</span><span class="n">dim_from</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim_to</span>
        <span class="k">elif</span> <span class="n">dims</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dim_from</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                <span class="n">dim_mapping</span><span class="p">[</span><span class="n">dim_from</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_mapping</span><span class="p">)</span> <span class="o">!=</span> <span class="n">target_cube</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Insufficient or conflicting coordinate &quot;</span>
            <span class="s2">&quot;metadata. Cannot infer dimension mapping &quot;</span>
            <span class="s2">&quot;to restore cube dimensions.&quot;</span>
        <span class="p">)</span>

    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">target_cube</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">for</span> <span class="n">dim_from</span><span class="p">,</span> <span class="n">dim_to</span> <span class="ow">in</span> <span class="n">dim_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">dim_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_shape</span><span class="p">[</span><span class="n">dim_from</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim_to</span><span class="p">]</span>

    <span class="n">new_data</span> <span class="o">=</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Transpose the data (if necessary) to prevent assignment of</span>
    <span class="c1"># new_shape doing anything except adding length one dims.</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dim_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">))]</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">new_order</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">new_cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">))</span>
    <span class="n">new_cube</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">src_cube</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>

    <span class="c1"># Record a mapping from old coordinate IDs to new coordinates,</span>
    <span class="c1"># for subsequent use in creating updated aux_factories.</span>
    <span class="n">coord_mapping</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">reverse_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dim_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">add_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Closure used to add a suitably reshaped coord to new_cube.&quot;&quot;&quot;</span>
        <span class="n">all_dims</span> <span class="o">=</span> <span class="n">target_cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="n">src_dims</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dim</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">]</span>
        <span class="n">mapped_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">reverse_mapping</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">src_dims</span><span class="p">]</span>
        <span class="n">length1_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">all_dims</span> <span class="k">if</span> <span class="n">new_cube</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">length1_dims</span> <span class="o">+</span> <span class="n">mapped_dims</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_cube</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">nbounds</span><span class="p">])</span>
        <span class="n">new_coord</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="c1"># If originally in dim_coords, add to dim_coords, otherwise add to</span>
        <span class="c1"># aux_coords.</span>
        <span class="k">if</span> <span class="n">target_cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_cube</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># Catch cases where the coord is an AuxCoord and therefore</span>
                <span class="c1"># cannot be added to dim_coords.</span>
                <span class="n">new_cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">new_coord</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="n">coord_mapping</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">coord</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_coord</span>

    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">aux_coords</span> <span class="o">+</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">:</span>
        <span class="n">add_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">src_cube</span><span class="o">.</span><span class="n">aux_factories</span><span class="p">:</span>
        <span class="n">new_cube</span><span class="o">.</span><span class="n">add_aux_factory</span><span class="p">(</span><span class="n">factory</span><span class="o">.</span><span class="n">updated</span><span class="p">(</span><span class="n">coord_mapping</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">new_cube</span></div>


<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes any dimension of length one. If it has an associated DimCoord or</span>
<span class="sd">    AuxCoord, this becomes a scalar coord.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube (:class:`iris.cube.Cube`)</span>
<span class="sd">        Source cube to remove length 1 dimension(s) from.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new :class:`iris.cube.Cube` instance without any dimensions of</span>
<span class="sd">        length 1.</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; cube.shape</span>
<span class="sd">        (1, 360, 360)</span>
<span class="sd">        &gt;&gt;&gt; ncube = iris.util.squeeze(cube)</span>
<span class="sd">        &gt;&gt;&gt; ncube.shape</span>
<span class="sd">        (360, 360)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span>
        <span class="mi">0</span> <span class="k">if</span> <span class="n">cube</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">squeezed</span> <span class="o">=</span> <span class="n">cube</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">squeezed</span></div>


<div class="viewcode-block" id="file_is_newer_than"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.file_is_newer_than">[docs]</a><span class="k">def</span> <span class="nf">file_is_newer_than</span><span class="p">(</span><span class="n">result_path</span><span class="p">,</span> <span class="n">source_paths</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether the &#39;result&#39; file has a later modification time than all of</span>
<span class="sd">    the &#39;source&#39; files.</span>

<span class="sd">    If a stored result depends entirely on known &#39;sources&#39;, it need only be</span>
<span class="sd">    re-built when one of them changes.  This function can be used to test that</span>
<span class="sd">    by comparing file timestamps.</span>

<span class="sd">    Args:</span>

<span class="sd">    * result_path (string):</span>
<span class="sd">        The filepath of a file containing some derived result data.</span>
<span class="sd">    * source_paths (string or iterable of strings):</span>
<span class="sd">        The path(s) to the original datafiles used to make the result.  May</span>
<span class="sd">        include wildcards and &#39;~&#39; expansions (like Iris load paths), but not</span>
<span class="sd">        URIs.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if all the sources are older than the result, else False.</span>

<span class="sd">        If any of the file paths describes no existing files, an exception will</span>
<span class="sd">        be raised.</span>

<span class="sd">    .. note::</span>
<span class="sd">        There are obvious caveats to using file timestamps for this, as correct</span>
<span class="sd">        usage depends on how the sources might change.  For example, a file</span>
<span class="sd">        could be replaced by one of the same name, but an older timestamp.</span>

<span class="sd">        If wildcards and &#39;~&#39; expansions are used, this introduces even more</span>
<span class="sd">        uncertainty, as then you cannot even be sure that the resulting list of</span>
<span class="sd">        file names is the same as the originals.  For example, some files may</span>
<span class="sd">        have been deleted or others added.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The result file may often be a :mod:`pickle` file.  In that case, it</span>
<span class="sd">        also depends on the relevant module sources, so extra caution is</span>
<span class="sd">        required.  Ideally, an additional check on iris.__version__ is advised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Accept a string as a single source path</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_paths</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">source_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">source_paths</span><span class="p">]</span>
    <span class="c1"># Fix our chosen timestamp function</span>
    <span class="n">file_date</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span>
    <span class="c1"># Get the &#39;result file&#39; time</span>
    <span class="n">result_timestamp</span> <span class="o">=</span> <span class="n">file_date</span><span class="p">(</span><span class="n">result_path</span><span class="p">)</span>
    <span class="c1"># Get all source filepaths, with normal Iris.io load helper function</span>
    <span class="n">source_file_paths</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">expand_filespecs</span><span class="p">(</span><span class="n">source_paths</span><span class="p">)</span>
    <span class="c1"># Compare each filetime, for each spec, with the &#39;result time&#39;</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">source_file_paths</span><span class="p">:</span>
        <span class="n">source_timestamp</span> <span class="o">=</span> <span class="n">file_date</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source_timestamp</span> <span class="o">&gt;=</span> <span class="n">result_timestamp</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="is_regular"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.is_regular">[docs]</a><span class="k">def</span> <span class="nf">is_regular</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine if the given coord is regular.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">regular_step</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotRegularError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="regular_step"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.regular_step">[docs]</a><span class="k">def</span> <span class="nf">regular_step</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the regular step from a coord or fail.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="s2">&quot;Expected 1D coord&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected a non-scalar coord&quot;</span><span class="p">)</span>

    <span class="n">avdiff</span><span class="p">,</span> <span class="n">regular</span> <span class="o">=</span> <span class="n">points_step</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">regular</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Coord </span><span class="si">%s</span><span class="s2"> is not regular&quot;</span> <span class="o">%</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateNotRegularError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avdiff</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="points_step"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.points_step">[docs]</a><span class="k">def</span> <span class="nf">points_step</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine whether a NumPy array has a regular step.&quot;&quot;&quot;</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">avdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span>
    <span class="c1"># TODO: This value for `rtol` is set for test_analysis to pass...</span>
    <span class="n">regular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="n">avdiff</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avdiff</span><span class="p">,</span> <span class="n">regular</span></div>


<div class="viewcode-block" id="unify_time_units"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.unify_time_units">[docs]</a><span class="k">def</span> <span class="nf">unify_time_units</span><span class="p">(</span><span class="n">cubes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs an in-place conversion of the time units of all time coords in the</span>
<span class="sd">    cubes in a given iterable. One common epoch is defined for each calendar</span>
<span class="sd">    found in the cubes to prevent units being defined with inconsistencies</span>
<span class="sd">    between epoch and calendar.</span>

<span class="sd">    Each epoch is defined from the first suitable time coordinate found in the</span>
<span class="sd">    input cubes.</span>

<span class="sd">    Arg:</span>

<span class="sd">    * cubes:</span>
<span class="sd">        An iterable containing :class:`iris.cube.Cube` instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">epochs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">time_coord</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">time_coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">():</span>
                <span class="n">epoch</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                    <span class="n">time_coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">calendar</span><span class="p">,</span> <span class="n">time_coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">origin</span>
                <span class="p">)</span>
                <span class="n">new_unit</span> <span class="o">=</span> <span class="n">cf_units</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">time_coord</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">calendar</span><span class="p">)</span>
                <span class="n">time_coord</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">new_unit</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_is_circular</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">modulus</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether the provided points or bounds are circular in nature</span>
<span class="sd">    relative to the modulus value.</span>

<span class="sd">    If the bounds are provided then these are checked for circularity rather</span>
<span class="sd">    than the points.</span>

<span class="sd">    Args:</span>

<span class="sd">    * points:</span>
<span class="sd">        :class:`numpy.ndarray` of point values.</span>

<span class="sd">    * modulus:</span>
<span class="sd">        Circularity modulus value.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * bounds:</span>
<span class="sd">        :class:`numpy.ndarray` of bound values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Boolean.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circular</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Set circular to True if the bounds ends are equivalent.</span>
        <span class="n">first_bound</span> <span class="o">=</span> <span class="n">last_bound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">first_bound</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">modulus</span>
            <span class="n">last_bound</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">modulus</span>
        <span class="k">elif</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">first_bound</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">modulus</span>
            <span class="n">last_bound</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">modulus</span>

        <span class="k">if</span> <span class="n">first_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">last_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">circular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">first_bound</span><span class="p">,</span> <span class="n">last_bound</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># set circular if points are regular and last+1 ~= first</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">points</span><span class="p">)))</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span>
            <span class="n">abs_tol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="mf">1.0e-4</span><span class="p">)</span>
            <span class="n">diff_approx_equal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diffs</span> <span class="o">-</span> <span class="n">diff</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">abs_tol</span>
            <span class="k">if</span> <span class="n">diff_approx_equal</span><span class="p">:</span>
                <span class="n">circular_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">)</span> <span class="o">%</span> <span class="n">modulus</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_approx_equal</span><span class="p">(</span>
                        <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">circular_value</span><span class="p">,</span> <span class="n">significant</span><span class="o">=</span><span class="mi">4</span>
                    <span class="p">)</span>
                    <span class="n">circular</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_approx_equal</span><span class="p">(</span>
                                <span class="n">modulus</span><span class="p">,</span> <span class="n">circular_value</span><span class="p">,</span> <span class="n">significant</span><span class="o">=</span><span class="mi">4</span>
                            <span class="p">)</span>
                            <span class="n">circular</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># XXX - Inherited behaviour from NetCDF PyKE rules.</span>
            <span class="c1"># We need to decide whether this is valid!</span>
            <span class="n">circular</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">modulus</span>
    <span class="k">return</span> <span class="n">circular</span>


<div class="viewcode-block" id="promote_aux_coord_to_dim_coord"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.promote_aux_coord_to_dim_coord">[docs]</a><span class="k">def</span> <span class="nf">promote_aux_coord_to_dim_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">name_or_coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Promotes an AuxCoord on the cube to a DimCoord. This AuxCoord must be</span>
<span class="sd">    associated with a single cube dimension. If the AuxCoord is associated</span>
<span class="sd">    with a dimension that already has a DimCoord, that DimCoord gets</span>
<span class="sd">    demoted to an AuxCoord.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube</span>
<span class="sd">        An instance of :class:`iris.cube.Cube`</span>

<span class="sd">    * name_or_coord:</span>
<span class="sd">        Either</span>

<span class="sd">        (a) An instance of :class:`iris.coords.AuxCoord`</span>

<span class="sd">        or</span>

<span class="sd">        (b) the :attr:`standard_name`, :attr:`long_name`, or</span>
<span class="sd">        :attr:`var_name` of an instance of an instance of</span>
<span class="sd">        :class:`iris.coords.AuxCoord`.</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; print cube</span>
<span class="sd">        air_temperature / (K)       (time: 12; latitude: 73; longitude: 96)</span>
<span class="sd">             Dimension coordinates:</span>
<span class="sd">                  time                    x      -              -</span>
<span class="sd">                  latitude                -      x              -</span>
<span class="sd">                  longitude               -      -              x</span>
<span class="sd">             Auxiliary coordinates:</span>
<span class="sd">                  year                    x      -              -</span>
<span class="sd">        &gt;&gt;&gt; promote_aux_coord_to_dim_coord(cube, &#39;year&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print cube</span>
<span class="sd">        air_temperature / (K)       (year: 12; latitude: 73; longitude: 96)</span>
<span class="sd">             Dimension coordinates:</span>
<span class="sd">                  year                    x      -              -</span>
<span class="sd">                  latitude                -      x              -</span>
<span class="sd">                  longitude               -      -              x</span>
<span class="sd">             Auxiliary coordinates:</span>
<span class="sd">                  time                    x      -              -</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">aux_coord</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">):</span>
        <span class="n">aux_coord</span> <span class="o">=</span> <span class="n">name_or_coord</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Don&#39;t know how to handle this type</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Don&#39;t know how to handle coordinate of type </span><span class="si">{}</span><span class="s2">. &quot;</span>
            <span class="s2">&quot;Ensure all coordinates are of type str or &quot;</span>
            <span class="s2">&quot;iris.coords.Coord.&quot;</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">aux_coord</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">:</span>
        <span class="c1"># nothing to do</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">aux_coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">aux_coords</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Attempting to promote an AuxCoord (</span><span class="si">{}</span><span class="s2">) &quot;</span>
            <span class="s2">&quot;which does not exist in the cube.&quot;</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aux_coord</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">coord_dim</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">aux_coord</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_dim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Attempting to promote an AuxCoord (</span><span class="si">{}</span><span class="s2">) &quot;</span>
            <span class="s2">&quot;which is associated with </span><span class="si">{}</span><span class="s2"> dimensions.&quot;</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aux_coord</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_dim</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">dim_coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="o">.</span><span class="n">from_coord</span><span class="p">(</span><span class="n">aux_coord</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">valerr</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Attempt to promote an AuxCoord (</span><span class="si">{}</span><span class="s2">) fails &quot;</span>
            <span class="s2">&quot;when attempting to create a DimCoord from the &quot;</span>
            <span class="s2">&quot;AuxCoord because: </span><span class="si">{}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aux_coord</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span><span class="n">valerr</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">old_dim_coord</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span>
        <span class="n">dim_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">contains_dimension</span><span class="o">=</span><span class="n">coord_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_dim_coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">demote_dim_coord_to_aux_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">old_dim_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># order matters here: don&#39;t want to remove</span>
    <span class="c1"># the aux_coord before have tried to make</span>
    <span class="c1"># dim_coord in case that fails</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="n">aux_coord</span><span class="p">)</span>

    <span class="n">cube</span><span class="o">.</span><span class="n">add_dim_coord</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">,</span> <span class="n">coord_dim</span><span class="p">)</span></div>


<div class="viewcode-block" id="demote_dim_coord_to_aux_coord"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.demote_dim_coord_to_aux_coord">[docs]</a><span class="k">def</span> <span class="nf">demote_dim_coord_to_aux_coord</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">name_or_coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Demotes a dimension coordinate  on the cube to an auxiliary coordinate.</span>

<span class="sd">    The DimCoord is demoted to an auxiliary coordinate on the cube.</span>
<span class="sd">    The dimension of the cube that was associated with the DimCoord becomes</span>
<span class="sd">    anonymous.  The class of the coordinate is left as DimCoord, it is not</span>
<span class="sd">    recast as an AuxCoord instance.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube</span>
<span class="sd">        An instance of :class:`iris.cube.Cube`</span>

<span class="sd">    * name_or_coord:</span>
<span class="sd">        Either</span>

<span class="sd">        (a) An instance of :class:`iris.coords.DimCoord`</span>

<span class="sd">        or</span>

<span class="sd">        (b) the :attr:`standard_name`, :attr:`long_name`, or</span>
<span class="sd">        :attr:`var_name` of an instance of an instance of</span>
<span class="sd">        :class:`iris.coords.DimCoord`.</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; print cube</span>
<span class="sd">        air_temperature / (K)       (time: 12; latitude: 73; longitude: 96)</span>
<span class="sd">             Dimension coordinates:</span>
<span class="sd">                  time                    x      -              -</span>
<span class="sd">                  latitude                -      x              -</span>
<span class="sd">                  longitude               -      -              x</span>
<span class="sd">             Auxiliary coordinates:</span>
<span class="sd">                  year                    x      -              -</span>
<span class="sd">        &gt;&gt;&gt; demote_dim_coord_to_aux_coord(cube, &#39;time&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print cube</span>
<span class="sd">        air_temperature / (K)        (-- : 12; latitude: 73; longitude: 96)</span>
<span class="sd">             Dimension coordinates:</span>
<span class="sd">                  latitude                -      x              -</span>
<span class="sd">                  longitude               -      -              x</span>
<span class="sd">             Auxiliary coordinates:</span>
<span class="sd">                  time                    x      -              -</span>
<span class="sd">                  year                    x      -              -</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">dim_coord</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">Coord</span><span class="p">):</span>
        <span class="n">dim_coord</span> <span class="o">=</span> <span class="n">name_or_coord</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Don&#39;t know how to handle this type</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Don&#39;t know how to handle coordinate of type </span><span class="si">{}</span><span class="s2">. &quot;</span>
            <span class="s2">&quot;Ensure all coordinates are of type str or &quot;</span>
            <span class="s2">&quot;iris.coords.Coord.&quot;</span>
        <span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name_or_coord</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dim_coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">dim_coords</span><span class="p">:</span>
        <span class="c1"># nothing to do</span>
        <span class="k">return</span>

    <span class="n">coord_dim</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">)</span>

    <span class="n">cube</span><span class="o">.</span><span class="n">remove_coord</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">)</span>

    <span class="n">cube</span><span class="o">.</span><span class="n">add_aux_coord</span><span class="p">(</span><span class="n">dim_coord</span><span class="p">,</span> <span class="n">coord_dim</span><span class="p">)</span></div>


<span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    @numpy v1.13, the dtype of each output nD coordinate is the same as its</span>
<span class="sd">    associated input 1D coordinate. This is not the case prior to numpy v1.13,</span>
<span class="sd">    where the output dtype is cast up to its highest resolution, regardlessly.</span>

<span class="sd">    This convenience function ensures consistent meshgrid behaviour across</span>
<span class="sd">    numpy versions.</span>

<span class="sd">    Reference: https://github.com/numpy/numpy/pull/5302</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mxi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">mxii</span><span class="p">,</span> <span class="n">xii</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mxi</span><span class="p">,</span> <span class="n">xi</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">mxii</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">xii</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="n">mxi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mxii</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">xii</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mxi</span>


<div class="viewcode-block" id="find_discontiguities"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.find_discontiguities">[docs]</a><span class="k">def</span> <span class="nf">find_discontiguities</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Searches coord for discontiguities in the bounds array, returned as a</span>
<span class="sd">    boolean array (True where discontiguities are present).</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube (`iris.cube.Cube`):</span>
<span class="sd">        The cube to be checked for discontinuities in its &#39;x&#39; and &#39;y&#39;</span>
<span class="sd">        coordinates.</span>

<span class="sd">    Kwargs:</span>

<span class="sd">    * rel_tol (float):</span>
<span class="sd">        The relative equality tolerance to apply in coordinate bounds</span>
<span class="sd">        checking.</span>

<span class="sd">    * abs_tol (float):</span>
<span class="sd">        The absolute value tolerance to apply in coordinate bounds</span>
<span class="sd">        checking.</span>

<span class="sd">    Returns:</span>

<span class="sd">    * result (`numpy.ndarray` of bool) :</span>
<span class="sd">        true/false map of which cells in the cube XY grid have</span>
<span class="sd">        discontiguities in the coordinate points array.</span>

<span class="sd">        This can be used as the input array for</span>
<span class="sd">        :func:`iris.util.mask_cube`.</span>

<span class="sd">    Examples::</span>

<span class="sd">        # Find any unknown discontiguities in your cube&#39;s x and y arrays:</span>
<span class="sd">        discontiguities = iris.util.find_discontiguities(cube)</span>

<span class="sd">        # Pass the resultant boolean array to `iris.util.mask_cube`</span>
<span class="sd">        # with a cube slice; this will use the boolean array to mask</span>
<span class="sd">        # any discontiguous data points before plotting:</span>
<span class="sd">        masked_cube_slice = iris.util.mask_cube(cube[0], discontiguities)</span>

<span class="sd">        # Plot the masked cube slice:</span>
<span class="sd">        iplt.pcolormesh(masked_cube_slice)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lats_and_lons</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;grid_latitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;grid_longitude&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">spatial_coords</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">coord</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">aux_coords</span> <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="ow">in</span> <span class="n">lats_and_lons</span>
    <span class="p">]</span>
    <span class="n">dim_err_msg</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Discontiguity searches are currently only supported for &quot;</span>
        <span class="s2">&quot;2-dimensional coordinates.&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">dim_err_msg</span><span class="p">)</span>

    <span class="c1"># Check which dimensions are spanned by each coordinate.</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">spatial_coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">dim_err_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">span</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">span</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The coordinate </span><span class="si">{!r}</span><span class="s2"> doesn&#39;t span a data dimension.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">()))</span>

    <span class="c1"># Check that the 2d coordinate arrays are the same shape as each other</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">spatial_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">spatial_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Set up unmasked boolean array the same size as the coord points array:</span>
    <span class="n">bad_points_boolean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spatial_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">spatial_coords</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">diffs_x</span><span class="p">,</span> <span class="n">diffs_y</span><span class="p">)</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">_discontiguity_in_bounds</span><span class="p">(</span>
            <span class="n">rtol</span><span class="o">=</span><span class="n">rel_tol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">abs_tol</span>
        <span class="p">)</span>

        <span class="n">bad_points_boolean</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">bad_points_boolean</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">diffs_x</span>
        <span class="p">)</span>
        <span class="c1"># apply mask for y-direction discontiguities:</span>
        <span class="n">bad_points_boolean</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">bad_points_boolean</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">diffs_y</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">bad_points_boolean</span></div>


<div class="viewcode-block" id="mask_cube"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.mask_cube">[docs]</a><span class="k">def</span> <span class="nf">mask_cube</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">points_to_mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Masks any cells in the data array which correspond to cells marked `True`</span>
<span class="sd">    in the `points_to_mask` array.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cube (`iris.cube.Cube`):</span>
<span class="sd">        A 2-dimensional instance of :class:`iris.cube.Cube`.</span>

<span class="sd">    * points_to_mask (`numpy.ndarray` of bool):</span>
<span class="sd">        A 2d boolean array of Truth values representing points to mask in the</span>
<span class="sd">        x and y arrays of the cube.</span>

<span class="sd">    Returns:</span>

<span class="sd">    * result (`iris.cube.Cube`):</span>
<span class="sd">        A cube whose data array is masked at points specified by input array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">cube</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">points_to_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
    <span class="k">return</span> <span class="n">cube</span></div>


<div class="viewcode-block" id="equalise_attributes"><a class="viewcode-back" href="../../generated/api/iris/util.html#iris.util.equalise_attributes">[docs]</a><span class="k">def</span> <span class="nf">equalise_attributes</span><span class="p">(</span><span class="n">cubes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Delete cube attributes that are not identical over all cubes in a group.</span>

<span class="sd">    This function simply deletes any attributes which are not the same for</span>
<span class="sd">    all the given cubes.  The cubes will then have identical attributes.  The</span>
<span class="sd">    given cubes are modified in-place.</span>

<span class="sd">    Args:</span>

<span class="sd">    * cubes (iterable of :class:`iris.cube.Cube`):</span>
<span class="sd">        A collection of cubes to compare and adjust.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Work out which attributes are identical across all the cubes.</span>
    <span class="n">common_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cubes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">cube_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">common_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">key</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">common_keys</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">key</span> <span class="ow">in</span> <span class="n">cube_keys</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">cubes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="c1"># Remove all the other attributes.</span>
    <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_keys</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_strip_metadata_from_dims</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove ancillary variables and cell measures that map to specific dimensions.</span>

<span class="sd">    Returns a cube copy with (possibly) some cell-measures and ancillary variables removed.</span>

<span class="sd">    To be used by operations that modify or remove dimensions.</span>
<span class="sd">    Note: does nothing to (aux)-coordinates.  Those would be handled explicitly by the calling operation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reduced_cube</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Remove any ancillary variables that span the dimension(s) being collapsed</span>
    <span class="k">for</span> <span class="n">ancil</span> <span class="ow">in</span> <span class="n">reduced_cube</span><span class="o">.</span><span class="n">ancillary_variables</span><span class="p">():</span>
        <span class="n">ancil_dims</span> <span class="o">=</span> <span class="n">reduced_cube</span><span class="o">.</span><span class="n">ancillary_variable_dims</span><span class="p">(</span><span class="n">ancil</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ancil_dims</span><span class="p">):</span>
            <span class="n">reduced_cube</span><span class="o">.</span><span class="n">remove_ancillary_variable</span><span class="p">(</span><span class="n">ancil</span><span class="p">)</span>

    <span class="c1"># Remove any cell measures that span the dimension(s) being collapsed</span>
    <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">reduced_cube</span><span class="o">.</span><span class="n">cell_measures</span><span class="p">():</span>
        <span class="n">cm_dims</span> <span class="o">=</span> <span class="n">reduced_cube</span><span class="o">.</span><span class="n">cell_measure_dims</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cm_dims</span><span class="p">):</span>
            <span class="n">reduced_cube</span><span class="o">.</span><span class="n">remove_cell_measure</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reduced_cube</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        
        &copy; <a href="../../copyright.html">Copyright</a> Iris contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>