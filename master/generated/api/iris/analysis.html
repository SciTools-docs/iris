

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>iris.analysis &mdash; Iris 3.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/theme_override.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
    <link rel="next" title="iris.analysis.calculus" href="analysis/calculus.html" />
    <link rel="prev" title="Iris API" href="../iris.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/iris-logo-title.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installing.html">Installing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/iris_cubes.html">Iris data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/loading_iris_cubes.html">Loading Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/saving_iris_cubes.html">Saving Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/navigating_a_cube.html">Navigating a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/subsetting_a_cube.html">Subsetting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/real_and_lazy_data.html">Real and lazy data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/plotting_a_cube.html">Plotting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/interpolation_and_regridding.html">Cube interpolation and regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/merge_and_concat.html">Merge and concatenate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/cube_statistics.html">Cube statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/cube_maths.html">Cube maths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/citation.html">Citing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide/code_maintenance.html">Code maintenance</a></li>
</ul>
<p class="caption"><span class="caption-text">Further Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../further_topics/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../further_topics/metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../further_topics/lenient_metadata.html">Lenient metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../further_topics/lenient_maths.html">Lenient cube maths</a></li>
</ul>
<p class="caption"><span class="caption-text">Developers Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/contributing_getting_involved.html">Getting involved</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/gitwash/index.html">Working with Iris source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/contributing_documentation.html">Contributing to the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/contributing_codebase_index.html">Contributing to the code base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/contributing_changes.html">Contributing your changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers_guide/release.html">Releases</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../iris.html">Iris API</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">iris.analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="analysis/calculus.html">iris.analysis.calculus</a></li>
<li class="toctree-l3"><a class="reference internal" href="analysis/cartography.html">iris.analysis.cartography</a></li>
<li class="toctree-l3"><a class="reference internal" href="analysis/geometry.html">iris.analysis.geometry</a></li>
<li class="toctree-l3"><a class="reference internal" href="analysis/maths.html">iris.analysis.maths</a></li>
<li class="toctree-l3"><a class="reference internal" href="analysis/stats.html">iris.analysis.stats</a></li>
<li class="toctree-l3"><a class="reference internal" href="analysis/trajectory.html">iris.analysis.trajectory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="aux_factory.html">iris.aux_factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="common.html">iris.common</a></li>
<li class="toctree-l2"><a class="reference internal" href="config.html">iris.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="coord_categorisation.html">iris.coord_categorisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="coord_systems.html">iris.coord_systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="coords.html">iris.coords</a></li>
<li class="toctree-l2"><a class="reference internal" href="cube.html">iris.cube</a></li>
<li class="toctree-l2"><a class="reference internal" href="exceptions.html">iris.exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="experimental.html">iris.experimental</a></li>
<li class="toctree-l2"><a class="reference internal" href="fileformats.html">iris.fileformats</a></li>
<li class="toctree-l2"><a class="reference internal" href="io.html">iris.io</a></li>
<li class="toctree-l2"><a class="reference internal" href="iterate.html">iris.iterate</a></li>
<li class="toctree-l2"><a class="reference internal" href="palette.html">iris.palette</a></li>
<li class="toctree-l2"><a class="reference internal" href="pandas.html">iris.pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="plot.html">iris.plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickplot.html">iris.quickplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="std_names.html">iris.std_names</a></li>
<li class="toctree-l2"><a class="reference internal" href="symbols.html">iris.symbols</a></li>
<li class="toctree-l2"><a class="reference internal" href="time.html">iris.time</a></li>
<li class="toctree-l2"><a class="reference internal" href="util.html">iris.util</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../whatsnew/index.html">What’s new in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../techpapers/index.html">Iris technical papers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Iris copyright, licensing and contributors</a></li>
</ul>

            
          

    
    
    
        <p class="caption">
            <span class="caption-text">
            
                Support
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SciTools/iris"><i class="fa fa-github fa-fw"></i> Source code</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris"><i class="fa fa-comments fa-fw"></i> Users Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris-dev"><i class="fa fa-comments fa-fw"></i> Developers Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://stackoverflow.com/questions/tagged/python-iris"><i class="fa fa-question fa-fw"></i> StackOverflow for "How do I?"</a></li>
            
                <li class="toctree-l1"><a href="https://scitools.org.uk/iris/docs/v2.4.0/index.html"><i class="fa fa-book fa-fw"></i> Legacy documentation</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Iris</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../iris.html">Iris API</a> &raquo;</li>
        
      <li>iris.analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/generated/api/iris/analysis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="iris-analysis">
<span id="id1"></span><h1>iris.analysis<a class="headerlink" href="#iris-analysis" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><div class="toctree-wrapper compound">
</div>
</div></blockquote>
<span class="target" id="module-iris.analysis"></span><p>A package providing <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> analysis support.</p>
<p>This module defines a suite of <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instances,
which are used to specify the statistical measure to calculate over a
<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, using methods such as
<a class="reference internal" href="cube.html#iris.cube.Cube.aggregated_by" title="iris.cube.Cube.aggregated_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregated_by()</span></code></a> and <a class="reference internal" href="cube.html#iris.cube.Cube.collapsed" title="iris.cube.Cube.collapsed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collapsed()</span></code></a>.</p>
<p>The <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> is a convenience class that allows
specific statistical aggregation operators to be defined and instantiated.
These operators can then be used to collapse, or partially collapse, one or
more dimensions of a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as discussed in
<a class="reference internal" href="../../../userguide/cube_statistics.html#cube-statistics"><span class="std std-ref">Cube statistics</span></a>.</p>
<p>In particular, <a class="reference internal" href="../../../userguide/cube_statistics.html#cube-statistics-collapsing"><span class="std std-ref">Collapsing entire data dimensions</span></a> discusses how to use
<a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">MEAN</span></code></a> to average over one dimension of a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>,
and also how to perform weighted <a class="reference internal" href="../../../userguide/cube_statistics.html#cube-statistics-collapsing-average"><span class="std std-ref">Area averaging</span></a>.
While <a class="reference internal" href="../../../userguide/cube_statistics.html#cube-statistics-aggregated-by"><span class="std std-ref">Partially reducing data dimensions</span></a> shows how to aggregate similar
groups of data points along a single dimension, to result in fewer points
in that dimension.</p>
<p>The gallery contains several interesting worked examples of how an
<a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> may be used, including:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="../../gallery/meteorology/plot_COP_1d.html#sphx-glr-generated-gallery-meteorology-plot-cop-1d-py"><span class="std std-ref">Global average annual temperature plot</span></a></p></li>
<li><p><a class="reference internal" href="../../gallery/general/plot_SOI_filtering.html#sphx-glr-generated-gallery-general-plot-soi-filtering-py"><span class="std std-ref">Applying a filter to a time-series</span></a></p></li>
<li><p><a class="reference internal" href="../../gallery/meteorology/plot_hovmoller.html#sphx-glr-generated-gallery-meteorology-plot-hovmoller-py"><span class="std std-ref">Hovmoller diagram of monthly surface temperature</span></a></p></li>
<li><p><a class="reference internal" href="../../gallery/meteorology/plot_lagged_ensemble.html#sphx-glr-generated-gallery-meteorology-plot-lagged-ensemble-py"><span class="std std-ref">Seasonal ensemble model plots</span></a></p></li>
<li><p><a class="reference internal" href="../../gallery/general/plot_custom_aggregation.html#sphx-glr-generated-gallery-general-plot-custom-aggregation-py"><span class="std std-ref">Calculating a custom statistic</span></a></p></li>
</ul>
</div></blockquote>
<p>In this module:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#iris.analysis.COUNT" title="iris.analysis.COUNT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">COUNT</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.GMEAN" title="iris.analysis.GMEAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GMEAN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.HMEAN" title="iris.analysis.HMEAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HMEAN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.MAX" title="iris.analysis.MAX"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAX</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MEAN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.MEDIAN" title="iris.analysis.MEDIAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MEDIAN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.MIN" title="iris.analysis.MIN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MIN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.PEAK" title="iris.analysis.PEAK"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PEAK</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.PERCENTILE" title="iris.analysis.PERCENTILE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PERCENTILE</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.PROPORTION" title="iris.analysis.PROPORTION"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PROPORTION</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.RMS" title="iris.analysis.RMS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RMS</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.STD_DEV" title="iris.analysis.STD_DEV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">STD_DEV</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.SUM" title="iris.analysis.SUM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SUM</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.VARIANCE" title="iris.analysis.VARIANCE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIANCE</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.WPERCENTILE" title="iris.analysis.WPERCENTILE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WPERCENTILE</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Aggregator</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.WeightedAggregator" title="iris.analysis.WeightedAggregator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WeightedAggregator</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.clear_phenomenon_identity" title="iris.analysis.clear_phenomenon_identity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear_phenomenon_identity</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Linear</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AreaWeighted</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.Nearest" title="iris.analysis.Nearest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nearest</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.UnstructuredNearest" title="iris.analysis.UnstructuredNearest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UnstructuredNearest</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.PointInCell" title="iris.analysis.PointInCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PointInCell</span></code></a></p></li>
</ul>
</div></blockquote>
<dl class="py data">
<dt id="iris.analysis.COUNT">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">COUNT</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.COUNT" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that counts the number
of <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> data occurrences that satisfy a particular
criterion, as defined by a user supplied <em>function</em>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>function (callable):</dt><dd><p>A function which converts an array of data values into a corresponding
array of True/False values.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the number of <em>ensemble members</em> with precipitation exceeding 10
(in cube data units) could be calculated with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;ensemble_member&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">COUNT</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The <a class="reference internal" href="#iris.analysis.PROPORTION" title="iris.analysis.PROPORTION"><code class="xref py py-func docutils literal notranslate"><span class="pre">PROPORTION()</span></code></a> aggregator.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.GMEAN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">GMEAN</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.GMEAN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates the
geometric mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.gmean.html#scipy.stats.mstats.gmean" title="(in SciPy v1.5.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.gmean()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal geometric means over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">GMEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.HMEAN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">HMEAN</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.HMEAN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates the
harmonic mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.hmean.html#scipy.stats.mstats.hmean" title="(in SciPy v1.5.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.hmean()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal harmonic mean over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">HMEAN</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The harmonic mean is only valid if all data values are greater
than zero.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.MAX">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">MAX</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the maximum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ma.max.html#numpy.ma.max" title="(in NumPy v1.19)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.max()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal maximums over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.MEAN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">MEAN</code> &#x2192; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.MEAN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ma.average.html#numpy.ma.average" title="(in NumPy v1.19)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.average()</span></code></a>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol (float):</dt><dd><p>Tolerance of missing data. The value returned in each element of the
returned array will be masked if the fraction of masked data contributing
to that element exceeds mdtol. This fraction is calculated based on the
number of masked elements. mdtol=0 means no missing data is tolerated
while mdtol=1 means the resulting element will be masked if and only if
all the contributing elements are masked. Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>weights (float ndarray):</dt><dd><p>Weights matching the shape of the cube or the length of the window
for rolling window operations. Note that, latitude/longitude area
weights can be calculated using
<a class="reference internal" href="analysis/cartography.html#iris.analysis.cartography.area_weights" title="iris.analysis.cartography.area_weights"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.cartography.area_weights()</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>returned (boolean):</dt><dd><p>Set this to True to indicate that the collapsed weights are to be
returned along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal means over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>To compute a weighted area average:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">)</span>
<span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">collapsed_weights</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span>
                                                   <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">,</span>
                                                   <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                                   <span class="n">returned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lazy operation is supported, via <code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.ma.average()</span></code>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.MEDIAN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">MEDIAN</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.MEDIAN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the median over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ma.median.html#numpy.ma.median" title="(in NumPy v1.19)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.median()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal medians over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEDIAN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.MIN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">MIN</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the minimum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ma.min.html#numpy.ma.min" title="(in NumPy v1.19)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.min()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal minimums over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MIN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.PEAK">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">PEAK</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.PEAK" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the peak value derived from a spline interpolation over a
<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>.</p>
<p>The peak calculation takes into account nan values. Therefore, if the number
of non-nan values is zero the result itself will be an array of nan values.</p>
<p>The peak calculation also takes into account masked values. Therefore, if the
number of non-masked values is zero the result itself will be a masked array.</p>
<p>If multiple coordinates are specified, then the peak calculations are
performed individually, in sequence, for each coordinate specified.</p>
<p><strong>For example</strong>:</p>
<p>To compute the peak over the <em>time</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PEAK</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.PERCENTILE">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">PERCENTILE</code><a class="headerlink" href="#iris.analysis.PERCENTILE" title="Permalink to this definition">¶</a></dt>
<dd><p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">PercentileAggregator</span></code> instance that calculates the
percentile over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v1.5.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>percent (float or sequence of floats):</dt><dd><p>Percentile rank/s at which to extract value/s.</p>
</dd>
</dl>
</li>
</ul>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>alphap (float):</dt><dd><p>Plotting positions parameter, see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v1.5.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>betap (float):</dt><dd><p>Plotting positions parameter, see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v1.5.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.
Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the 10th and 90th percentile over <em>time</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PERCENTILE</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.PROPORTION">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">PROPORTION</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.PROPORTION" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates the
proportion, as a fraction, of <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> data occurrences
that satisfy a particular criterion, as defined by a user supplied
<em>function</em>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>function (callable):</dt><dd><p>A function which converts an array of data values into a corresponding
array of True/False values.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the probability of precipitation exceeding 10
(in cube data units) across <em>ensemble members</em> could be calculated with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;ensemble_member&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PROPORTION</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, the proportion of <em>time</em> precipitation exceeded 10
(in cube data units) could be calculated with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PROPORTION</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The <a class="reference internal" href="#iris.analysis.COUNT" title="iris.analysis.COUNT"><code class="xref py py-func docutils literal notranslate"><span class="pre">COUNT()</span></code></a> aggregator.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.RMS">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">RMS</code> &#x2192; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.RMS" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the root mean square over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
((x0**2 + x1**2 + … + xN-1**2) / N) ** 0.5.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>weights (float ndarray):</dt><dd><p>Weights matching the shape of the cube or the length of the window for
rolling window operations. The weights are applied to the squares when
taking the mean.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the zonal root mean square over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">RMS</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.STD_DEV">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">STD_DEV</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.STD_DEV" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the standard deviation over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as
computed by <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.std()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>ddof (integer):</dt><dd><p>Delta degrees of freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal standard deviations over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">STD_DEV</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the biased standard deviation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">STD_DEV</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lazy operation is supported, via <code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.nanstd()</span></code>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.SUM">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">SUM</code> &#x2192; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.SUM" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the sum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.sum()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>weights (float ndarray):</dt><dd><p>Weights matching the shape of the cube, or the length of
the window for rolling window operations. Weights should be
normalized before using them with this aggregator if scaling
is not intended.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>returned (boolean):</dt><dd><p>Set this to True to indicate the collapsed weights are to be returned
along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute an accumulation over the <em>time</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
</pre></div>
</div>
<p>To compute a weighted rolling sum e.g. to apply a digital filter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">,</span>
                             <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.VARIANCE">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">VARIANCE</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.VARIANCE" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the variance over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.var()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>ddof (integer):</dt><dd><p>Delta degrees of freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal variance over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">VARIANCE</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the biased variance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">VARIANCE</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lazy operation is supported, via <code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.nanvar()</span></code>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py data">
<dt id="iris.analysis.WPERCENTILE">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">WPERCENTILE</code><a class="headerlink" href="#iris.analysis.WPERCENTILE" title="Permalink to this definition">¶</a></dt>
<dd><p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedPercentileAggregator</span></code> instance that
calculates the weighted percentile over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>percent (float or sequence of floats):</dt><dd><p>Percentile rank/s at which to extract value/s.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>weights (float ndarray):</dt><dd><p>Weights matching the shape of the cube or the length of the window
for rolling window operations. Note that, latitude/longitude area
weights can be calculated using
<a class="reference internal" href="analysis/cartography.html#iris.analysis.cartography.area_weights" title="iris.analysis.cartography.area_weights"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.cartography.area_weights()</span></code></a>.</p>
</dd>
</dl>
</li>
</ul>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>returned (boolean):</dt><dd><p>Set this to True to indicate that the collapsed weights are to be
returned along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>kind (string or int):</dt><dd><p>Specifies the kind of interpolation used, see
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d()</span></code> Defaults to “linear”, which is
equivalent to alphap=0.5, betap=0.5 in <cite>iris.analysis.PERCENTILE</cite></p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>The <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> class provides common aggregation functionality.</p>
<blockquote>
<div><dl class="py class">
<dt id="iris.analysis.Aggregator">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">Aggregator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell_method</span></em>, <em class="sig-param"><span class="n">call_func</span></em>, <em class="sig-param"><span class="n">units_func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lazy_func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#Aggregator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.Aggregator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an aggregator for the given <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code>.</p>
<p>Args:</p>
<ul>
<li><dl class="simple">
<dt>cell_method (string):</dt><dd><p>Cell method definition formatter.  Used in the fashion
“cell_method.format(**kwargs)”, to produce a cell-method string
which can include keyword values.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>call_func (callable):</dt><dd><div class="line-block">
<div class="line"><em>Call signature</em>: (data, axis=None, **kwargs)</div>
</div>
<p>Data aggregation function.
Returns an aggregation result, collapsing the ‘axis’ dimension of
the ‘data’ argument.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul>
<li><dl>
<dt>units_func (callable):</dt><dd><div class="line-block">
<div class="line"><em>Call signature</em>: (units)</div>
</div>
<p>If provided, called to convert a cube’s units.
Returns an <code class="xref py py-class docutils literal notranslate"><span class="pre">cf_units.Unit</span></code>, or a
value that can be made into one.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>lazy_func (callable or None):</dt><dd><p>An alternative to <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code> implementing a lazy
aggregation. Note that, it need not support all features of the
main operation, but should raise an error in unhandled cases.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Additional kwargs::</dt><dd><p>Passed through to <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code> and <code class="xref py py-data docutils literal notranslate"><span class="pre">lazy_func</span></code>.</p>
</dd>
</dl>
<p>Aggregators are used by cube aggregation methods such as
<a class="reference internal" href="cube.html#iris.cube.Cube.collapsed" title="iris.cube.Cube.collapsed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collapsed()</span></code></a> and
<a class="reference internal" href="cube.html#iris.cube.Cube.aggregated_by" title="iris.cube.Cube.aggregated_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregated_by()</span></code></a>.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>A variety of ready-made aggregators are provided in this module, such
as <a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-data docutils literal notranslate"><span class="pre">MEAN</span></code></a> and <a class="reference internal" href="#iris.analysis.MAX" title="iris.analysis.MAX"><code class="xref py py-data docutils literal notranslate"><span class="pre">MAX</span></code></a>.  Custom
aggregators can also be created for special purposes, see
<a class="reference internal" href="../../gallery/general/plot_custom_aggregation.html#sphx-glr-generated-gallery-general-plot-custom-aggregation-py"><span class="std std-ref">Calculating a custom statistic</span></a>
for a worked example.</p>
<dl class="py method">
<dt id="iris.analysis.Aggregator.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the aggregation function given the data.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the “percent” keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>data (array):</dt><dd><p>Data array.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>axis (int):</dt><dd><p>Axis to aggregate over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol (float):</dt><dd><p>Tolerance of missing data. The value returned will be masked if
the fraction of data to missing data is less than or equal to
mdtol.  mdtol=0 means no missing data is tolerated while mdtol=1
will return the resulting value from the aggregation function.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>All keyword arguments apart from those specified above, are
passed through to the data aggregation function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The aggregated data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.Aggregator.aggregate_shape">
<code class="sig-name descname">aggregate_shape</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.aggregate_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the new dimension/s created by the aggregator.</p>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A tuple of the aggregate shape.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.Aggregator.lazy_aggregate">
<code class="sig-name descname">lazy_aggregate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.lazy_aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform aggregation over the data with a lazy operation, analogous to
the ‘aggregate’ result.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the “percent” keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>data (array):</dt><dd><p>A lazy array (<code class="xref py py-class docutils literal notranslate"><span class="pre">dask.array.Array</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>axis (int or list of int):</dt><dd><p>The dimensions to aggregate over – note that this is defined
differently to the ‘aggregate’ method ‘axis’ argument, which only
accepts a single dimension index.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>All keyword arguments are passed through to the data aggregation
function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A lazy array representing the aggregation operation
(<code class="xref py py-class docutils literal notranslate"><span class="pre">dask.array.Array</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.Aggregator.name">
<code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the aggregator.</p>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.Aggregator.post_process">
<code class="sig-name descname">post_process</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">collapsed_cube</span></em>, <em class="sig-param"><span class="n">data_result</span></em>, <em class="sig-param"><span class="n">coords</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.post_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>collapsed_cube:</dt><dd><p>A <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>data_result:</dt><dd><p>Result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords:</dt><dd><p>The one or more coordinates that were aggregated over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords (for example, the “ddof”
keyword from a standard deviation aggregator).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The collapsed cube with its aggregated data payload.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.Aggregator.update_metadata">
<code class="sig-name descname">update_metadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cube</span></em>, <em class="sig-param"><span class="n">coords</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#Aggregator.update_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.Aggregator.update_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Update cube cell method metadata w.r.t the aggregation function.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cube (<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a>):</dt><dd><p>Source cube that requires metadata update.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords (<a class="reference internal" href="coords.html#iris.coords.Coord" title="iris.coords.Coord"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.coords.Coord</span></code></a>):</dt><dd><p>The one or more coordinates that were aggregated.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords (for example, the “ddof”
keyword for a standard deviation aggregator).</p></li>
</ul>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>Convenience class that supports common weighted aggregation functionality.</p>
<blockquote>
<div><dl class="py class">
<dt id="iris.analysis.WeightedAggregator">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">WeightedAggregator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell_method</span></em>, <em class="sig-param"><span class="n">call_func</span></em>, <em class="sig-param"><span class="n">units_func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lazy_func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#WeightedAggregator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.WeightedAggregator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a weighted aggregator for the given <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cell_method (string):</dt><dd><p>Cell method string that supports string format substitution.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>call_func (callable):</dt><dd><p>Data aggregation function. Call signature <cite>(data, axis, **kwargs)</cite>.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>units_func (callable):</dt><dd><p>Units conversion function.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>lazy_func (callable or None):</dt><dd><p>An alternative to <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code> implementing a lazy
aggregation. Note that, it need not support all features of the
main operation, but should raise an error in unhandled cases.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Additional kwargs:</dt><dd><p>Passed through to <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code> and <code class="xref py py-data docutils literal notranslate"><span class="pre">lazy_func</span></code>.</p>
</dd>
</dl>
<dl class="py method">
<dt id="iris.analysis.WeightedAggregator.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the aggregation function given the data.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the “percent” keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>data (array):</dt><dd><p>Data array.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>axis (int):</dt><dd><p>Axis to aggregate over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol (float):</dt><dd><p>Tolerance of missing data. The value returned will be masked if
the fraction of data to missing data is less than or equal to
mdtol.  mdtol=0 means no missing data is tolerated while mdtol=1
will return the resulting value from the aggregation function.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>All keyword arguments apart from those specified above, are
passed through to the data aggregation function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The aggregated data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.WeightedAggregator.aggregate_shape">
<code class="sig-name descname">aggregate_shape</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.aggregate_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the new dimension/s created by the aggregator.</p>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A tuple of the aggregate shape.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.WeightedAggregator.lazy_aggregate">
<code class="sig-name descname">lazy_aggregate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.lazy_aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform aggregation over the data with a lazy operation, analogous to
the ‘aggregate’ result.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the “percent” keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>data (array):</dt><dd><p>A lazy array (<code class="xref py py-class docutils literal notranslate"><span class="pre">dask.array.Array</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>axis (int or list of int):</dt><dd><p>The dimensions to aggregate over – note that this is defined
differently to the ‘aggregate’ method ‘axis’ argument, which only
accepts a single dimension index.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>All keyword arguments are passed through to the data aggregation
function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A lazy array representing the aggregation operation
(<code class="xref py py-class docutils literal notranslate"><span class="pre">dask.array.Array</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.WeightedAggregator.name">
<code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the aggregator.</p>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.WeightedAggregator.post_process">
<code class="sig-name descname">post_process</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">collapsed_cube</span></em>, <em class="sig-param"><span class="n">data_result</span></em>, <em class="sig-param"><span class="n">coords</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#WeightedAggregator.post_process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.WeightedAggregator.post_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Returns a tuple(cube, weights) if a tuple(data, weights) was returned
from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>collapsed_cube:</dt><dd><p>A <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>data_result:</dt><dd><p>Result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords:</dt><dd><p>The one or more coordinates that were aggregated over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords (for example, the “weights”
keywords from a mean aggregator).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The collapsed cube with it’s aggregated data payload. Or a tuple
pair of (cube, weights) if the keyword “returned” is specified
and True.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.WeightedAggregator.update_metadata">
<code class="sig-name descname">update_metadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cube</span></em>, <em class="sig-param"><span class="n">coords</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.update_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Update cube cell method metadata w.r.t the aggregation function.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cube (<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a>):</dt><dd><p>Source cube that requires metadata update.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords (<a class="reference internal" href="coords.html#iris.coords.Coord" title="iris.coords.Coord"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.coords.Coord</span></code></a>):</dt><dd><p>The one or more coordinates that were aggregated.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords (for example, the “ddof”
keyword for a standard deviation aggregator).</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.WeightedAggregator.uses_weighting">
<code class="sig-name descname">uses_weighting</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#WeightedAggregator.uses_weighting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.WeightedAggregator.uses_weighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether this aggregator uses weighting.</p>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>Arguments to filter of weighted keywords.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Boolean.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="py function">
<dt id="iris.analysis.clear_phenomenon_identity">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">clear_phenomenon_identity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cube</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#clear_phenomenon_identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.clear_phenomenon_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to clear the standard_name, attributes, and
cell_methods of a cube.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the linear interpolation and regridding scheme for
interpolating or regridding over one or more orthogonal coordinates,
typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> or
<a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="py class">
<dt id="iris.analysis.Linear">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">Linear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">extrapolation_mode</span><span class="o">=</span><span class="default_value">'linear'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#Linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear interpolation and regridding scheme suitable for interpolating
or regridding over one or more orthogonal coordinates.</p>
<p>Kwargs:</p>
<ul>
<li><dl>
<dt>extrapolation_mode:</dt><dd><p>Must be one of the following strings:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘extrapolate’ or ‘linear’ - The extrapolation points
will be calculated by extending the gradient of the
closest two points.</p></li>
<li><p>‘nan’ - The extrapolation points will be be set to NaN.</p></li>
<li><p>‘error’ - A ValueError exception will be raised, notifying an
attempt to extrapolate.</p></li>
<li><p>‘mask’ - The extrapolation points will always be masked, even
if the source data is not a MaskedArray.</p></li>
<li><p>‘nanmask’ - If the source data is a MaskedArray the
extrapolation points will be masked. Otherwise they will be
set to NaN.</p></li>
</ul>
</div></blockquote>
<p>The default mode of extrapolation is ‘linear’.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt id="iris.analysis.Linear.interpolator">
<code class="sig-name descname">interpolator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cube</span></em>, <em class="sig-param"><span class="n">coords</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#Linear.interpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.Linear.interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a linear interpolator to perform interpolation over the
given <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> specified by the dimensions of
the given coordinates.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> for
interpolating a cube. There are, however, some situations when
constructing your own interpolator is preferable. These are detailed
in the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-an-interpolator"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cube:</dt><dd><p>The source <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> to be interpolated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords:</dt><dd><p>The names or coordinate instances that are to be
interpolated over.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>callable(sample_points, collapse_scalar=True)</cite></p>
<p>where <cite>sample_points</cite> is a sequence containing an array of values
for each of the coordinates passed to this method, and
<cite>collapse_scalar</cite> determines whether to remove length one
dimensions in the result cube caused by scalar values in
<cite>sample_points</cite>.</p>
<p>The values for coordinates that correspond to date/times
may optionally be supplied as datetime.datetime or
cftime.datetime instances.</p>
<p>For example, for the callable returned by:
<cite>Linear().interpolator(cube, [‘latitude’, ‘longitude’])</cite>,
sample_points must have the form
<cite>[new_lat_values, new_lon_values]</cite>.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A callable with the interface</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.Linear.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src_grid</span></em>, <em class="sig-param"><span class="n">target_grid</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#Linear.regridder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.Linear.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a linear regridder to perform regridding from the source
grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Supports lazy regridding. Any
<a class="reference external" href="https://docs.dask.org/en/latest/array-chunks.html">chunks</a>
in horizontal dimensions will be combined before regridding.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>callable(cube)</cite></p>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A callable with the interface</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="iris.analysis.Linear.LINEAR_EXTRAPOLATION_MODES">
<code class="sig-name descname">LINEAR_EXTRAPOLATION_MODES</code><em class="property"> = ['extrapolate', 'error', 'nan', 'mask', 'nanmask', 'linear']</em><a class="headerlink" href="#iris.analysis.Linear.LINEAR_EXTRAPOLATION_MODES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes an area-weighted regridding scheme for regridding
between ‘ordinary’ horizontal grids with separated X and Y coordinates in a
common coordinate system.
Typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="py class">
<dt id="iris.analysis.AreaWeighted">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">AreaWeighted</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mdtol</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#AreaWeighted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.AreaWeighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Area-weighted regridding scheme suitable for regridding between
different orthogonal XY grids in the same coordinate system.</p>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol (float):</dt><dd><p>Tolerance of missing data. The value returned in each element of
the returned array will be masked if the fraction of missing data
exceeds mdtol. This fraction is calculated based on the area of
masked cells within each target cell. mdtol=0 means no masked
data is tolerated while mdtol=1 will mean the resulting element
will be masked if and only if all the overlapping elements of the
source grid are masked. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt id="iris.analysis.AreaWeighted.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src_grid_cube</span></em>, <em class="sig-param"><span class="n">target_grid_cube</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#AreaWeighted.regridder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.AreaWeighted.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an area-weighted regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Supports lazy regridding. Any
<a class="reference external" href="https://docs.dask.org/en/latest/array-chunks.html">chunks</a>
in horizontal dimensions will be combined before regridding.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid_cube:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid_cube:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>callable(cube)</cite></p>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid_cube</cite>
that is to be regridded to the grid of <cite>target_grid_cube</cite>.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A callable with the interface</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the nearest-neighbour interpolation and regridding
scheme for interpolating or regridding over one or more orthogonal
coordinates, typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.interpolate()</span></code></a>
or <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="py class">
<dt id="iris.analysis.Nearest">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">Nearest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">extrapolation_mode</span><span class="o">=</span><span class="default_value">'extrapolate'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#Nearest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.Nearest" title="Permalink to this definition">¶</a></dt>
<dd><p>Nearest-neighbour interpolation and regridding scheme suitable for
interpolating or regridding over one or more orthogonal coordinates.</p>
<p>Kwargs:</p>
<ul>
<li><dl>
<dt>extrapolation_mode:</dt><dd><p>Must be one of the following strings:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘extrapolate’ - The extrapolation points will take their
value from the nearest source point.</p></li>
<li><p>‘nan’ - The extrapolation points will be be set to NaN.</p></li>
<li><p>‘error’ - A ValueError exception will be raised, notifying an
attempt to extrapolate.</p></li>
<li><p>‘mask’ - The extrapolation points will always be masked, even
if the source data is not a MaskedArray.</p></li>
<li><p>‘nanmask’ - If the source data is a MaskedArray the
extrapolation points will be masked. Otherwise they will be
set to NaN.</p></li>
</ul>
</div></blockquote>
<p>The default mode of extrapolation is ‘extrapolate’.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt id="iris.analysis.Nearest.interpolator">
<code class="sig-name descname">interpolator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cube</span></em>, <em class="sig-param"><span class="n">coords</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#Nearest.interpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.Nearest.interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a nearest-neighbour interpolator to perform
interpolation over the given <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> specified
by the dimensions of the specified coordinates.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> for
interpolating a cube. There are, however, some situations when
constructing your own interpolator is preferable. These are detailed
in the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-an-interpolator"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cube:</dt><dd><p>The source <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> to be interpolated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords:</dt><dd><p>The names or coordinate instances that are to be
interpolated over.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>callable(sample_points, collapse_scalar=True)</cite></p>
<p>where <cite>sample_points</cite> is a sequence containing an array of values
for each of the coordinates passed to this method, and
<cite>collapse_scalar</cite> determines whether to remove length one
dimensions in the result cube caused by scalar values in
<cite>sample_points</cite>.</p>
<p>The values for coordinates that correspond to date/times
may optionally be supplied as datetime.datetime or
cftime.datetime instances.</p>
<p>For example, for the callable returned by:
<cite>Nearest().interpolator(cube, [‘latitude’, ‘longitude’])</cite>,
sample_points must have the form
<cite>[new_lat_values, new_lon_values]</cite>.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A callable with the interface</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="iris.analysis.Nearest.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src_grid</span></em>, <em class="sig-param"><span class="n">target_grid</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#Nearest.regridder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.Nearest.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a nearest-neighbour regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Supports lazy regridding. Any
<a class="reference external" href="https://docs.dask.org/en/latest/array-chunks.html">chunks</a>
in horizontal dimensions will be combined before regridding.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>callable(cube)</cite></p>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A callable with the interface</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This is a nearest-neighbour regridding scheme for regridding data whose
horizontal (X- and Y-axis) coordinates are mapped to the <em>same</em> dimensions,
rather than being orthogonal on independent dimensions.</p>
<p>For latitude-longitude coordinates, the nearest-neighbour distances are
computed on the sphere, otherwise flat Euclidean distances are used.</p>
<p>The source X and Y coordinates can have any shape.</p>
<p>The target grid must be of the “normal” kind, i.e. it has separate,
1-dimensional X and Y coordinates.</p>
<p>Source and target XY coordinates must have the same coordinate system,
which may also be None.
If any of the XY coordinates are latitudes or longitudes, then they <em>all</em>
must be.  Otherwise, the corresponding X and Y coordinates must have the
same units in the source and grid cubes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only supports regridding, not interpolation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This scheme performs essentially the same job as
<a class="reference internal" href="experimental/regrid.html#iris.experimental.regrid.ProjectedUnstructuredNearest" title="iris.experimental.regrid.ProjectedUnstructuredNearest"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.experimental.regrid.ProjectedUnstructuredNearest</span></code></a>.
That scheme is faster, but only works well on data in a limited
region of the globe, covered by a specified projection.
This approach is more rigorously correct and can be applied to global
datasets.</p>
</div>
<blockquote>
<div><dl class="py class">
<dt id="iris.analysis.UnstructuredNearest">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">UnstructuredNearest</code><a class="reference internal" href="../../../_modules/iris/analysis.html#UnstructuredNearest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.UnstructuredNearest" title="Permalink to this definition">¶</a></dt>
<dd><p>Nearest-neighbour interpolation and regridding scheme suitable for
interpolating or regridding from un-gridded data such as trajectories
or other data where the X and Y coordinates share the same dimensions.</p>
<dl class="py method">
<dt id="iris.analysis.UnstructuredNearest.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src_cube</span></em>, <em class="sig-param"><span class="n">target_grid</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#UnstructuredNearest.regridder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.UnstructuredNearest.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a nearest-neighbour regridder, of the
<a class="reference internal" href="analysis/trajectory.html#iris.analysis.trajectory.UnstructuredNearestNeigbourRegridder" title="iris.analysis.trajectory.UnstructuredNearestNeigbourRegridder"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnstructuredNearestNeigbourRegridder</span></code></a>
type, to perform regridding from the source grid to the target grid.</p>
<p>This can then be applied to any source data with the same structure as
the original ‘src_cube’.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Does not support lazy regridding.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_cube:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.
The X and Y coordinates can have any shape, but must be mapped over
the same cube dimensions.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.
The X and Y coordinates must be one-dimensional dimension
coordinates, mapped to different dimensions.
All other cube components are ignored.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>callable(cube)</cite></p>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_cube</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A callable with the interface</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the point-in-cell regridding scheme for use
typically with <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<p>The PointInCell regridder can regrid data from a source grid of any
dimensionality and in any coordinate system.
The location of each source point is specified by X and Y coordinates
mapped over the same cube dimensions, aka “grid dimensions” : the grid may
have any dimensionality.  The X and Y coordinates must also have the same,
defined coord_system.
The weights, if specified, must have the same shape as the X and Y
coordinates.
The output grid can be any ‘normal’ XY grid, specified by <em>separate</em> X
and Y coordinates :  That is, X and Y have two different cube dimensions.
The output X and Y coordinates must also have a common, specified
coord_system.</p>
<blockquote>
<div><dl class="py class">
<dt id="iris.analysis.PointInCell">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">PointInCell</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#PointInCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.PointInCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-in-cell regridding scheme suitable for regridding over one
or more orthogonal coordinates.</p>
<p>Optional Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>weights:</dt><dd><p>A <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> instance that defines the weights
for the grid cells of the source grid. Must have the same shape
as the data of the source grid.
If unspecified, equal weighting is assumed.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt id="iris.analysis.PointInCell.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src_grid</span></em>, <em class="sig-param"><span class="n">target_grid</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/iris/analysis.html#PointInCell.regridder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#iris.analysis.PointInCell.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a point-in-cell regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Does not support lazy regridding.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><cite>callable(cube)</cite></p>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A callable with the interface</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="analysis/calculus.html" class="btn btn-neutral float-right" title="iris.analysis.calculus" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../iris.html" class="btn btn-neutral float-left" title="Iris API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        
        &copy; <a href="../../../copyright.html">Copyright</a> Iris Contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>