

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>iris.coords &mdash; Iris 3.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/theme_override.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/iris-logo-title.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installing.html">Installing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/gallery/index.html">Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/iris_cubes.html">Iris data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/loading_iris_cubes.html">Loading Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/saving_iris_cubes.html">Saving Iris cubes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/navigating_a_cube.html">Navigating a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/subsetting_a_cube.html">Subsetting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/real_and_lazy_data.html">Real and lazy data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/plotting_a_cube.html">Plotting a cube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/interpolation_and_regridding.html">Cube interpolation and regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/merge_and_concat.html">Merge and concatenate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_statistics.html">Cube statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/cube_maths.html">Cube maths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/citation.html">Citing Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/code_maintenance.html">Code maintenance</a></li>
</ul>
<p class="caption"><span class="caption-text">Further Topics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/lenient_metadata.html">Lenient metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../further_topics/lenient_maths.html">Lenient cube maths</a></li>
</ul>
<p class="caption"><span class="caption-text">Developers Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/contributing_documentation.html">Contributing to the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/documenting/index.html">Documentation in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/gitwash/index.html">Working with Iris source code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/code_format.html">Code formatting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/pulls.html">Pull request check list</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/tests.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/deprecations.html">Deprecations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers_guide/release.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/iris.html">Iris API</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../whatsnew/index.html">Whatâ€™s new in Iris</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../techpapers/index.html">Iris technical papers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Iris copyright, licensing and contributors</a></li>
</ul>

            
          

    
    
    
        <p class="caption">
            <span class="caption-text">
            
                Support
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SciTools/iris"><i class="fa fa-github fa-fw"></i> Source code</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris"><i class="fa fa-comments fa-fw"></i> Users Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://groups.google.com/forum/#!forum/scitools-iris-dev"><i class="fa fa-comments fa-fw"></i> Developers Google Group</a></li>
            
                <li class="toctree-l1"><a href="https://stackoverflow.com/questions/tagged/python-iris"><i class="fa fa-question fa-fw"></i> StackOverflow for "How do I?"</a></li>
            
                <li class="toctree-l1"><a href="https://scitools.org.uk/iris/docs/v2.4.0/index.html"><i class="fa fa-book fa-fw"></i> Legacy documentation</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Iris</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../iris.html">iris</a> &raquo;</li>
        
      <li>iris.coords</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for iris.coords</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Iris contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Iris and is released under the LGPL license.</span>
<span class="c1"># See COPYING and COPYING.LESSER in the root of the repository for full</span>
<span class="c1"># licensing details.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Definitions of coordinates and other dimensional metadata.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">zip_longest</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">zlib</span>

<span class="kn">import</span> <span class="nn">cftime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="kn">from</span> <span class="nn">iris._data_manager</span> <span class="kn">import</span> <span class="n">DataManager</span>
<span class="kn">import</span> <span class="nn">iris._lazy_data</span> <span class="k">as</span> <span class="nn">_lazy</span>
<span class="kn">import</span> <span class="nn">iris.aux_factory</span>
<span class="kn">from</span> <span class="nn">iris.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AncillaryVariableMetadata</span><span class="p">,</span>
    <span class="n">BaseMetadata</span><span class="p">,</span>
    <span class="n">CFVariableMixin</span><span class="p">,</span>
    <span class="n">CellMeasureMetadata</span><span class="p">,</span>
    <span class="n">CoordMetadata</span><span class="p">,</span>
    <span class="n">DimCoordMetadata</span><span class="p">,</span>
    <span class="n">metadata_manager_factory</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">iris.exceptions</span>
<span class="kn">import</span> <span class="nn">iris.time</span>
<span class="kn">import</span> <span class="nn">iris.util</span>


<span class="k">class</span> <span class="nc">_DimensionalMetadata</span><span class="p">(</span><span class="n">CFVariableMixin</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Superclass for dimensional metadata.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_MODE_ADD</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">_MODE_SUB</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">_MODE_MUL</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">_MODE_DIV</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">_MODE_RDIV</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">_MODE_SYMBOL</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">_MODE_ADD</span><span class="p">:</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">_MODE_SUB</span><span class="p">:</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">_MODE_MUL</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">_MODE_DIV</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span>
        <span class="n">_MODE_RDIV</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a single dimensional metadata object.</span>

<span class="sd">        Args:</span>

<span class="sd">        * values:</span>
<span class="sd">            The values of the dimensional metadata.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * standard_name:</span>
<span class="sd">            CF standard name of the dimensional metadata.</span>
<span class="sd">        * long_name:</span>
<span class="sd">            Descriptive name of the dimensional metadata.</span>
<span class="sd">        * var_name:</span>
<span class="sd">            The netCDF variable name for the dimensional metadata.</span>
<span class="sd">        * units</span>
<span class="sd">            The :class:`~cf_units.Unit` of the dimensional metadata&#39;s values.</span>
<span class="sd">            Can be a string, which will be converted to a Unit object.</span>
<span class="sd">        * attributes</span>
<span class="sd">            A dictionary containing other cf and user-defined attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: this class includes bounds handling code for convenience, but</span>
        <span class="c1"># this can only run within instances which are also Coords, because</span>
        <span class="c1"># only they may actually have bounds.  This parent class has no</span>
        <span class="c1"># bounds-related getter/setter properties, and no bounds keywords in</span>
        <span class="c1"># its __init__ or __copy__ methods.  The only bounds-related behaviour</span>
        <span class="c1"># it provides is a &#39;has_bounds()&#39; method, which always returns False.</span>

        <span class="c1"># Configure the metadata manager.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_metadata_manager&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span> <span class="o">=</span> <span class="n">metadata_manager_factory</span><span class="p">(</span><span class="n">BaseMetadata</span><span class="p">)</span>

        <span class="c1">#: CF standard name of the quantity that the metadata represents.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standard_name</span> <span class="o">=</span> <span class="n">standard_name</span>

        <span class="c1">#: Descriptive name of the metadata.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span>

        <span class="c1">#: The netCDF variable name for the metadata.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span> <span class="o">=</span> <span class="n">var_name</span>

        <span class="c1">#: Unit of the quantity that the metadata represents.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>

        <span class="c1">#: Other attributes, including user specified attributes that</span>
        <span class="c1">#: have no meaning to Iris.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="c1"># Set up DataManager attributes and values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Only ever set on Coord-derived instances.</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new dimensional metadata whose values are obtained by</span>
<span class="sd">        conventional array indexing.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Indexing of a circular coordinate results in a non-circular</span>
<span class="sd">            coordinate if the overall shape of the coordinate changes after</span>
<span class="sd">            indexing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: this method includes bounds handling code, but it only runs</span>
        <span class="c1"># within Coord type instances, as only these allow bounds to be set.</span>

        <span class="c1"># Fetch the values.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>

        <span class="c1"># Index values with the keys.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_slice_data_with_keys</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

        <span class="c1"># Copy values after indexing to avoid making metadata that is a</span>
        <span class="c1"># view on another metadata. This will not realise lazy data.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># If the metadata is a coordinate and it has bounds, repeat the above</span>
        <span class="c1"># with the bounds.</span>
        <span class="n">copy_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_slice_data_with_keys</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
            <span class="c1"># Pass into the copy method : for Coords, it has a &#39;bounds&#39; key.</span>
            <span class="n">copy_args</span><span class="p">[</span><span class="s2">&quot;bounds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># The new metadata is a copy of the old one with replaced content.</span>
        <span class="n">new_metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">copy_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_metadata</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this dimensional metadata object.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * values</span>
<span class="sd">            An array of values for the new dimensional metadata object.</span>
<span class="sd">            This may be a different shape to the original values array being</span>
<span class="sd">            copied.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: this is overridden in Coord subclasses, to add bounds handling</span>
        <span class="c1"># and a &#39;bounds&#39; keyword.</span>
        <span class="n">new_metadata</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_metadata</span><span class="o">.</span><span class="n">_values_dm</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">new_metadata</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">values</span>

        <span class="k">return</span> <span class="n">new_metadata</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">cube_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify the cube dims of any _DimensionalMetadata object.</span>

<span class="sd">        Return the dimensions in the cube of a matching _DimensionalMetadata</span>
<span class="sd">        object, if any.</span>

<span class="sd">        Equivalent to cube.coord_dims(self) for a Coord,</span>
<span class="sd">        or cube.cell_measure_dims for a CellMeasure, and so on.</span>
<span class="sd">        Simplifies generic code to handle any _DimensionalMetadata objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Only makes sense for specific subclasses.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_sanitise_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">ndmin</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">is_lazy_data</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="c1"># Lazy data : just ensure ndmin requirement.</span>
            <span class="n">ndims_missing</span> <span class="o">=</span> <span class="n">ndmin</span> <span class="o">-</span> <span class="n">src</span><span class="o">.</span><span class="n">ndim</span>
            <span class="k">if</span> <span class="n">ndims_missing</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">src</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extended_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndims_missing</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">extended_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Real data : a few more things to do in this case.</span>
            <span class="c1"># Ensure the array is writeable.</span>
            <span class="c1"># NB. Returns the *same object* if src is already writeable.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="s2">&quot;W&quot;</span><span class="p">)</span>
            <span class="c1"># Ensure the array has enough dimensions.</span>
            <span class="c1"># NB. Returns the *same object* if result.ndim &gt;= ndmin</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span> <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># We don&#39;t need to copy the data, but we do need to have our</span>
            <span class="c1"># own view so we can control the shape, etc.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The _DimensionalMetadata values as a NumPy array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="nd">@_values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># Set the values to a new array - as long as it&#39;s the same shape.</span>

        <span class="c1"># Ensure values has an ndmin of 1 and is either a numpy or lazy array.</span>
        <span class="c1"># This will avoid Scalar _DimensionalMetadata with values of shape ()</span>
        <span class="c1"># rather than the desired (1,).</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitise_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Set or update DataManager.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span> <span class="o">=</span> <span class="n">DataManager</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_lazy_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a lazy array representing the dimensional metadata values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_core_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The values array of this dimensional metadata which may be a NumPy</span>
<span class="sd">        array or a dask array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">is_lazy_data</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_has_lazy_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a boolean indicating whether the metadata&#39;s values array is a</span>
<span class="sd">        lazy dask array or not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_other_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;, long_name=</span><span class="si">{self.long_name!r}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">+=</span> <span class="s2">&quot;, var_name=</span><span class="si">{self.var_name!r}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">+=</span> <span class="s2">&quot;, attributes=</span><span class="si">{self.attributes}</span><span class="s2">&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_str_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dates_as_numbers</span><span class="p">):</span>
        <span class="n">date_obj_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">dates_as_numbers</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;separator&quot;</span><span class="p">:</span> <span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="s2">&quot;prefix&quot;</span><span class="p">:</span> <span class="s2">&quot;      &quot;</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">arrayprint</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span>
            <span class="n">date_obj_array</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">},</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Note: this method includes bounds handling code, but it only runs</span>
        <span class="c1"># within Coord type instances, as only these allow bounds to be set.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">():</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">(</span><span class="si">{values}{bounds}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;, standard_name=</span><span class="si">{self.standard_name!r}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;, calendar=</span><span class="si">{self.units.calendar!r}{other_metadata}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_long_time_interval</span><span class="p">():</span>
                <span class="c1"># A time unit with a long time interval (&quot;months&quot; or &quot;years&quot;)</span>
                <span class="c1"># cannot be converted to a date using `num2date` so gracefully</span>
                <span class="c1"># fall back to printing points as numbers, not datetimes.</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_dates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_long_time_interval</span><span class="p">():</span>
                    <span class="n">bounds_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bounds_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_dates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="s2">&quot;, bounds=</span><span class="si">{vals}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vals</span><span class="o">=</span><span class="n">bounds_vals</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="bp">cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">other_metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_repr_other_metadata</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Note: this method includes bounds handling code, but it only runs</span>
        <span class="c1"># within Coord type instances, as only these allow bounds to be set.</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">(</span><span class="si">{self._values!r}{bounds}</span><span class="s2">&quot;</span>
            <span class="s2">&quot;, standard_name=</span><span class="si">{self.standard_name!r}</span><span class="s2">, units=</span><span class="si">{self.units!r}</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="si">{other_metadata}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># if coordinate, handle the bounds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="s2">&quot;, bounds=&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">other_metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_repr_other_metadata</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Note: this method includes bounds handling code, but it only runs</span>
        <span class="c1"># within Coord type instances, as only these allow bounds to be set.</span>

        <span class="n">eq</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="c1"># If the other object has a means of getting its definition, then do</span>
        <span class="c1"># the  comparison, otherwise return a NotImplemented to let Python try</span>
        <span class="c1"># to resolve the operator elsewhere.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">):</span>
            <span class="c1"># metadata comparison</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span>
            <span class="c1"># data values comparison</span>
            <span class="k">if</span> <span class="n">eq</span> <span class="ow">and</span> <span class="n">eq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">withnans</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="c1"># Also consider bounds, if we have them.</span>
            <span class="c1"># (N.B. though only Coords can ever actually *have* bounds).</span>
            <span class="k">if</span> <span class="n">eq</span> <span class="ow">and</span> <span class="n">eq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">()</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">withnans</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">eq</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># Must supply __hash__ as Python 3 does not enable it if __eq__ is defined.</span>
    <span class="c1"># NOTE: Violates &quot;objects which compare equal must have the same hash&quot;.</span>
    <span class="c1"># We ought to remove this, as equality of two dimensional metadata can</span>
    <span class="c1"># *change*, so they really should not be hashable.</span>
    <span class="c1"># However, current code needs it, e.g. so we can put them in sets.</span>
    <span class="c1"># Fixing it will require changing those uses.  See #962 and #1772.</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__binary_operator__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">mode_constant</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Common code which is called by add, sub, mul and div</span>

<span class="sd">        Mode constant is one of ADD, SUB, MUL, DIV, RDIV</span>

<span class="sd">        .. note::</span>

<span class="sd">            The unit is *not* changed when doing scalar operations on a</span>
<span class="sd">            metadata object. This means that a metadata object which represents</span>
<span class="sd">            &quot;10 meters&quot; when multiplied by a scalar i.e. &quot;1000&quot; would result in</span>
<span class="sd">            a metadata object of &quot;10000 meters&quot;. An alternative approach could</span>
<span class="sd">            be taken to multiply the *unit* by 1000 and the resultant metadata</span>
<span class="sd">            object would represent &quot;10 kilometers&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: this method includes bounds handling code, but it only runs</span>
        <span class="c1"># within Coord type instances, as only these allow bounds to be set.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_DimensionalMetadata</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
        <span class="p">):</span>

            <span class="k">def</span> <span class="nf">typename</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Coord</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;Coord&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># We don&#39;t really expect this, but do something anyway.</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{selftype}</span><span class="s2"> </span><span class="si">{operator}</span><span class="s2"> </span><span class="si">{othertype}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">selftype</span><span class="o">=</span><span class="n">typename</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                <span class="n">operator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MODE_SYMBOL</span><span class="p">[</span><span class="n">mode_constant</span><span class="p">],</span>
                <span class="n">othertype</span><span class="o">=</span><span class="n">typename</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">NotYetImplementedError</span><span class="p">(</span><span class="n">emsg</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># &#39;Other&#39; is an array type : adjust points, and bounds if any.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>

            <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">mode_constant</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_ADD</span><span class="p">:</span>
                    <span class="n">new_values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">+</span> <span class="n">other</span>
                <span class="k">elif</span> <span class="n">mode_constant</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_SUB</span><span class="p">:</span>
                    <span class="n">new_values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">-</span> <span class="n">other</span>
                <span class="k">elif</span> <span class="n">mode_constant</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_MUL</span><span class="p">:</span>
                    <span class="n">new_values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">*</span> <span class="n">other</span>
                <span class="k">elif</span> <span class="n">mode_constant</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_DIV</span><span class="p">:</span>
                    <span class="n">new_values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">/</span> <span class="n">other</span>
                <span class="k">elif</span> <span class="n">mode_constant</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_RDIV</span><span class="p">:</span>
                    <span class="n">new_values</span> <span class="o">=</span> <span class="n">other</span> <span class="o">/</span> <span class="n">values</span>
                <span class="k">return</span> <span class="n">new_values</span>

            <span class="n">new_values</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">())</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                <span class="n">result</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binary_operator__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_ADD</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binary_operator__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_SUB</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binary_operator__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_MUL</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binary_operator__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_DIV</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binary_operator__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_DIV</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binary_operator__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_RDIV</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binary_operator__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MODE_RDIV</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_core_values</span><span class="p">()</span>
        <span class="n">copy_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">copy_args</span><span class="p">[</span><span class="s2">&quot;bounds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">core_bounds</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">copy_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the units, converting the values of the metadata.&quot;&quot;&quot;</span>
        <span class="c1"># If the coord has units convert the values in points (and bounds if</span>
        <span class="c1"># present).</span>
        <span class="c1"># Note: this method includes bounds handling code, but it only runs</span>
        <span class="c1"># within Coord type instances, as only these allow bounds to be set.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot convert from unknown units. &quot;</span>
                <span class="s1">&#39;The &quot;units&quot; attribute may be set directly.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Set up a delayed conversion for use if either values or bounds (if</span>
        <span class="c1"># present) are lazy.</span>
        <span class="c1"># Make fixed copies of old + new units for a delayed conversion.</span>
        <span class="n">old_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
        <span class="n">new_unit</span> <span class="o">=</span> <span class="n">unit</span>

        <span class="c1"># Define a delayed conversion operation (i.e. a callback).</span>
        <span class="k">def</span> <span class="nf">pointwise_convert</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">old_unit</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_lazy_values</span><span class="p">():</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">lazy_elementwise</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_values</span><span class="p">(),</span> <span class="n">pointwise_convert</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">new_values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_lazy_bounds</span><span class="p">():</span>
                <span class="n">new_bounds</span> <span class="o">=</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">lazy_elementwise</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lazy_bounds</span><span class="p">(),</span> <span class="n">pointwise_convert</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">new_bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">unit</span>

    <span class="k">def</span> <span class="nf">is_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the current dimensional metadata object is compatible</span>
<span class="sd">        with another.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">units</span>

        <span class="k">if</span> <span class="n">compatible</span><span class="p">:</span>
            <span class="n">common_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ignore</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ignore</span> <span class="o">=</span> <span class="p">(</span><span class="n">ignore</span><span class="p">,)</span>
                <span class="n">common_keys</span> <span class="o">=</span> <span class="n">common_keys</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ignore</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">common_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                    <span class="n">compatible</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">compatible</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The NumPy dtype of the current dimensional metadata object, as</span>
<span class="sd">        specified by its values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of dimensions of the current dimensional metadata</span>
<span class="sd">        object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">def</span> <span class="nf">has_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean indicating whether the current dimensional metadata</span>
<span class="sd">        object has a bounds array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Allows for code to handle unbounded dimensional metadata agnostic of</span>
        <span class="c1"># whether the metadata is a coordinate or not.</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The fundamental shape of the metadata, expressed as a tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="nf">xml_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a DOM element describing this metadata.&quot;&quot;&quot;</span>
        <span class="c1"># Create the XML element as the camelCaseEquivalent of the</span>
        <span class="c1"># class name.</span>
        <span class="n">element_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">element_name</span> <span class="o">=</span> <span class="n">element_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="n">element_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="n">element_name</span><span class="p">)</span>

        <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xml_id</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_name</span><span class="p">:</span>
            <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;standard_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">standard_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span><span class="p">:</span>
            <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;long_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">:</span>
            <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;var_name&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_name</span><span class="p">))</span>
        <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;units&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Coord</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">climatological</span><span class="p">:</span>
                <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span>
                    <span class="s2">&quot;climatological&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">climatological</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="n">attributes_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;attributes&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">attribute_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;attribute&quot;</span><span class="p">)</span>
                <span class="n">attribute_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">attribute_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span>
                    <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">attributes_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">attribute_element</span><span class="p">)</span>
            <span class="n">element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">attributes_element</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Coord</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span><span class="p">:</span>
                <span class="n">element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span><span class="o">.</span><span class="n">xml_element</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>

        <span class="c1"># Add the values</span>
        <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;value_type&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_type_name</span><span class="p">()))</span>
        <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="c1"># The values are referred to &quot;points&quot; of a coordinate and &quot;data&quot;</span>
        <span class="c1"># otherwise.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Coord</span><span class="p">):</span>
            <span class="n">values_term</span> <span class="o">=</span> <span class="s2">&quot;points&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values_term</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>
        <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="n">values_term</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xml_array_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">element</span>

    <span class="k">def</span> <span class="nf">_xml_id_extra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique_value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">unique_value</span>

    <span class="k">def</span> <span class="nf">_xml_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Returns a consistent, unique string identifier for this coordinate.</span>
        <span class="n">unique_value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_name</span><span class="p">:</span>
            <span class="n">unique_value</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="n">unique_value</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span><span class="p">:</span>
            <span class="n">unique_value</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="n">unique_value</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span>
        <span class="n">unique_value</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">unique_value</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span>
        <span class="c1"># Extra modifications to unique_value that are specialised in child</span>
        <span class="c1"># classes</span>
        <span class="n">unique_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xml_id_extra</span><span class="p">(</span><span class="n">unique_value</span><span class="p">)</span>
        <span class="c1"># Mask to ensure consistency across Python versions &amp; platforms.</span>
        <span class="n">crc</span> <span class="o">=</span> <span class="n">zlib</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">unique_value</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%08x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">crc</span><span class="p">,)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_xml_array_repr</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;to_xml_attr&quot;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">to_xml_attr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">format_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_value_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A simple, readable name for the data type of the dimensional metadata</span>
<span class="sd">        values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core_values</span><span class="p">()</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;SU&quot;</span><span class="p">:</span>
            <span class="c1"># Establish the basic type name for &#39;string&#39; type data.</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                <span class="n">value_type_name</span> <span class="o">=</span> <span class="s2">&quot;bytes&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value_type_name</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_type_name</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="n">value_type_name</span>


<div class="viewcode-block" id="AncillaryVariable"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.AncillaryVariable">[docs]</a><span class="k">class</span> <span class="nc">AncillaryVariable</span><span class="p">(</span><span class="n">_DimensionalMetadata</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a single ancillary variable.</span>

<span class="sd">        Args:</span>

<span class="sd">        * data:</span>
<span class="sd">            The values of the ancillary variable.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * standard_name:</span>
<span class="sd">            CF standard name of the ancillary variable.</span>
<span class="sd">        * long_name:</span>
<span class="sd">            Descriptive name of the ancillary variable.</span>
<span class="sd">        * var_name:</span>
<span class="sd">            The netCDF variable name for the ancillary variable.</span>
<span class="sd">        * units</span>
<span class="sd">            The :class:`~cf_units.Unit` of the ancillary variable&#39;s values.</span>
<span class="sd">            Can be a string, which will be converted to a Unit object.</span>
<span class="sd">        * attributes</span>
<span class="sd">            A dictionary containing other cf and user-defined attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Configure the metadata manager.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_metadata_manager&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span> <span class="o">=</span> <span class="n">metadata_manager_factory</span><span class="p">(</span>
                <span class="n">AncillaryVariableMetadata</span>
            <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">values</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">standard_name</span><span class="o">=</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="n">long_name</span><span class="o">=</span><span class="n">long_name</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">data</span>

<div class="viewcode-block" id="AncillaryVariable.lazy_data"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.AncillaryVariable.lazy_data">[docs]</a>    <span class="k">def</span> <span class="nf">lazy_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a lazy array representing the ancillary variable&#39;s data.</span>

<span class="sd">        Accessing this method will never cause the data values to be loaded.</span>
<span class="sd">        Similarly, calling methods on, or indexing, the returned Array</span>
<span class="sd">        will not cause the ancillary variable to have loaded data.</span>

<span class="sd">        If the data have already been loaded for the ancillary variable, the</span>
<span class="sd">        returned Array will be a new lazy array wrapper.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A lazy array, representing the ancillary variable data array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_lazy_values</span><span class="p">()</span></div>

<div class="viewcode-block" id="AncillaryVariable.core_data"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.AncillaryVariable.core_data">[docs]</a>    <span class="k">def</span> <span class="nf">core_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The data array at the core of this ancillary variable, which may be a</span>
<span class="sd">        NumPy array or a dask array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_core_values</span><span class="p">()</span></div>

<div class="viewcode-block" id="AncillaryVariable.has_lazy_data"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.AncillaryVariable.has_lazy_data">[docs]</a>    <span class="k">def</span> <span class="nf">has_lazy_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean indicating whether the ancillary variable&#39;s data array</span>
<span class="sd">        is a lazy dask array or not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_has_lazy_values</span><span class="p">()</span></div>

<div class="viewcode-block" id="AncillaryVariable.cube_dims"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.AncillaryVariable.cube_dims">[docs]</a>    <span class="k">def</span> <span class="nf">cube_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cube dimensions of this AncillaryVariable.</span>

<span class="sd">        Equivalent to &quot;cube.ancillary_variable_dims(self)&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">ancillary_variable_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CellMeasure"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.CellMeasure">[docs]</a><span class="k">class</span> <span class="nc">CellMeasure</span><span class="p">(</span><span class="n">AncillaryVariable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A CF Cell Measure, providing area or volume properties of a cell</span>
<span class="sd">    where these cannot be inferred from the Coordinates and</span>
<span class="sd">    Coordinate Reference System.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">measure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a single cell measure.</span>

<span class="sd">        Args:</span>

<span class="sd">        * data:</span>
<span class="sd">            The values of the measure for each cell.</span>
<span class="sd">            Either a &#39;real&#39; array (:class:`numpy.ndarray`) or a &#39;lazy&#39; array</span>
<span class="sd">            (:class:`dask.array.Array`).</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * standard_name:</span>
<span class="sd">            CF standard name of the coordinate.</span>
<span class="sd">        * long_name:</span>
<span class="sd">            Descriptive name of the coordinate.</span>
<span class="sd">        * var_name:</span>
<span class="sd">            The netCDF variable name for the coordinate.</span>
<span class="sd">        * units</span>
<span class="sd">            The :class:`~cf_units.Unit` of the coordinate&#39;s values.</span>
<span class="sd">            Can be a string, which will be converted to a Unit object.</span>
<span class="sd">        * attributes</span>
<span class="sd">            A dictionary containing other CF and user-defined attributes.</span>
<span class="sd">        * measure</span>
<span class="sd">            A string describing the type of measure. Supported values are</span>
<span class="sd">            &#39;area&#39; and &#39;volume&#39;. The default is &#39;area&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Configure the metadata manager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span> <span class="o">=</span> <span class="n">metadata_manager_factory</span><span class="p">(</span><span class="n">CellMeasureMetadata</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">standard_name</span><span class="o">=</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="n">long_name</span><span class="o">=</span><span class="n">long_name</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">measure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">measure</span> <span class="o">=</span> <span class="s2">&quot;area&quot;</span>

        <span class="c1">#: String naming the measure type.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure</span> <span class="o">=</span> <span class="n">measure</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">measure</span>

    <span class="nd">@measure</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measure</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">measure</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="s2">&quot;volume&quot;</span><span class="p">]:</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;measure must be &#39;area&#39; or &#39;volume&#39;, got </span><span class="si">{</span><span class="n">measure</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emsg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">measure</span> <span class="o">=</span> <span class="n">measure</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">(</span><span class="si">{self.data!r}</span><span class="s2">, &quot;</span>
            <span class="s2">&quot;measure=</span><span class="si">{self.measure!r}</span><span class="s2">, standard_name=</span><span class="si">{self.standard_name!r}</span><span class="s2">, &quot;</span>
            <span class="s2">&quot;units=</span><span class="si">{self.units!r}{other_metadata}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">other_metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_repr_other_metadata</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="CellMeasure.cube_dims"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.CellMeasure.cube_dims">[docs]</a>    <span class="k">def</span> <span class="nf">cube_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cube dimensions of this CellMeasure.</span>

<span class="sd">        Equivalent to &quot;cube.cell_measure_dims(self)&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">cell_measure_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="CellMeasure.xml_element"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.CellMeasure.xml_element">[docs]</a>    <span class="k">def</span> <span class="nf">xml_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="c1"># Create the XML element as the camelCaseEquivalent of the</span>
        <span class="c1"># class name</span>
        <span class="n">element</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">xml_element</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">)</span>

        <span class="c1"># Add the &#39;measure&#39; property</span>
        <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;measure&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">element</span></div></div>


<div class="viewcode-block" id="CoordExtent"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.CoordExtent">[docs]</a><span class="k">class</span> <span class="nc">CoordExtent</span><span class="p">(</span>
    <span class="n">namedtuple</span><span class="p">(</span>
        <span class="s2">&quot;_CoordExtent&quot;</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="s2">&quot;name_or_coord&quot;</span><span class="p">,</span>
            <span class="s2">&quot;minimum&quot;</span><span class="p">,</span>
            <span class="s2">&quot;maximum&quot;</span><span class="p">,</span>
            <span class="s2">&quot;min_inclusive&quot;</span><span class="p">,</span>
            <span class="s2">&quot;max_inclusive&quot;</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">)</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines a range of values for a coordinate.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">name_or_coord</span><span class="p">,</span>
        <span class="n">minimum</span><span class="p">,</span>
        <span class="n">maximum</span><span class="p">,</span>
        <span class="n">min_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">max_inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a CoordExtent for the specified coordinate and range of</span>
<span class="sd">        values.</span>

<span class="sd">        Args:</span>

<span class="sd">        * name_or_coord</span>
<span class="sd">            Either a coordinate name or a coordinate, as defined in</span>
<span class="sd">            :meth:`iris.cube.Cube.coords()`.</span>

<span class="sd">        * minimum</span>
<span class="sd">            The minimum value of the range to select.</span>

<span class="sd">        * maximum</span>
<span class="sd">            The maximum value of the range to select.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * min_inclusive</span>
<span class="sd">            If True, coordinate values equal to `minimum` will be included</span>
<span class="sd">            in the selection. Default is True.</span>

<span class="sd">        * max_inclusive</span>
<span class="sd">            If True, coordinate values equal to `maximum` will be included</span>
<span class="sd">            in the selection. Default is True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">name_or_coord</span><span class="p">,</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">min_inclusive</span><span class="p">,</span> <span class="n">max_inclusive</span>
        <span class="p">)</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span></div>


<span class="c1"># Coordinate cell styles. Used in plot and cartography.</span>
<span class="n">POINT_MODE</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">BOUND_MODE</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">BOUND_POSITION_START</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">BOUND_POSITION_MIDDLE</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">BOUND_POSITION_END</span> <span class="o">=</span> <span class="mi">1</span>


<span class="c1"># Private named tuple class for coordinate groups.</span>
<span class="n">_GroupbyItem</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;GroupbyItem&quot;</span><span class="p">,</span> <span class="s2">&quot;groupby_point, groupby_slice&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_2d_coord_bound_grid</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a grid using the bounds of a 2D coordinate with 4 sided cells.</span>

<span class="sd">    Assumes that the four vertices of the cells are in an anti-clockwise order</span>
<span class="sd">    (bottom-left, bottom-right, top-right, top-left).</span>

<span class="sd">    Selects the zeroth vertex of each cell. A final column is added, which</span>
<span class="sd">    contains the first vertex of the cells in the final column. A final row</span>
<span class="sd">    is added, which contains the third vertex of all the cells in the final</span>
<span class="sd">    row, except for in the final column where it uses the second vertex.</span>
<span class="sd">    e.g.</span>
<span class="sd">    # 0-0-0-0-1</span>
<span class="sd">    # 0-0-0-0-1</span>
<span class="sd">    # 3-3-3-3-2</span>

<span class="sd">    Args:</span>
<span class="sd">    * bounds: (array)</span>
<span class="sd">        Coordinate bounds array of shape (Y, X, 4)</span>

<span class="sd">    Returns:</span>
<span class="sd">    * grid: (array)</span>
<span class="sd">        Grid of shape (Y+1, X+1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check bds has the shape (ny, nx, 4)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Bounds for 2D coordinates must be 3-dimensional and &quot;</span>
            <span class="s2">&quot;have 4 bounds per point.&quot;</span>
        <span class="p">)</span>

    <span class="n">bounds_shape</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">bounds_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">result</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="Cell"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Cell">[docs]</a><span class="k">class</span> <span class="nc">Cell</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Cell&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;point&quot;</span><span class="p">,</span> <span class="s2">&quot;bound&quot;</span><span class="p">])):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An immutable representation of a single cell of a coordinate, including the</span>
<span class="sd">    sample point and/or boundary position.</span>

<span class="sd">    Notes on cell comparison:</span>

<span class="sd">    Cells are compared in two ways, depending on whether they are</span>
<span class="sd">    compared to another Cell, or to a number/string.</span>

<span class="sd">    Cell-Cell comparison is defined to produce a strict ordering. If</span>
<span class="sd">    two cells are not exactly equal (i.e. including whether they both</span>
<span class="sd">    define bounds or not) then they will have a consistent relative</span>
<span class="sd">    order.</span>

<span class="sd">    Cell-number and Cell-string comparison is defined to support</span>
<span class="sd">    Constraint matching. The number/string will equal the Cell if, and</span>
<span class="sd">    only if, it is within the Cell (including on the boundary). The</span>
<span class="sd">    relative comparisons (lt, le, ..) are defined to be consistent with</span>
<span class="sd">    this interpretation. So for a given value `n` and Cell `cell`, only</span>
<span class="sd">    one of the following can be true:</span>

<span class="sd">    |    n &lt; cell</span>
<span class="sd">    |    n == cell</span>
<span class="sd">    |    n &gt; cell</span>

<span class="sd">    Similarly, `n &lt;= cell` implies either `n &lt; cell` or `n == cell`.</span>
<span class="sd">    And `n &gt;= cell` implies either `n &gt; cell` or `n == cell`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This subclass adds no attributes.</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="c1"># Make this class&#39;s comparison operators override those of numpy</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Cell from point or point-and-bound information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Point must be defined.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Point may only be a list or tuple if it has &quot;</span> <span class="s2">&quot;length 1.&quot;</span>
                <span class="p">)</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">bound</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">point</span> <span class="o">%</span> <span class="n">mod</span>
        <span class="k">if</span> <span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">val</span> <span class="o">%</span> <span class="n">mod</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bound</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Cell</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">bound</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">point</span> <span class="o">+</span> <span class="n">mod</span>
        <span class="k">if</span> <span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">val</span> <span class="o">+</span> <span class="n">mod</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bound</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Cell</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">bound</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares Cell equality depending on the type of the object to be</span>
<span class="sd">        compared.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="s2">&quot;timetuple&quot;</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Cell</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">point</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># Must supply __ne__, Python does not defer to __eq__ for negative equality</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__common_cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">operator_method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Common method called by the rich comparison operators. The method of</span>
<span class="sd">        checking equality depends on the type of the object to be compared.</span>

<span class="sd">        Cell vs Cell comparison is used to define a strict order.</span>
<span class="sd">        Non-Cell vs Cell comparison is used to define Constraint matching.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">Cell</span><span class="p">))</span>
            <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;timetuple&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected type of other &quot;</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">operator_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected operator_method&quot;</span><span class="p">)</span>

        <span class="c1"># Prevent silent errors resulting from missing cftime</span>
        <span class="c1"># behaviour.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">cftime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">PartialDateTime</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot determine the order of &quot;</span> <span class="s2">&quot;cftime.datetime objects&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Cell</span><span class="p">):</span>
            <span class="c1"># Cell vs Cell comparison for providing a strict sort order</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Point vs point</span>
                    <span class="c1"># - Simple ordering</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Point vs point-and-bound</span>
                    <span class="c1"># - Simple ordering of point values, but if the two</span>
                    <span class="c1">#   points are equal, we make the arbitrary choice</span>
                    <span class="c1">#   that the point-only Cell is defined as less than</span>
                    <span class="c1">#   the point-and-bound Cell.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">point</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Point-and-bound vs point</span>
                    <span class="c1"># - Simple ordering of point values, but if the two</span>
                    <span class="c1">#   points are equal, we make the arbitrary choice</span>
                    <span class="c1">#   that the point-only Cell is defined as less than</span>
                    <span class="c1">#   the point-and-bound Cell.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">point</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Point-and-bound vs point-and-bound</span>
                    <span class="c1"># - Primarily ordered on minimum-bound. If the</span>
                    <span class="c1">#   minimum-bounds are equal, then ordered on</span>
                    <span class="c1">#   maximum-bound. If the maximum-bounds are also</span>
                    <span class="c1">#   equal, then ordered on point values.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Cell vs number (or string, or datetime-like) for providing</span>
            <span class="c1"># Constraint behaviour.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Point vs number</span>
                <span class="c1"># - Simple matching</span>
                <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;timetuple&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot determine whether a point lies &quot;</span>
                        <span class="s2">&quot;within a bounded region for &quot;</span>
                        <span class="s2">&quot;datetime-like objects.&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># Point-and-bound vs number</span>
                <span class="c1"># - Match if &quot;within&quot; the Cell</span>
                <span class="k">if</span> <span class="n">operator_method</span> <span class="ow">in</span> <span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">]:</span>
                    <span class="n">me</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">me</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span>

            <span class="c1"># Work around to handle cftime.datetime comparison, which</span>
            <span class="c1"># doesn&#39;t return NotImplemented on failure in some versions of the</span>
            <span class="c1"># library</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">operator_method</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">rop</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
                <span class="p">}[</span><span class="n">operator_method</span><span class="p">]</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">rop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">me</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__common_cmp__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__common_cmp__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__common_cmp__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__common_cmp__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>

<div class="viewcode-block" id="Cell.contains_point"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Cell.contains_point">[docs]</a>    <span class="k">def</span> <span class="nf">contains_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a bounded cell, returns whether the given point lies within the</span>
<span class="sd">        bounds.</span>

<span class="sd">        .. note:: The test carried out is equivalent to min(bound)</span>
<span class="sd">                  &lt;= point &lt;= max(bound).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Point cannot exist inside an unbounded cell.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="s2">&quot;timetuple&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;timetuple&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot determine whether a point lies within &quot;</span>
                <span class="s2">&quot;a bounded region for datetime-like objects.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">point</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Coord"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord">[docs]</a><span class="k">class</span> <span class="nc">Coord</span><span class="p">(</span><span class="n">_DimensionalMetadata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Superclass for coordinates.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coord_system</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">climatological</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a single coordinate.</span>

<span class="sd">        Args:</span>

<span class="sd">        * points:</span>
<span class="sd">            The values (or value in the case of a scalar coordinate) for each</span>
<span class="sd">            cell of the coordinate.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * standard_name:</span>
<span class="sd">            CF standard name of the coordinate.</span>
<span class="sd">        * long_name:</span>
<span class="sd">            Descriptive name of the coordinate.</span>
<span class="sd">        * var_name:</span>
<span class="sd">            The netCDF variable name for the coordinate.</span>
<span class="sd">        * units</span>
<span class="sd">            The :class:`~cf_units.Unit` of the coordinate&#39;s values.</span>
<span class="sd">            Can be a string, which will be converted to a Unit object.</span>
<span class="sd">        * bounds</span>
<span class="sd">            An array of values describing the bounds of each cell. Given n</span>
<span class="sd">            bounds for each cell, the shape of the bounds array should be</span>
<span class="sd">            points.shape + (n,). For example, a 1d coordinate with 100 points</span>
<span class="sd">            and two bounds per cell would have a bounds array of shape</span>
<span class="sd">            (100, 2)</span>
<span class="sd">            Note if the data is a climatology, `climatological`</span>
<span class="sd">            should be set.</span>
<span class="sd">        * attributes</span>
<span class="sd">            A dictionary containing other cf and user-defined attributes.</span>
<span class="sd">        * coord_system</span>
<span class="sd">            A :class:`~iris.coord_systems.CoordSystem` representing the</span>
<span class="sd">            coordinate system of the coordinate,</span>
<span class="sd">            e.g. a :class:`~iris.coord_systems.GeogCS` for a longitude Coord.</span>
<span class="sd">        * climatological (bool):</span>
<span class="sd">            When True: the coordinate is a NetCDF climatological time axis.</span>
<span class="sd">            When True: saving in NetCDF will give the coordinate variable a</span>
<span class="sd">            &#39;climatology&#39; attribute and will create a boundary variable called</span>
<span class="sd">            &#39;&lt;coordinate-name&gt;_climatology&#39; in place of a standard bounds</span>
<span class="sd">            attribute and bounds variable.</span>
<span class="sd">            Will set to True when a climatological time axis is loaded</span>
<span class="sd">            from NetCDF.</span>
<span class="sd">            Always False if no bounds exist.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Configure the metadata manager.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_metadata_manager&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span> <span class="o">=</span> <span class="n">metadata_manager_factory</span><span class="p">(</span><span class="n">CoordMetadata</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">values</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
            <span class="n">standard_name</span><span class="o">=</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="n">long_name</span><span class="o">=</span><span class="n">long_name</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1">#: Relevant coordinate system (if any).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span> <span class="o">=</span> <span class="n">coord_system</span>

        <span class="c1"># Set up bounds DataManager attributes and the bounds values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">climatological</span> <span class="o">=</span> <span class="n">climatological</span>

<div class="viewcode-block" id="Coord.copy"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this coordinate.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * points: A points array for the new coordinate.</span>
<span class="sd">                  This may be a different shape to the points of the coordinate</span>
<span class="sd">                  being copied.</span>

<span class="sd">        * bounds: A bounds array for the new coordinate.</span>
<span class="sd">                  Given n bounds for each cell, the shape of the bounds array</span>
<span class="sd">                  should be points.shape + (n,). For example, a 1d coordinate</span>
<span class="sd">                  with 100 points and two bounds per cell would have a bounds</span>
<span class="sd">                  array of shape (100, 2).</span>

<span class="sd">        .. note:: If the points argument is specified and bounds are not, the</span>
<span class="sd">                  resulting coordinate will have no bounds.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If bounds are specified, points must also be &quot;</span> <span class="s2">&quot;specified&quot;</span>
            <span class="p">)</span>

        <span class="n">new_coord</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Regardless of whether bounds are provided as an argument, new</span>
            <span class="c1"># points will result in new bounds, discarding those copied from</span>
            <span class="c1"># self.</span>
            <span class="n">new_coord</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>

        <span class="k">return</span> <span class="n">new_coord</span></div>

<div class="viewcode-block" id="Coord.from_coord"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.from_coord">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_coord</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new Coord of this type, from the given coordinate.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;points&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">core_points</span><span class="p">(),</span>
            <span class="s2">&quot;bounds&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">core_bounds</span><span class="p">(),</span>
            <span class="s2">&quot;standard_name&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">long_name</span><span class="p">,</span>
            <span class="s2">&quot;var_name&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span>
            <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
            <span class="s2">&quot;attributes&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span>
            <span class="s2">&quot;coord_system&quot;</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">coord_system</span><span class="p">),</span>
            <span class="s2">&quot;climatological&quot;</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">climatological</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">DimCoord</span><span class="p">):</span>
            <span class="c1"># DimCoord introduces an extra constructor keyword.</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;circular&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The coordinate points values as a NumPy array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

    <span class="nd">@points</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">points</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The coordinate bounds values, as a NumPy array,</span>
<span class="sd">        or None if no bound values are defined.</span>

<span class="sd">        .. note:: The shape of the bound array should be: ``points.shape +</span>
<span class="sd">            (n_bounds, )``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bounds</span>

    <span class="nd">@bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="c1"># Ensure the bounds are a compatible shape.</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">climatological</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitise_array</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Bounds shape must be compatible with points &quot;</span> <span class="s2">&quot;shape.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">()</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_bounds</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">):</span>
                <span class="c1"># Construct a new bounds DataManager.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span> <span class="o">=</span> <span class="n">DataManager</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coord_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The coordinate-system of the coordinate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">coord_system</span>

    <span class="nd">@coord_system</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">coord_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">coord_system</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">climatological</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A boolean that controls whether the coordinate is a climatological</span>
<span class="sd">        time axis, in which case the bounds represent a climatological period</span>
<span class="sd">        rather than a normal period.</span>

<span class="sd">        Always reads as False if there are no bounds.</span>
<span class="sd">        On set, the input value is cast to a boolean, exceptions raised</span>
<span class="sd">        if units are not time units or if there are no bounds.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">climatological</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">climatological</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">climatological</span>

    <span class="nd">@climatological</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">climatological</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Ensure the bounds are a compatible shape.</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">():</span>
                <span class="n">emsg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Cannot set climatological coordinate, does not have&quot;</span>
                    <span class="s2">&quot; valid time reference units, got </span><span class="si">{!r}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;Cannot set climatological coordinate, no bounds exist.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emsg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">climatological</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Coord.lazy_points"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.lazy_points">[docs]</a>    <span class="k">def</span> <span class="nf">lazy_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a lazy array representing the coord points.</span>

<span class="sd">        Accessing this method will never cause the points values to be loaded.</span>
<span class="sd">        Similarly, calling methods on, or indexing, the returned Array</span>
<span class="sd">        will not cause the coord to have loaded points.</span>

<span class="sd">        If the data have already been loaded for the coord, the returned</span>
<span class="sd">        Array will be a new lazy array wrapper.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A lazy array, representing the coord points array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_lazy_values</span><span class="p">()</span></div>

<div class="viewcode-block" id="Coord.lazy_bounds"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.lazy_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">lazy_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a lazy array representing the coord bounds.</span>

<span class="sd">        Accessing this method will never cause the bounds values to be loaded.</span>
<span class="sd">        Similarly, calling methods on, or indexing, the returned Array</span>
<span class="sd">        will not cause the coord to have loaded bounds.</span>

<span class="sd">        If the data have already been loaded for the coord, the returned</span>
<span class="sd">        Array will be a new lazy array wrapper.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A lazy array representing the coord bounds array or `None` if the</span>
<span class="sd">            coord does not have bounds.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lazy_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">lazy_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">lazy_bounds</span></div>

<div class="viewcode-block" id="Coord.core_points"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.core_points">[docs]</a>    <span class="k">def</span> <span class="nf">core_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The points array at the core of this coord, which may be a NumPy array</span>
<span class="sd">        or a dask array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_core_values</span><span class="p">()</span></div>

<div class="viewcode-block" id="Coord.core_bounds"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.core_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">core_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The points array at the core of this coord, which may be a NumPy array</span>
<span class="sd">        or a dask array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">is_lazy_data</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Coord.has_lazy_points"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.has_lazy_points">[docs]</a>    <span class="k">def</span> <span class="nf">has_lazy_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean indicating whether the coord&#39;s points array is a</span>
<span class="sd">        lazy dask array or not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_has_lazy_values</span><span class="p">()</span></div>

<div class="viewcode-block" id="Coord.has_lazy_bounds"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.has_lazy_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">has_lazy_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean indicating whether the coord&#39;s bounds array is a</span>
<span class="sd">        lazy dask array or not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">has_lazy_data</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">_repr_other_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_repr_other_metadata</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;, coord_system=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">climatological</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;, climatological=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">climatological</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># Must supply __hash__ as Python 3 does not enable it if __eq__ is defined.</span>
    <span class="c1"># NOTE: Violates &quot;objects which compare equal must have the same hash&quot;.</span>
    <span class="c1"># We ought to remove this, as equality of two coords can *change*, so they</span>
    <span class="c1"># really should not be hashable.</span>
    <span class="c1"># However, current code needs it, e.g. so we can put them in sets.</span>
    <span class="c1"># Fixing it will require changing those uses.  See #962 and #1772.</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Coord.cube_dims"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.cube_dims">[docs]</a>    <span class="k">def</span> <span class="nf">cube_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cube dimensions of this Coord.</span>

<span class="sd">        Equivalent to &quot;cube.coord_dims(self)&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cube</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Coord.convert_units"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.convert_units">[docs]</a>    <span class="k">def</span> <span class="nf">convert_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the coordinate&#39;s units, converting the values in its points</span>
<span class="sd">        and bounds arrays.</span>

<span class="sd">        For example, if a coordinate&#39;s :attr:`~iris.coords.Coord.units`</span>
<span class="sd">        attribute is set to radians then::</span>

<span class="sd">            coord.convert_units(&#39;degrees&#39;)</span>

<span class="sd">        will change the coordinate&#39;s</span>
<span class="sd">        :attr:`~iris.coords.Coord.units` attribute to degrees and</span>
<span class="sd">        multiply each value in :attr:`~iris.coords.Coord.points` and</span>
<span class="sd">        :attr:`~iris.coords.Coord.bounds` by 180.0/:math:`\pi`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="Coord.cells"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.cells">[docs]</a>    <span class="k">def</span> <span class="nf">cells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable of Cell instances for this Coord.</span>

<span class="sd">        For example::</span>

<span class="sd">           for cell in self.cells():</span>
<span class="sd">              ...</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_CellIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_sanity_check_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbounds</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid operation for </span><span class="si">{!r}</span><span class="s2">, with </span><span class="si">{}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;bound(s). Contiguous bounds are only &quot;</span>
                    <span class="s2">&quot;defined for 1D coordinates with 2 &quot;</span>
                    <span class="s2">&quot;bounds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbounds</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbounds</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid operation for </span><span class="si">{!r}</span><span class="s2">, with </span><span class="si">{}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;bound(s). Contiguous bounds are only &quot;</span>
                    <span class="s2">&quot;defined for 2D coordinates with 4 &quot;</span>
                    <span class="s2">&quot;bounds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbounds</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid operation for </span><span class="si">{!r}</span><span class="s2">. Contiguous bounds &quot;</span>
                <span class="s2">&quot;are not defined for coordinates with more than &quot;</span>
                <span class="s2">&quot;2 dimensions.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_discontiguity_in_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks that the bounds of the coordinate are contiguous.</span>

<span class="sd">        Kwargs:</span>
<span class="sd">        * rtol: (float)</span>
<span class="sd">            Relative tolerance that is used when checking contiguity. Defaults</span>
<span class="sd">            to 1e-5.</span>
<span class="sd">        * atol: (float)</span>
<span class="sd">            Absolute tolerance that is used when checking contiguity. Defaults</span>
<span class="sd">            to 1e-8.</span>

<span class="sd">        Returns:</span>
<span class="sd">        * contiguous: (boolean)</span>
<span class="sd">            True if there are no discontiguities.</span>
<span class="sd">        * diffs: (array or tuple of arrays)</span>
<span class="sd">            The diffs along the bounds of the coordinate. If self is a 2D</span>
<span class="sd">            coord of shape (Y, X), a tuple of arrays is returned, where the</span>
<span class="sd">            first is an array of differences along the x-axis, of the shape</span>
<span class="sd">            (Y, X-1) and the second is an array of differences along the</span>
<span class="sd">            y-axis, of the shape (Y-1, X).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check_bounds</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">contiguous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span>
            <span class="p">)</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">mod360_adjust</span><span class="p">(</span><span class="n">compare_axis</span><span class="p">):</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">compare_axis</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                    <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">compare_axis</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                    <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;grid_longitude&quot;</span><span class="p">]:</span>
                    <span class="c1"># If longitude, adjust for longitude wrapping</span>
                    <span class="n">diffs</span> <span class="o">=</span> <span class="n">upper_bounds</span> <span class="o">-</span> <span class="n">lower_bounds</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">diffs</span> <span class="o">&gt;</span> <span class="mi">180</span>
                    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span>
                        <span class="n">modification</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">360</span><span class="p">)</span> <span class="o">*</span> <span class="n">sign</span>
                        <span class="n">upper_bounds</span> <span class="o">-=</span> <span class="n">modification</span>

                <span class="n">diffs_between_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">upper_bounds</span> <span class="o">-</span> <span class="n">lower_bounds</span><span class="p">)</span>
                <span class="n">cell_size</span> <span class="o">=</span> <span class="n">lower_bounds</span> <span class="o">-</span> <span class="n">upper_bounds</span>
                <span class="n">diffs_along_axis</span> <span class="o">=</span> <span class="n">diffs_between_cells</span> <span class="o">&gt;</span> <span class="p">(</span>
                    <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">cell_size</span>
                <span class="p">)</span>

                <span class="n">points_close_enough</span> <span class="o">=</span> <span class="n">diffs_along_axis</span> <span class="o">&lt;=</span> <span class="p">(</span>
                    <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">cell_size</span>
                <span class="p">)</span>
                <span class="n">contiguous_along_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">points_close_enough</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">diffs_along_axis</span><span class="p">,</span> <span class="n">contiguous_along_axis</span>

            <span class="n">diffs_along_x</span><span class="p">,</span> <span class="n">match_cell_x1</span> <span class="o">=</span> <span class="n">mod360_adjust</span><span class="p">(</span><span class="n">compare_axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
            <span class="n">diffs_along_y</span><span class="p">,</span> <span class="n">match_cell_y1</span> <span class="o">=</span> <span class="n">mod360_adjust</span><span class="p">(</span><span class="n">compare_axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

            <span class="n">contiguous</span> <span class="o">=</span> <span class="n">match_cell_x1</span> <span class="ow">and</span> <span class="n">match_cell_y1</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">diffs_along_x</span><span class="p">,</span> <span class="n">diffs_along_y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">contiguous</span><span class="p">,</span> <span class="n">diffs</span>

<div class="viewcode-block" id="Coord.is_contiguous"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.is_contiguous">[docs]</a>    <span class="k">def</span> <span class="nf">is_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if, and only if, this Coord is bounded with contiguous</span>
<span class="sd">        bounds to within the specified relative and absolute tolerances.</span>

<span class="sd">        1D coords are contiguous if the upper bound of a cell aligns,</span>
<span class="sd">        within a tolerance, to the lower bound of the next cell along.</span>

<span class="sd">        2D coords, with 4 bounds, are contiguous if the lower right corner of</span>
<span class="sd">        each cell aligns with the lower left corner of the cell to the right of</span>
<span class="sd">        it, and the upper left corner of each cell aligns with the lower left</span>
<span class="sd">        corner of the cell above it.</span>

<span class="sd">        Args:</span>

<span class="sd">        * rtol:</span>
<span class="sd">            The relative tolerance parameter (default is 1e-05).</span>
<span class="sd">        * atol:</span>
<span class="sd">            The absolute tolerance parameter (default is 1e-08).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">contiguous</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discontiguity_in_bounds</span><span class="p">(</span><span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">contiguous</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">contiguous</span></div>

<div class="viewcode-block" id="Coord.contiguous_bounds"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.contiguous_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">contiguous_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the N+1 bound values for a contiguous bounded 1D coordinate</span>
<span class="sd">        of length N, or the (N+1, M+1) bound values for a contiguous bounded 2D</span>
<span class="sd">        coordinate of shape (N, M).</span>

<span class="sd">        Only 1D or 2D coordinates are supported.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the coordinate has bounds, this method assumes they are</span>
<span class="sd">            contiguous.</span>

<span class="sd">            If the coordinate is 1D and does not have bounds, this method will</span>
<span class="sd">            return bounds positioned halfway between the coordinate&#39;s points.</span>

<span class="sd">            If the coordinate is 2D and does not have bounds, an error will be</span>
<span class="sd">            raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Coordinate </span><span class="si">{!r}</span><span class="s2"> is not bounded, guessing &quot;</span>
                    <span class="s2">&quot;contiguous bounds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
                <span class="p">)</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_guess_bounds</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;2D coordinate </span><span class="si">{!r}</span><span class="s2"> is not bounded. Guessing &quot;</span>
                    <span class="s2">&quot;bounds of 2D coords is not currently &quot;</span>
                    <span class="s2">&quot;supported.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sanity_check_bounds</span><span class="p">()</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">c_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">c_bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">c_bounds</span> <span class="o">=</span> <span class="n">_get_2d_coord_bound_grid</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c_bounds</span></div>

<div class="viewcode-block" id="Coord.is_monotonic"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.is_monotonic">[docs]</a>    <span class="k">def</span> <span class="nf">is_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if, and only if, this Coord is monotonic.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">monotonic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">b_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbounds</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">monotonic</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">b_index</span><span class="p">],</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Coord.is_compatible"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.is_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">is_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the coordinate is compatible with another.</span>

<span class="sd">        Compatibility is determined by comparing</span>
<span class="sd">        :meth:`iris.coords.Coord.name()`, :attr:`iris.coords.Coord.units`,</span>
<span class="sd">        :attr:`iris.coords.Coord.coord_system` and</span>
<span class="sd">        :attr:`iris.coords.Coord.attributes` that are present in both objects.</span>

<span class="sd">        Args:</span>

<span class="sd">        * other:</span>
<span class="sd">            An instance of :class:`iris.coords.Coord`,</span>
<span class="sd">            :class:`iris.common.CoordMetadata` or</span>
<span class="sd">            :class:`iris.common.DimCoordMetadata`.</span>
<span class="sd">        * ignore:</span>
<span class="sd">           A single attribute key or iterable of attribute keys to ignore when</span>
<span class="sd">           comparing the coordinates. Default is None. To ignore all</span>
<span class="sd">           attributes, set this to other.attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">           Boolean.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">coord_system</span><span class="p">:</span>
            <span class="n">compatible</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">compatible</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The NumPy dtype of the coord&#39;s bounds. Will be `None` if the coord</span>
<span class="sd">        does not have bounds.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of bounds that this coordinate has (0 for no bounds).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nbounds</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">nbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nbounds</span>

<div class="viewcode-block" id="Coord.has_bounds"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.has_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">has_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean indicating whether the coord has a bounds array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Coord.cell"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.cell">[docs]</a>    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the single :class:`Cell` instance which results from slicing the</span>
<span class="sd">        points/bounds with the given index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_build_full_slice_given_keys</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="n">point</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;The index </span><span class="si">%s</span><span class="s2"> did not uniquely identify a single &quot;</span>
                <span class="s2">&quot;point to create a cell with.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span>
            <span class="p">)</span>

        <span class="n">bound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">():</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Cell</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">bound</span><span class="p">)</span></div>

<div class="viewcode-block" id="Coord.collapsed"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.collapsed">[docs]</a>    <span class="k">def</span> <span class="nf">collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims_to_collapse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this coordinate, which has been collapsed along</span>
<span class="sd">        the specified dimensions.</span>

<span class="sd">        Replaces the points &amp; bounds with a simple bounded region.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

        <span class="c1"># Ensure dims_to_collapse is a tuple to be able to pass</span>
        <span class="c1"># through to numpy</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims_to_collapse</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">dims_to_collapse</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims_to_collapse</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims_to_collapse</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">dims_to_collapse</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims_to_collapse</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">):</span>
            <span class="c1"># Collapse the coordinate by serializing the points and</span>
            <span class="c1"># bounds as strings.</span>
            <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span>

            <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                    <span class="n">index_slice</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">serialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">index_slice</span><span class="p">]))</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;U</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">bounds</span><span class="p">))))</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">serialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;U</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)))</span>
            <span class="c1"># Create the new collapsed coordinate.</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Collapse the coordinate by calculating the bounded extremes.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Collapsing a multi-dimensional coordinate. &quot;</span>
                    <span class="s2">&quot;Metadata may not be fully descriptive for </span><span class="si">{!r}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_contiguous</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Collapsing a non-contiguous coordinate. &quot;</span>
                    <span class="s2">&quot;Metadata may not be fully descriptive for </span><span class="si">{!r}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
                <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_bounds</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dims_to_collapse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Express main dims_to_collapse as non-negative integers</span>
                    <span class="c1"># and add the last (bounds specific) dimension.</span>
                    <span class="n">dims_to_collapse</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="n">dim</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims_to_collapse</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_points</span><span class="p">()</span>

            <span class="c1"># Determine the array library for stacking</span>
            <span class="n">al</span> <span class="o">=</span> <span class="n">da</span> <span class="k">if</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">is_lazy_data</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span>

            <span class="c1"># Calculate the bounds and points along the right dims</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">al</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">dims_to_collapse</span><span class="p">),</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">dims_to_collapse</span><span class="p">),</span>
                <span class="p">],</span>
                <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">al</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Create the new collapsed coordinate.</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coord</span></div>

    <span class="k">def</span> <span class="nf">_guess_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bound_position</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return bounds for this coordinate based on its points.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * bound_position:</span>
<span class="sd">            The desired position of the bounds relative to the position</span>
<span class="sd">            of the points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A numpy array of shape (len(self.points), 2).</span>

<span class="sd">        .. note::</span>

<span class="sd">            This method only works for coordinates with ``coord.ndim == 1``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX Consider moving into DimCoord</span>
        <span class="c1"># ensure we have monotonic points</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Need monotonic points to generate bounds for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot guess bounds for a coordinate of length &quot;</span> <span class="s2">&quot;1.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Coord already has bounds. Remove the bounds &quot;</span>
                <span class="s2">&quot;before guessing new ones.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span> <span class="o">*</span> <span class="n">direction</span><span class="p">)</span>
            <span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span> <span class="o">*</span> <span class="n">direction</span><span class="p">)</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">diffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="n">diffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">min_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">-</span> <span class="n">diffs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">bound_position</span>
        <span class="n">max_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">+</span> <span class="n">diffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">bound_position</span><span class="p">)</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">min_bounds</span><span class="p">,</span> <span class="n">max_bounds</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;grid_latitude&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;degree&quot;</span>
        <span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">points</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">90</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">points</span> <span class="o">&lt;=</span> <span class="mi">90</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bounds</span>

<div class="viewcode-block" id="Coord.guess_bounds"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.guess_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">guess_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bound_position</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add contiguous bounds to a coordinate, calculated from its points.</span>

<span class="sd">        Puts a cell boundary at the specified fraction between each point and</span>
<span class="sd">        the next, plus extrapolated lowermost and uppermost bound points, so</span>
<span class="sd">        that each point lies within a cell.</span>

<span class="sd">        With regularly spaced points, the resulting bounds will also be</span>
<span class="sd">        regular, and all points lie at the same position within their cell.</span>
<span class="sd">        With irregular points, the first and last cells are given the same</span>
<span class="sd">        widths as the ones next to them.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * bound_position:</span>
<span class="sd">            The desired position of the bounds relative to the position</span>
<span class="sd">            of the points.</span>

<span class="sd">        .. note::</span>

<span class="sd">            An error is raised if the coordinate already has bounds, is not</span>
<span class="sd">            one-dimensional, or is not monotonic.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Unevenly spaced values, such from a wrapped longitude range, can</span>
<span class="sd">            produce unexpected results :  In such cases you should assign</span>
<span class="sd">            suitable values directly to the bounds property, instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_guess_bounds</span><span class="p">(</span><span class="n">bound_position</span><span class="p">)</span></div>

<div class="viewcode-block" id="Coord.intersect"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.intersect">[docs]</a>    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new coordinate from the intersection of two coordinates.</span>

<span class="sd">        Both coordinates must be compatible as defined by</span>
<span class="sd">        :meth:`~iris.coords.Coord.is_compatible`.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * return_indices:</span>
<span class="sd">            If True, changes the return behaviour to return the intersection</span>
<span class="sd">            indices for the &quot;self&quot; coordinate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;The coordinates cannot be intersected. They are not &quot;</span>
                <span class="s2">&quot;compatible because of differing metadata.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Cache self.cells for speed. We can also use the index operation on a</span>
        <span class="c1"># list conveniently.</span>
        <span class="n">self_cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">()]</span>

        <span class="c1"># Maintain a list of indices on self for which cells exist in both self</span>
        <span class="c1"># and other.</span>
        <span class="n">self_intersect_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">cells</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">self_intersect_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">self_cells</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">return_indices</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">self_intersect_indices</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No intersection between </span><span class="si">%s</span><span class="s2"> coords possible.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="n">self_intersect_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">self_intersect_indices</span><span class="p">)</span>

        <span class="c1"># Return either the indices, or a Coordinate instance of the</span>
        <span class="c1"># intersection.</span>
        <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self_intersect_indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">self_intersect_indices</span><span class="p">]</span></div>

<div class="viewcode-block" id="Coord.nearest_neighbour_index"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.nearest_neighbour_index">[docs]</a>    <span class="k">def</span> <span class="nf">nearest_neighbour_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of the cell nearest to the given point.</span>

<span class="sd">        Only works for one-dimensional coordinates.</span>

<span class="sd">        For example:</span>

<span class="sd">        &gt;&gt;&gt; cube = iris.load_cube(iris.sample_data_path(&#39;ostia_monthly.nc&#39;))</span>
<span class="sd">        &gt;&gt;&gt; cube.coord(&#39;latitude&#39;).nearest_neighbour_index(0)</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt; cube.coord(&#39;longitude&#39;).nearest_neighbour_index(10)</span>
<span class="sd">        12</span>

<span class="sd">        .. note:: If the coordinate contains bounds, these will be used to</span>
<span class="sd">            determine the nearest neighbour instead of the point values.</span>

<span class="sd">        .. note:: For circular coordinates, the &#39;nearest&#39; point can wrap around</span>
<span class="sd">            to the other end of the values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Nearest-neighbour is currently limited&quot;</span>
                <span class="s2">&quot; to one-dimensional coordinates.&quot;</span>
            <span class="p">)</span>
        <span class="n">do_circular</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_circular</span><span class="p">:</span>
            <span class="n">wrap_modulus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span>
            <span class="c1"># wrap &#39;point&#39; to a range based on lowest points or bounds value.</span>
            <span class="n">wrap_origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">points</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">flatten</span><span class="p">())))</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">wrap_origin</span> <span class="o">+</span> <span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="n">wrap_origin</span><span class="p">)</span> <span class="o">%</span> <span class="n">wrap_modulus</span>

        <span class="c1"># Calculate the nearest neighbour.</span>
        <span class="c1"># The algorithm:  given a single value (V),</span>
        <span class="c1">#   if coord has bounds,</span>
        <span class="c1">#     make bounds cells complete and non-overlapping</span>
        <span class="c1">#     return first cell containing V</span>
        <span class="c1">#   else (no bounds),</span>
        <span class="c1">#     find the point which is closest to V</span>
        <span class="c1">#     or if two are equally close, return the lowest index</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="c1"># make bounds ranges complete+separate, so point is in at least one</span>
            <span class="n">increasing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># sort the bounds cells by their centre values</span>
            <span class="n">sort_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">sort_inds</span><span class="p">]</span>
            <span class="c1"># replace all adjacent bounds with their averages</span>
            <span class="k">if</span> <span class="n">increasing</span><span class="p">:</span>
                <span class="n">mid_bounds</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_bounds</span>
                <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_bounds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mid_bounds</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_bounds</span>
                <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_bounds</span>

            <span class="c1"># if point lies beyond either end, fix the end cell to include it</span>
            <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># get index of first-occurring cell that contains the point</span>
            <span class="n">inside_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">point</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">point</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">result_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inside_cells</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># return the original index of the cell (before the bounds sort)</span>
            <span class="n">result_index</span> <span class="o">=</span> <span class="n">sort_inds</span><span class="p">[</span><span class="n">result_index</span><span class="p">]</span>

        <span class="c1"># Or, if no bounds, we always have points ...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">do_circular</span><span class="p">:</span>
                <span class="c1"># add an extra, wrapped max point (simpler than bounds case)</span>
                <span class="c1"># NOTE: circular implies a DimCoord, so *must* be monotonic</span>
                <span class="k">if</span> <span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># ascending value order : add wrapped lowest value to end</span>
                    <span class="n">index_offset</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">points</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">wrap_modulus</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># descending order : add wrapped lowest value at start</span>
                    <span class="n">index_offset</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wrap_modulus</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span>
            <span class="c1"># return index of first-occurring nearest point</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">points</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span>
            <span class="n">result_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">do_circular</span><span class="p">:</span>
                <span class="c1"># convert index back from circular-adjusted points</span>
                <span class="n">result_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">result_index</span> <span class="o">-</span> <span class="n">index_offset</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result_index</span></div>

<div class="viewcode-block" id="Coord.xml_element"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.Coord.xml_element">[docs]</a>    <span class="k">def</span> <span class="nf">xml_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a DOM element describing this Coord.&quot;&quot;&quot;</span>
        <span class="c1"># Create the XML element as the camelCaseEquivalent of the</span>
        <span class="c1"># class name</span>
        <span class="n">element</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">xml_element</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">)</span>

        <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xml_array_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>

        <span class="c1"># Add bounds handling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_bounds</span><span class="p">():</span>
            <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xml_array_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">element</span></div>

    <span class="k">def</span> <span class="nf">_xml_id_extra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coord specific stuff for the xml id&quot;&quot;&quot;</span>
        <span class="n">unique_value</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_system</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">unique_value</span></div>


<div class="viewcode-block" id="DimCoord"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.DimCoord">[docs]</a><span class="k">class</span> <span class="nc">DimCoord</span><span class="p">(</span><span class="n">Coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A coordinate that is 1D, numeric, and strictly monotonic.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DimCoord.from_regular"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.DimCoord.from_regular">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_regular</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">zeroth</span><span class="p">,</span>
        <span class="n">step</span><span class="p">,</span>
        <span class="n">count</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coord_system</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">circular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">climatological</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">with_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a :class:`DimCoord` with regularly spaced points, and</span>
<span class="sd">        optionally bounds.</span>

<span class="sd">        The majority of the arguments are defined as for</span>
<span class="sd">        :meth:`Coord.__init__`, but those which differ are defined below.</span>

<span class="sd">        Args:</span>

<span class="sd">        * zeroth:</span>
<span class="sd">            The value *prior* to the first point value.</span>
<span class="sd">        * step:</span>
<span class="sd">            The numeric difference between successive point values.</span>
<span class="sd">        * count:</span>
<span class="sd">            The number of point values.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * with_bounds:</span>
<span class="sd">            If True, the resulting DimCoord will possess bound values</span>
<span class="sd">            which are equally spaced around the points. Otherwise no</span>
<span class="sd">            bounds values will be defined. Defaults to False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">zeroth</span> <span class="o">+</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">regular</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">points_step</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">regular</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">zeroth</span> <span class="o">+</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="p">)</span>
        <span class="n">points</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">with_bounds</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">step</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">points</span> <span class="o">-</span> <span class="n">delta</span><span class="p">],</span> <span class="p">[</span><span class="n">points</span> <span class="o">+</span> <span class="n">delta</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span>
            <span class="n">standard_name</span><span class="o">=</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="n">long_name</span><span class="o">=</span><span class="n">long_name</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
            <span class="n">coord_system</span><span class="o">=</span><span class="n">coord_system</span><span class="p">,</span>
            <span class="n">circular</span><span class="o">=</span><span class="n">circular</span><span class="p">,</span>
            <span class="n">climatological</span><span class="o">=</span><span class="n">climatological</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">standard_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coord_system</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">circular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">climatological</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a 1D, numeric, and strictly monotonic :class:`Coord` with</span>
<span class="sd">        read-only points and bounds.</span>

<span class="sd">        Args:</span>

<span class="sd">        * points:</span>
<span class="sd">            1D numpy array-like of values (or single value in the case of a</span>
<span class="sd">            scalar coordinate) for each cell of the coordinate.  The values</span>
<span class="sd">            must be strictly monotonic and masked values are not allowed.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * standard_name:</span>
<span class="sd">            CF standard name of the coordinate.</span>
<span class="sd">        * long_name:</span>
<span class="sd">            Descriptive name of the coordinate.</span>
<span class="sd">        * var_name:</span>
<span class="sd">            The netCDF variable name for the coordinate.</span>
<span class="sd">        * units:</span>
<span class="sd">            The :class:`~cf_units.Unit` of the coordinate&#39;s values.</span>
<span class="sd">            Can be a string, which will be converted to a Unit object.</span>
<span class="sd">        * bounds:</span>
<span class="sd">            An array of values describing the bounds of each cell. Given n</span>
<span class="sd">            bounds and m cells, the shape of the bounds array should be</span>
<span class="sd">            (m, n). For each bound, the values must be strictly monotonic along</span>
<span class="sd">            the cells, and the direction of monotonicity must be consistent</span>
<span class="sd">            across the bounds.  For example, a DimCoord with 100 points and two</span>
<span class="sd">            bounds per cell would have a bounds array of shape (100, 2), and</span>
<span class="sd">            the slices ``bounds[:, 0]`` and ``bounds[:, 1]`` would be monotonic</span>
<span class="sd">            in the same direction.  Masked values are not allowed.</span>
<span class="sd">            Note if the data is a climatology, `climatological`</span>
<span class="sd">            should be set.</span>
<span class="sd">        * attributes:</span>
<span class="sd">            A dictionary containing other cf and user-defined attributes.</span>
<span class="sd">        * coord_system:</span>
<span class="sd">            A :class:`~iris.coord_systems.CoordSystem` representing the</span>
<span class="sd">            coordinate system of the coordinate,</span>
<span class="sd">            e.g. a :class:`~iris.coord_systems.GeogCS` for a longitude Coord.</span>
<span class="sd">        * circular (bool):</span>
<span class="sd">            Whether the coordinate wraps by the :attr:`~iris.coords.DimCoord.units.modulus`</span>
<span class="sd">            i.e., the longitude coordinate wraps around the full great circle.</span>
<span class="sd">        * climatological (bool):</span>
<span class="sd">            When True: the coordinate is a NetCDF climatological time axis.</span>
<span class="sd">            When True: saving in NetCDF will give the coordinate variable a</span>
<span class="sd">            &#39;climatology&#39; attribute and will create a boundary variable called</span>
<span class="sd">            &#39;&lt;coordinate-name&gt;_climatology&#39; in place of a standard bounds</span>
<span class="sd">            attribute and bounds variable.</span>
<span class="sd">            Will set to True when a climatological time axis is loaded</span>
<span class="sd">            from NetCDF.</span>
<span class="sd">            Always False if no bounds exist.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Configure the metadata manager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span> <span class="o">=</span> <span class="n">metadata_manager_factory</span><span class="p">(</span><span class="n">DimCoordMetadata</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span>
            <span class="n">standard_name</span><span class="o">=</span><span class="n">standard_name</span><span class="p">,</span>
            <span class="n">long_name</span><span class="o">=</span><span class="n">long_name</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
            <span class="n">coord_system</span><span class="o">=</span><span class="n">coord_system</span><span class="p">,</span>
            <span class="n">climatological</span><span class="o">=</span><span class="n">climatological</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1">#: Whether the coordinate wraps by ``coord.units.modulus``.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circular</span> <span class="o">=</span> <span class="n">circular</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        coord.__deepcopy__() -&gt; Deep copy of coordinate.</span>

<span class="sd">        Used if copy.deepcopy is called on a coordinate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_coord</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">super</span><span class="p">(),</span> <span class="n">memo</span><span class="p">)</span>
        <span class="c1"># Ensure points and bounds arrays are read-only.</span>
        <span class="n">new_coord</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">new_coord</span><span class="o">.</span><span class="n">_bounds_dm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_coord</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">new_coord</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">circular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">circular</span>

    <span class="nd">@circular</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">circular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">circular</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_manager</span><span class="o">.</span><span class="n">circular</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">circular</span><span class="p">)</span>

<div class="viewcode-block" id="DimCoord.copy"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.DimCoord.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">new_coord</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="c1"># Make the arrays read-only.</span>
        <span class="n">new_coord</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_coord</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">new_coord</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DimCoord</span><span class="p">):</span>
            <span class="c1"># The &quot;circular&quot; member participates in DimCoord to DimCoord</span>
            <span class="c1"># equivalence. We require to do this explicitly here</span>
            <span class="c1"># as the &quot;circular&quot; member does NOT participate in</span>
            <span class="c1"># DimCoordMetadata to DimCoordMetadata equivalence.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circular</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># The __ne__ operator from Coord implements the not __eq__ method.</span>

    <span class="c1"># For Python 3, we must explicitly re-implement the &#39;__hash__&#39; method, as</span>
    <span class="c1"># defining an &#39;__eq__&#39; has blocked its inheritance.  See ...</span>
    <span class="c1"># https://docs.python.org/3.1/reference/datamodel.html#object.__hash__</span>
    <span class="c1"># &quot;If a class that overrides __eq__() needs to retain the</span>
    <span class="c1"># implementation of __hash__() from a parent class, the interpreter</span>
    <span class="c1"># must be told this explicitly&quot;.</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="n">Coord</span><span class="o">.</span><span class="fm">__hash__</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">coord</span><span class="o">.</span><span class="n">circular</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="n">coord</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">coord</span>

<div class="viewcode-block" id="DimCoord.collapsed"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.DimCoord.collapsed">[docs]</a>    <span class="k">def</span> <span class="nf">collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims_to_collapse</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">Coord</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims_to_collapse</span><span class="o">=</span><span class="n">dims_to_collapse</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">circular</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bnds</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">bnds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">modulus</span>
            <span class="n">coord</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bnds</span>
            <span class="n">coord</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>
        <span class="c1"># XXX This isn&#39;t actually correct, but is ported from the old world.</span>
        <span class="n">coord</span><span class="o">.</span><span class="n">circular</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">coord</span></div>

    <span class="k">def</span> <span class="nf">_repr_other_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Coord</span><span class="o">.</span><span class="n">_repr_other_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;, circular=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">circular</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_new_points_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Confirm that a new set of coord points adheres to the requirements for</span>
<span class="sd">        :class:`~iris.coords.DimCoord` points, being:</span>
<span class="sd">            * points are scalar or 1D,</span>
<span class="sd">            * points are numeric,</span>
<span class="sd">            * points are not masked, and</span>
<span class="sd">            * points are monotonic.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;The </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> points array must be scalar or 1-dimensional.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;The </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> points array must be numeric.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;A </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> points array must not be masked.&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">monotonic</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;The </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> points array must be strictly monotonic.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="nd">@Coord</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># DimCoord always realises the points, to allow monotonicity checks.</span>
        <span class="c1"># Ensure it is an actual array, and also make our own copy so that we</span>
        <span class="c1"># can make it read-only.</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">as_concrete_data</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># Make sure that we have an array (any type of array).</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># Check validity requirements for dimension-coordinate points.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_points_requirements</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># Cast to a numpy array for masked arrays with no mask.</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">DimCoord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Re-fetch the core array, as the super call may replace it.</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>
            <span class="c1"># N.B. always a *real* array, as we realised &#39;points&#39; at the start.</span>

            <span class="c1"># Make the array read-only.</span>
            <span class="n">points</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_new_bounds_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Confirm that a new set of coord bounds adheres to the requirements for</span>
<span class="sd">        :class:`~iris.coords.DimCoord` bounds, being:</span>
<span class="sd">            * bounds are compatible in shape with the points</span>
<span class="sd">            * bounds are numeric,</span>
<span class="sd">            * bounds are not masked, and</span>
<span class="sd">            * bounds are monotonic in the first dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure the bounds are a compatible shape.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="ow">and</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;The shape of the </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> bounds array should be &quot;</span>
                <span class="s2">&quot;points.shape + (n_bounds)&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="c1"># Checks for numeric.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;The </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> bounds array must be numeric.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="c1"># Check not masked.</span>
        <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;A </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> bounds array must not be masked.&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="c1"># Check bounds are monotonic.</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n_bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_points</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n_points</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                <span class="n">directions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">b_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bounds</span><span class="p">):</span>
                    <span class="n">monotonic</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">monotonic</span><span class="p">(</span>
                        <span class="n">bounds</span><span class="p">[:,</span> <span class="n">b_index</span><span class="p">],</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_direction</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">monotonic</span><span class="p">:</span>
                        <span class="n">emsg</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;The </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> bounds array must be strictly &quot;</span>
                            <span class="s2">&quot;monotonic.&quot;</span>
                        <span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">directions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">emsg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;The direction of monotonicity for </span><span class="si">{!r}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> must &quot;</span>
                        <span class="s2">&quot;be consistent across all bounds.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="p">)</span>

    <span class="nd">@Coord</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Ensure we have a realised array of new bounds values.</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">_lazy</span><span class="o">.</span><span class="n">as_concrete_data</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
            <span class="c1"># Make sure we have an array (any type of array).</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

            <span class="c1"># Check validity requirements for dimension-coordinate bounds.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_bounds_requirements</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
            <span class="c1"># Cast to a numpy array for masked arrays with no mask.</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># Call the parent bounds setter.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DimCoord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Re-fetch the core array, as the super call may replace it.</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds_dm</span><span class="o">.</span><span class="n">core_data</span><span class="p">()</span>
            <span class="c1"># N.B. always a *real* array, as we realised &#39;bounds&#39; at the start.</span>

            <span class="c1"># Ensure the array is read-only.</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="DimCoord.is_monotonic"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.DimCoord.is_monotonic">[docs]</a>    <span class="k">def</span> <span class="nf">is_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="DimCoord.xml_element"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.DimCoord.xml_element">[docs]</a>    <span class="k">def</span> <span class="nf">xml_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return DOM element describing this :class:`iris.coords.DimCoord`.&quot;&quot;&quot;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">xml_element</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">circular</span><span class="p">:</span>
            <span class="n">element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;circular&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circular</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">element</span></div></div>


<div class="viewcode-block" id="AuxCoord"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.AuxCoord">[docs]</a><span class="k">class</span> <span class="nc">AuxCoord</span><span class="p">(</span><span class="n">Coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A CF auxiliary coordinate.</span>

<span class="sd">    .. note::</span>

<span class="sd">        There are currently no specific properties of :class:`AuxCoord`,</span>
<span class="sd">        everything is inherited from :class:`Coord`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">Coord</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;__doc__&quot;</span><span class="p">,),</span> <span class="n">updated</span><span class="o">=</span><span class="p">())</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># Logically, :class:`Coord` is an abstract class and all actual coords must</span>
    <span class="c1"># be members of some concrete subclass, i.e. an :class:`AuxCoord` or</span>
    <span class="c1"># a :class:`DimCoord`.</span>
    <span class="c1"># So we retain :class:`AuxCoord` as a distinct concrete subclass.</span>
    <span class="c1"># This provides clarity, backwards compatibility, and so we can add</span>
    <span class="c1"># AuxCoord-specific code if needed in future.</span>


<div class="viewcode-block" id="CellMethod"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.CellMethod">[docs]</a><span class="k">class</span> <span class="nc">CellMethod</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_OrderedHashable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a sub-cell pre-processing operation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Declare the attribute names relevant to the _OrderedHashable behaviour.</span>
    <span class="n">_names</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="s2">&quot;coord_names&quot;</span><span class="p">,</span> <span class="s2">&quot;intervals&quot;</span><span class="p">,</span> <span class="s2">&quot;comments&quot;</span><span class="p">)</span>

    <span class="c1">#: The name of the operation that was applied. e.g. &quot;mean&quot;, &quot;max&quot;, etc.</span>
    <span class="n">method</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#: The tuple of coordinate names over which the operation was applied.</span>
    <span class="n">coord_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#: A description of the original intervals over which the operation</span>
    <span class="c1">#: was applied.</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#: Additional comments.</span>
    <span class="n">comments</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>

<span class="sd">        * method:</span>
<span class="sd">            The name of the operation.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">        * coords:</span>
<span class="sd">            A single instance or sequence of :class:`.Coord` instances or</span>
<span class="sd">            coordinate names.</span>

<span class="sd">        * intervals:</span>
<span class="sd">            A single string, or a sequence strings, describing the intervals</span>
<span class="sd">            within the cell method.</span>

<span class="sd">        * comments:</span>
<span class="sd">            A single string, or a sequence strings, containing any additional</span>
<span class="sd">            comments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;method&#39; must be a string - got a &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">default_name</span> <span class="o">=</span> <span class="n">BaseMetadata</span><span class="o">.</span><span class="n">DEFAULT_NAME</span>
        <span class="n">_coords</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">Coord</span><span class="p">):</span>
            <span class="n">_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="n">token</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BaseMetadata</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="ow">or</span> <span class="n">default_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normalise</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">coord</span><span class="p">:</span> <span class="n">coord</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="n">token</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">BaseMetadata</span><span class="o">.</span><span class="n">token</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="ow">or</span> <span class="n">default_name</span>
            <span class="p">)</span>
            <span class="n">_coords</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">normalise</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>

        <span class="n">_intervals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">_intervals</span> <span class="o">=</span> <span class="p">[</span><span class="n">intervals</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>

        <span class="n">_comments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">comments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comments</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">_comments</span> <span class="o">=</span> <span class="p">[</span><span class="n">comments</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_comments</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">comments</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_coords</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_intervals</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_comments</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a custom string representation of CellMethod&quot;&quot;&quot;</span>
        <span class="c1"># Group related coord names intervals and comments together</span>
        <span class="n">cell_components</span> <span class="o">=</span> <span class="n">zip_longest</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comments</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
        <span class="p">)</span>

        <span class="n">collection_summaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cm_summary</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span>

        <span class="k">for</span> <span class="n">coord_name</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">cell_components</span><span class="p">:</span>
            <span class="n">other_info</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">chain</span><span class="p">((</span><span class="n">interval</span><span class="p">,</span> <span class="n">comment</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">other_info</span><span class="p">:</span>
                <span class="n">coord_summary</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">other_info</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coord_summary</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">coord_name</span>

            <span class="n">collection_summaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_summary</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cm_summary</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">collection_summaries</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Disable the default tuple behaviour of tuple concatenation</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="CellMethod.xml_element"><a class="viewcode-back" href="../../generated/api/iris/coords.html#iris.coords.CellMethod.xml_element">[docs]</a>    <span class="k">def</span> <span class="nf">xml_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dom element describing itself</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cellMethod_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;cellMethod&quot;</span><span class="p">)</span>
        <span class="n">cellMethod_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">coord_name</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comments</span>
        <span class="p">):</span>
            <span class="n">coord_xml_element</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s2">&quot;coord&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coord_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coord_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">coord_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">interval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">coord_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">coord_xml_element</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="s2">&quot;comment&quot;</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>
                <span class="n">cellMethod_xml_element</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span><span class="n">coord_xml_element</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cellMethod_xml_element</span></div></div>


<span class="c1"># See Coord.cells() for the description/context.</span>
<span class="k">class</span> <span class="nc">_CellIterator</span><span class="p">(</span><span class="n">Iterator</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord</span> <span class="o">=</span> <span class="n">coord</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">iris</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">CoordinateMultiDimError</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># NB. When self._indices runs out it will raise StopIteration for us.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>


<span class="c1"># See ExplicitCoord._group() for the description/context.</span>
<span class="k">class</span> <span class="nc">_GroupIterator</span><span class="p">(</span><span class="n">Iterator</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">&gt;=</span> <span class="n">num_points</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="n">num_points</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">stop</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">group</span> <span class="o">=</span> <span class="n">_GroupbyItem</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="k">return</span> <span class="n">group</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        
        &copy; <a href="../../copyright.html">Copyright</a> Iris Contributors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>